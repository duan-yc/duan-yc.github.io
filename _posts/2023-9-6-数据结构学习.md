---
layout: post
title: "数据结构学习"
subtitle: "数据结构"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
  - java
---

**数据结构学习**

数据结构：线性结构+非线形结构

线性结构

![image-20230911221742333](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230911221742333.png)

非线形结构

数组、广义表、树、图

##### **稀疏数组**

![image-20230911222140819](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230911222140819.png)

**处理方式**

![image-20230911222357195](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230911222357195.png)

**实例**

![image-20230912233425237](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230912233425237.png)

**稀疏矩阵与二维数组转化思路**

![image-20230912233516675](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230912233516675.png)

**代码实现**

```java
package sparseArray;

import java.io.*;
import java.util.ArrayList;
import java.util.Stack;
import java.io.IOException;

public class sparseArray {

    public static void main(String[] args) {
        int array[][] = new int[11][11];
        array[1][2] = 1;
        array[4][5] = 3;
        //输出数组
        for (int row[] : array) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
        //array to sparse
        int res[][]=arraytosparse(array);
        for (int row[] : res) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
        //sparse to array
        int res2[][]=sparsetoarray(res);
        for (int row[] : res2) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }
        //io
        save(res2);
        int res3[][]=read();
        for (int row[] : res2) {
            for (int data : row) {
                System.out.printf("%d\t", data);
            }
            System.out.println();
        }

    }

    public  static int[][] arraytosparse(int [][]array){
        int num=0;
        Stack<Integer>stack=new Stack<>();
        for(int i=0;i<array.length;i++){
            for(int j=0;j<array[0].length;j++){
                if(array[i][j]!=0){
                    num++;
                    stack.push(i);
                    stack.push(j);
                    stack.push(array[i][j]);
                }
            }
        }
        int res[][]=new int[num+1][3];
        res[0][0]=array.length;
        res[0][1]=array[0].length;
        res[0][2]=num;
        int i=1;
        while (!stack.isEmpty()){
            res[i][2]=stack.pop();
            res[i][1]=stack.pop();
            res[i][0]=stack.pop();
            i++;
        }
        return res;
    }

    public  static  int[][] sparsetoarray(int sparse[][]){
        int res[][]=new int[sparse[0][0]][sparse[0][1]];
        for(int k=1;k<sparse.length;k++){
            res[sparse[k][0]][sparse[k][1]]=sparse[k][2];
        }
        return res;
    }

    public static void save(int array[][]){
        try {
            FileOutputStream fileOutputStream=new FileOutputStream("map.data");
            ObjectOutputStream objectOutputStream=new ObjectOutputStream(fileOutputStream);
            objectOutputStream.writeObject(array);
            objectOutputStream.close();
            fileOutputStream.close();
            System.out.println("已保存");

        }catch (IOException ioe){
            ioe.printStackTrace();
        }
    }

    public static int[][] read()  {
        try {
            FileInputStream fileInputStream=new FileInputStream("map.data");
            ObjectInputStream objectInputStream=new ObjectInputStream(fileInputStream);
            int array[][]= (int[][]) objectInputStream.readObject();
            objectInputStream.close();
            fileInputStream.close();
            return array;
        }catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
}
```

##### 队列

###### 单向队列

![image-20230913103223124](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230913103223124.png)

**数组模拟队列**

![image-20230913103751253](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230913103751253.png)

```java
class ArrayQueue{

    private int MaxSize;   //队列最大容积
    private int front;     //队列头 代表当前位置的下一个有数据
    private int rear;      //队列尾 代表当前位置为最后一个数据
    private int[] arr;     //模拟队列

    public void ArrayQueue(int arrayMaxSize){
        MaxSize=arrayMaxSize;
        arr=new int[MaxSize];
        front=-1;
        rear=-1;
    }

    //判断队列是否满
    public boolean isFull(){
        return rear==MaxSize-1;
    }

    //判断队列是否为空
    public boolean isempty(){
        return front==rear;
    }
    //进队列
    public void addQueue(int data){
        if(isFull()){
            System.out.println("队列已满");
            return;
        }
        arr[++rear]=data;
        System.out.println("添加成功");
        return;

    }
    //出队列
    public int getQueue(){
        if(isempty()){
            throw new RuntimeException("队列空");
        }
        int res=arr[++front];
        return res;
    }
    //输出队列
    public void showQueue(){
        if(isempty()){
            System.out.println("队列为空");
            return;
        }
        for(int i=front+1;i<=rear;i++){
            System.out.printf("%d\t",arr[i]);
        }
        return;
    }
}
```

###### **环形队列**

![image-20230913115051109](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230913115051109.png)

和单独队列的front和rear的意义不一样，rear指向的是最后一个位置的下一个，这样的话就需要预留一个空间，否则就会和front相撞

```java
class CircleArrayQueue{
    private int MaxSize;   //队列最大容积
    private int front;     //队列头 代表第一个数据
    private int rear;      //队列尾 代表当前位置为最后一个数据的下一个
    private int[] arr;     //模拟队列

    public CircleArrayQueue(int maxSize){
        MaxSize=maxSize;
        front=0;
        rear=0;
        arr=new int[MaxSize];
    }

    public boolean isFull(){
        return (rear+1)%MaxSize==front;
    }

    public boolean isEmpty(){
        return rear==front;
    }

    public void addQueue(int data){
        if(isFull()){
            throw new RuntimeException("队列已满");
        }
        arr[rear++]=data;
        rear=rear%MaxSize;
        return;
    }

    public int getQueue(){
        if(isEmpty()){
            throw new RuntimeException("队列为空");
        }
        int res=arr[front++];
        front=front%MaxSize;
        return res;
    }

    public void showQueue(){
        if(isEmpty()){
            System.out.println("队列为空");
            return ;
        }
        //计算有效数据的数量
        int count=(rear-front+MaxSize)%MaxSize;
        for(int i=front;i<(rear+count);i++){
            System.out.printf("%d\t",arr[i%MaxSize]);
        }
    }
}
```

##### 链表

###### **单向链表**

**插入中间节点**

![image-20230918113924500](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230918113924500.png)

**删除节点**

![image-20230918164928564](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230918164928564.png)

```java
package linkedlist;

//定义一个链表
class Listnode {
    public int no;
    public String name;
    public Listnode next;

    public Listnode(int lno, String lname) {
        this.name = lname;
        this.no = lno;
    }

    @Override
    public String toString() {
        return "listnode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                '}';
    }
}

public class SingleLinkedList {

    public Listnode head = new Listnode(0, "");

    public static void main(String[] args) {
        Listnode a = new Listnode(1, "1");
        Listnode b = new Listnode(2, "2");
        Listnode c = new Listnode(3, "3");
        Listnode d = new Listnode(4, "4");
        Listnode e = new Listnode(5, "5");
        SingleLinkedList singleLinkedList = new SingleLinkedList();
        singleLinkedList.addlist(a);
        singleLinkedList.addlist(b);
        singleLinkedList.addlist(c);
        singleLinkedList.addlist(d);
        singleLinkedList.show();
        singleLinkedList.insert(e, 2);
        singleLinkedList.show();
        singleLinkedList.delete(5);
        singleLinkedList.show();

    }
		//从链表最后位置添加链表
    public void addlist(Listnode listnode) {
        Listnode temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = listnode;
    }
    //显示链表
    public void show() {
        if (head.next == null) {
            System.out.println("空");
            return;
        }
        Listnode listnode = head.next;
        while (listnode != null) {
            System.out.println(listnode.name);
            listnode = listnode.next;
        }
        return;
    }
		//从中间插入链表
    public void insert(Listnode listnode, int no) {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        Listnode temp = head.next;
        while (temp != null) {
            if (temp.no == no) {
                //主要是下面这两步，先把后面的位置给listnode，再让temp指向listnode
                listnode.next = temp.next;
                temp.next = listnode;
                return;
            }
            temp = temp.next;
        }
        System.out.println("未找到该节点");
        return;

    }
		//删除节点注意的是temp从head开始，这样就可以while的时候用temp.next，因为一直需要判断的是temp.next
    public void delete(int no) {
        if (head.next == null)
            return;
        Listnode temp = head;
        while (temp.next != null) {
            if (temp.next.no == no) {
                temp.next = temp.next.next;
                return;
            }
            temp = temp.next;
        }
        System.out.println("未找到");
        return;
    }
}
```

一般都是head节点不动，然后用temp节点来动，就取决于是temp=head还是temp=head.next，像插入节点这种，直接和节点相关的，就可以temp=head.next，如果是像删除或者创造链表这种和next相关的就可以temp=head

**单链表题目**

1. 求单链表有效节点个数

   ```java
   public void q1(Linkedlist head){
       if(head.next==null){
           System.out.println("null");
           return;
       }
       Linkedlist temp=head.next;
       while(temp!=null){
           System.out.printf("%d\t", temp.no);
           temp=temp.next;
       }
   
   }
   ```

2. 查找单链表的倒数第k个节点

   设置两个链表，让第一个链表先跑k个节点，再让第二个链表跑，第一个链表跑到最后时，第二个链表就为倒数第k个，需要注意的是第一个链表跑的时候需要一直判断是否为空，即判断链表长度是否有k个

   ```java
   public void q2(Linkedlist head,int no){
       if(head.next==null){
           System.out.println("链表为空");
           return;
       }
       Linkedlist l1=head;
       for(int i=0;i<no;i++){
           l1=l1.next;
           if(l1==null){
               System.out.printf("链表数量不够%d个",no);
               return;
           }
       }
       Linkedlist l2=head;
       while(l1!=null){
           l1=l1.next;
           l2=l2.next;
       }
       System.out.println(l2.no);
       return;
   }
   ```

3. 链表反转

   思路是创建一个新的链表res，每次将链表从head链表中拿出一个节点，然后在res链表的第一个位置进行插入，就实现反转的功能，需要注意的是要先保留head.next的位置，最后再返还

   ```java
       public Linkedlist q3(Linkedlist head){
           if(head==null){
               System.out.println("链表为空");
               return null;
           }
           Linkedlist res=new Linkedlist(0);
           head=head.next;
           while(head!=null){
               Linkedlist node=head.next;
               head.next=res.next;
               res.next=head;
               head=node;
           }
           return res;
       }
   ```

4. 从尾到头打印单链表

   ```java
   public void q4(Linkedlist linkedlist){
       if(linkedlist==null){
           System.out.println("null");
           return;
       }
       Stack<Linkedlist> stack=new <Linkedlist> Stack();
       Linkedlist temp=linkedlist.next;
       while(temp!=null){
           stack.push(temp);
           temp=temp.next;
       }
       while(!stack.isEmpty()){
           Linkedlist node= (Linkedlist) stack.pop();
           System.out.println(node.no);
       }
   }
   ```

5. 两个有序链表合并

   两个链表在循环中比较大小然后进行插入，等一个链表遍历完之后，将另一个链表直接续上，这里需要注意的是，**创建新链表是插入节点，不是直接更改temp的指向就可以的**

   ```java
   public Linkedlist q5(Linkedlist l1,Linkedlist l2){
       if(l1.next==null||l2.next==null){
           if(l1.next==null&&l2.next==null){
               System.out.println("两链表都为空");
               return null;
           } else if (l1.next==null) {
               return l2;
           }else {
               return l1;
           }
       }
       Linkedlist r1=l1.next;
       Linkedlist r2=l2.next;
       Linkedlist res=new Linkedlist(0);
       Linkedlist temp=res;
       while(r1!=null&&r2!=null){
           if(r1.no<r2.no){
               Linkedlist node=r1.next;
               r1.next=temp.next;
               temp.next=r1;
               temp=temp.next;
               r1=node;
           }else {
               Linkedlist node=r2.next;
               r2.next=temp.next;
               temp.next=r2;
               temp=temp.next;
               r2=node;
           }
       }
       if(r1==null){
           temp.next=r2;
       }else {
           temp.next=r1;
       }
       return res;
   }
   ```

###### **双向链表**

![image-20230919214610314](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230919214610314.png)

```java
package linkedlist;

public class doubleLinkedListDemo {
    public static void main(String[] args) {

        DoubleLinkedList head = new DoubleLinkedList(0);
        DoubleLinkedList node2 = new DoubleLinkedList(2);
        head.next = node2;
        node2.pre = head;
        DoubleLinkedList node3 = new DoubleLinkedList(3);
        node2.next = node3;
        node3.pre = node2;
        DoubleLinkedList node=new DoubleLinkedList(5);
        doubleLinkedListDemo dll = new doubleLinkedListDemo();
        dll.insert(head,node,3);
        dll.show(head);
    }
		//显示链表
    public void show(DoubleLinkedList head){
        if(head.next==null){
            System.out.println("null");
            return;
        }
        DoubleLinkedList temp=head.next;
        while(temp!=null){
            System.out.printf("%d\t",temp.no);
            temp=temp.next;
        }
        return;
    }
    //默认添加到最后
    public void add(DoubleLinkedList head,DoubleLinkedList node){
        DoubleLinkedList temp=head.next;
        while(temp!=null){
            temp=temp.next;
        }
        temp.next=node;
        node.pre=temp;
        return;
    }
	 //删除链表节点，比起单向链表要简单一些，不用再用temp.next来进行判断，不过就需要注意最后一个节点
    public void delete(DoubleLinkedList head,int no){
        if(head.next==null){
            System.out.println("null");
            return;
        }
        DoubleLinkedList temp=head.next;
        while(temp!=null){
            if(temp.no==no){
                temp.pre.next=temp.next;
                //因为和单链表不一样 不再是用temp.next进行判断，所以temp可以是最后一个节点
                // 如果是最后一个节点则不能用temp.next.pre，这会是空指针异常
                if(temp.next!=null)
                    temp.next.pre=temp.pre;
                return;
            }
            temp=temp.next;
        }
        System.out.println("未找到该节点");
        return;
    }

    public void insert(DoubleLinkedList head,DoubleLinkedList node,int no){
        if(head.next==null){
            System.out.println("null");
            return;
        }
        DoubleLinkedList temp=head.next;
        while(temp!=null){
            if(temp.no==no){
                node.next=temp.next;
                node.pre=temp;
              //同样的需要注意如果temp是最后一个节点，则需要注意空指针异常的问题
                if(temp.next!=null)
                    temp.next.pre=node;
                temp.next=node;
                return;
            }
            temp=temp.next;
        }
        System.out.println("未找到");
        return;
    }

}

class DoubleLinkedList{
    public int no;
    public DoubleLinkedList pre;
    public DoubleLinkedList next;
    public DoubleLinkedList(int no){
        this.no=no;
    }
}
```

双向链表问题，比起单向链表多一个pre，在删除节点时简单一些，在插入中间节点时要难一些，主要是都要判断temp节点为最后一个节点时，temp.next.pre的空指针异常的问题

###### 单向环形链表

![image-20230920153455519](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230920153455519.png)

```java
package linkedlist;

public class Josepfu {
    public static void main(String[] args) {
        CircleSingleLinkedList circleSingleLinkedList=new CircleSingleLinkedList();
        circleSingleLinkedList.addNode(25);
        circleSingleLinkedList.showNode();

    }
}

//创建一个node类
class Node{
    public int no;
    public Node next;
    public Node(int no){
        this.no=no;
    }
}

//创建单向环形链表
class CircleSingleLinkedList{
    private Node first=null;
    public void addNode(int num){
        //num表示需要创建节点的数量
        if(num<1){
            System.out.println("num不正确");
            return;
        }
        //作为辅助节点 便于遍历
        Node curNode=null;
        for(int i=1;i<=num;i++){
            //根据编号创建node节点
            Node node=new Node(i);
            //判断是否是第一个节点，如果是第一个节点需要先自己成一个环
           if(i==1){
               //让first指向第一个节点
               first=node;
               //让第一个节点先自己形成循环
               node.next=node;
               //让cur指向node 表示当前节点 便于添加新节点
               curNode=node;
           }
           else{
               //先将node加入链表中
               curNode.next=node;
               //让node指向头节点，形成环
               node.next=first;
               //让curNode移到当前节点
               curNode=node;
           }
        }
        return;
    }

    public void showNode(){
        if(first==null){
            System.out.println("环形链表为空");
            return;
        }
        Node temp=first;
        //需要先输出第一个，不然循环的条件就是temp.next!=first
        // 如果这样 当temp为最后一个时进不了循环，无法输出最后一个节点
        System.out.printf("%d\t",temp.no);
        temp=temp.next;
        while(temp!=first){
            System.out.printf("%d\t",temp.no);
            temp=temp.next;
        }
    }
}
```

**约瑟夫环**

**思路：**

![image-20230920173116744](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230920173116744.png)

```java
    public void josepfu(int startNo,int countNum,int nums){
        if(first==null||startNo<1||startNo>nums){
            System.out.println("输入数据有误");
            return;
        }
        //temp的作用是在delete的时候，起到在first前面的作用
        Node temp=first;
        //先通过下面循环让temp到first的前面一个
        while(temp.next!=first)
            temp=temp.next;
        //通过这个循环，到指定的初始位置
        for(int i=1;i<startNo;i++){
            first=first.next;
            temp=temp.next;
        }
        //通过下面的循环将除最后一个外的所有输出
        while(first!=temp){
            //先经过countnum个，让first到要输出的位置
            for(int i=0;i<countNum;i++){
                first=first.next;
                temp=temp.next;
            }
            //进行输出
            System.out.printf("%d\t",first.no);
            //让first到下一个位置，然后让temp指向
            // 相当于temp.next=temp.next.next
            first=first.next;
            temp.next=first;
        }
        System.out.printf("the last %d\t",first.no);
        return;
    }
```

##### 栈

栈的基本操作

```java
class ArrayStack{

    private int Maxsize;
    private int []stack;
    private int top=-1;
    public void ArrayStack(int Maxsize){
        this.Maxsize=Maxsize;
        stack=new int[Maxsize];
    }

    public boolean isFull(){
        return top==Maxsize-1;
    }
    public boolean isEmpty(){
        return top==-1;
    }

    public void push(int a){
        if(isFull()){
            System.out.println("full");
            return;
        }
        top++;
        stack[top]=a;

    }

    public int pop(){
        if(isEmpty()){
            throw new RuntimeException("栈空");
        }
        int value=stack[top];
        top--;
        return value;
    }

    public void list(){
        if(isEmpty()){
            System.out.println("栈空");
            return;
        }
        for(int i=top;i>-1;i--){
            System.out.printf("%d\t",stack[i]);
        }
        return;
    }

}
```

**栈模拟计算器**

![image-20230921134508038](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230921134508038.png)

```java
package Stack;

public class Calculator {

    public static void main(String[] args) {
        String expression="4*(3+(5-9))";
        arrayStack2 numStack=new arrayStack2(10);
        arrayStack2 operStack=new arrayStack2(10);
        int index=0;
        int num1=0;
        int num2=0;
        int oper=0;
        String countnum="";
        while(index!=expression.length()){
            char ch=expression.substring(index,index+1).charAt(0);
            index++;
            if(ch=='('){
                operStack.push(ch);

            }
            else if(ch==')'){
                while(operStack.peek()!='('){
                    num1=numStack.pop();
                    num2=numStack.pop();
                    oper=operStack.pop();
                    numStack.push(operStack.cal(num1,num2,oper));
                }
                operStack.pop();

            }
            //如果是字符
            else if(operStack.ischar(ch)){
                //如果为空 直接加入
                if(operStack.isEmpty()){
                    operStack.push(ch);
                }
                else{
                    //判断当前符号优先级更低，则先把栈内优先级更高的拿出来计算
                    if(operStack.priority(ch)<operStack.priority(operStack.peek())){
                        num1=numStack.pop();
                        num2=numStack.pop();
                        oper=operStack.pop();
                        numStack.push(operStack.cal(num1,num2,oper));
                    }
                    operStack.push(ch);
                }
            }
            //如果是数字
            else if(Character.isDigit(ch)){
                //每一次给countcum清零
                countnum="";
                countnum+=ch;
                while(index!=expression.length()&&Character.isDigit(expression.substring(index,index+1).charAt(0))){
                    ch=expression.substring(index,index+1).charAt(0);
                    countnum+=ch;
                    index++;
                }
                numStack.push(Integer.parseInt(countnum));
            }
        }
        while(!operStack.isEmpty()){
            num1=numStack.pop();
            num2=numStack.pop();
            oper=operStack.pop();
            numStack.push(operStack.cal(num1,num2,oper));
        }
        System.out.println(numStack.pop());
        return;
    }

}
class arrayStack2 {

    private int Maxsize;
    private int []stack;
    private int top=-1;
    public arrayStack2(int Maxsize){
        this.Maxsize=Maxsize;
        stack=new int[Maxsize];
    }

    public boolean isFull(){
        return top==Maxsize-1;
    }
    public boolean isEmpty(){
        return top==-1;
    }

    public void push(int a){
        if(isFull()){
            System.out.println("full");
            return;
        }
        top++;
        stack[top]=a;

    }

    public int pop(){
        if(isEmpty()){
            throw new RuntimeException("栈空");
        }
        int value=stack[top];
        top--;
        return value;
    }

    public void list(){
        if(isEmpty()){
            System.out.println("栈空");
            return;
        }
        for(int i=top;i>-1;i--){
            System.out.printf("%d\t",stack[i]);
        }
        return;
    }
    public boolean ischar(int ch){
        return ch=='+'||ch=='-'||ch=='*'||ch=='/';
    }
    //判断优先级
    public int priority(int ch){
        if(ch=='*'||ch=='/'){
            return 1;
        } else if (ch=='+'||ch=='-') {
            return 0;
        }
        return -1;
    }

    public int peek(){
        return stack[top];
    }
    public int cal(int num1,int num2,int oper){
        int res=0;
        switch (oper){
            case '+':
                res=num1+num2;
                break;
            case '-':
                res=num2-num1;
                break;
            case '*':
                res=num1*num2;
                break;
            case '/':
                res=num2/num1;
        }
        return res;
    }
}
```

**栈的三种表达式**

**前缀表达式**

![image-20230921185155088](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230921185155088.png)

**中缀表达式**

![image-20230921185621968](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230921185621968.png)

**后缀表达式**

![image-20230921185658368](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230921185658368.png)

逆波兰计算器

```java
public class PolandNotation {

    public static void main(String[] args) {
        String Expression="3 4 + 5 * 6 -";
        ArrayList<String>arrayList=StringToArrayList(Expression);
        int res=cal(arrayList);
        System.out.println(res);

    }

    public static ArrayList StringToArrayList(String Expression){
        String []ch=Expression.split(" ");
        ArrayList<String>arrayList=new ArrayList<>();
        for(String element:ch){
            arrayList.add(element);
        }
        return arrayList;
    }

    public static int cal(List<String>list){
        Stack<String>stack=new Stack<>();
        for(String item:list){
            if(item.matches("\\d+")){
                stack.push(item);
            }
            else{
                int num1=Integer.parseInt(stack.pop());
                int num2=Integer.parseInt(stack.pop());
                int res=0;
                switch (item){
                    case "+":
                        res=num1+num2;
                        break;
                    case "-":
                        res=num2-num1;
                        break;
                    case "*":
                        res=num1*num2;
                        break;
                    case "/":
                        res=num2/num1;
                }
                //res+"" 将整数转化成字符串
                stack.push(res+"");
            }
        }
        return Integer.parseInt(stack.peek());
    }
}
```

**中缀转后缀**

![image-20230922110929072](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230922110929072.png)

![image-20230922110831040](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230922110831040.png)

```java
package Stack;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Stack;

public class InpixToPost {
    //考虑的是表达式完全正确的情况下，且不出现其他运算符
    public static void main(String[] args) {
        String expression="1+((2+3)*4)-5";
        ArrayList<String>arrayList=inpixtolist(expression);
        System.out.println(IntoPost(arrayList));
    }

    public  static ArrayList<String>IntoPost(ArrayList<String> arrayList){
        ArrayList<String>res=new ArrayList<>();
        //符号栈
        Stack<String>s1=new Stack<>();
        //暂存栈
        Stack<String>s2=new Stack<>();
        for(String item:arrayList){
            //因为是字符串所以不能用==来判断字符串相等，应该用equals
            if(isCharacter(item)){
                //只有当前item优先级小于等于栈顶并且栈顶不为（并且栈不为空的时候需要将栈顶元素拿出，其余直接push
                while(!s1.isEmpty()&&!s1.peek().equals("(")&&priority(item)<=priority(s1.peek())){
                        s2.push(s1.pop());
                }
                s1.push(item);
            }else if(item.equals("(")){
                s1.push(item);
            }else if(item.equals(")")){
                while(!s1.peek().equals("(")){
                    s2.push(s1.pop());
                }
                s1.pop();
            }else {
                s2.push(item);
            }
        }
        //将s1剩下的倒入s2
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        //将s2中元入放入list中
        while(!s2.isEmpty()){
            res.add(s2.pop());
        }
        //进行反转
        Collections.reverse(res);
        return res;
    }
    public static ArrayList<String> inpixtolist(String expression){
        int index=0;
        String countnum="";
        ArrayList<String>arrayList=new ArrayList<>();
        while(index!=expression.length()){
            char ch=expression.charAt(index);
            index++;
            if(Character.isDigit(ch)){
                countnum="";
                countnum+=ch;
                while(index!=expression.length()&&Character.isDigit(expression.charAt(index))){
                    ch=expression.charAt(index);
                    countnum+=ch;
                    index++;
                }
                arrayList.add(countnum);
            }else{
                arrayList.add(ch+"");
            }
        }
        return arrayList;
    }

    public static int priority(String ch){
        if(ch.equals("+")||ch.equals("-"))
            return 0;
        if(ch.equals("*")||ch.equals("/"))
            return 1;
        return 0;
    }
    public static boolean isCharacter(String ch){
        return ch.equals("+")||ch.equals("-")||ch.equals("*")||ch.equals("/");
    }

}
```
