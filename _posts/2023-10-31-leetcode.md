---
layout: post
title: "leetcode"
subtitle: "leetcode"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
  - java
---

### 链表

##### 双指针

###### [分隔链表](https://leetcode.cn/problems/partition-list/)

思路 定义两个链表，一个存储小的，一个存储大于等于的，最后进行拼接

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode bigger=new ListNode(-1);
        ListNode biggertemp=bigger;
        ListNode smaller=new ListNode(-1);
        ListNode smallertemp=smaller;
        while(head!=null){
            if(head.val>=x){
                biggertemp.next=head;
                head=head.next;
                biggertemp=biggertemp.next;
            }else{
                smallertemp.next=head;
                head=head.next;
                smallertemp=smallertemp.next;
            }
        }
        biggertemp.next=null;
        smallertemp.next=bigger.next;
        return smaller.next;
    }
}
```

###### [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1==null||list2==null){
            if(list1!=null)
                return list1;
            else
                return list2;
        }
        ListNode result=new ListNode(-1);
        ListNode temp=result;
        while(list1!=null&&list2!=null){
            if(list1.val>list2.val){
                temp.next=list2;
                temp=temp.next;
                list2=list2.next;
            }else{
                temp.next=list1;
                temp=temp.next;
                list1=list1.next;
            }
        }
        if(list1==null)
            temp.next=list2;
        else if(list2==null)
            temp.next=list1;
        return result.next;
    }
}
```

###### [ 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

解法1️⃣

思路：循环遍历，以第一个链表为标准，不断把后面的链表插入第一个链表中

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists==null||lists.length==0)
            return null;
        ListNode res=new ListNode(-1);
        res.next=lists[0];
        for(int i=1;i<lists.length;i++){
            ListNode p1=res;
            ListNode p2=lists[i];
            while(p1.next!=null&&p2!=null){
                if(p1.next.val<p2.val){
                    p1=p1.next;
                }else{
                    ListNode temp=p2.next;
                    p2.next=p1.next;
                    p1.next=p2;
                    p2=temp;
                    p1=p1.next;
                }
            }
            if(p2!=null){
                p1.next=p2;
            }
        }
        return res.next;
    }
}
```

解法2️⃣

思路：将数组中各个链表头节点加入有序队列中，然后定义一个新的链表加入其中最小的头节点，如果被加入的那个链表不为空，把它的下一个加入有序队列中，继续进行比较，知道队列为空

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0)
            return null;
        PriorityQueue<ListNode>queue=new PriorityQueue<>(
            lists.length,(a,b)->(a.val-b.val)
        );
        for(ListNode head:lists){
            if(head!=null)
                queue.add(head);
        }
        ListNode res=new ListNode(-1);
        ListNode temp=res;
        while(!queue.isEmpty()){
            ListNode node=queue.poll();
            temp.next=node;
            if(node.next!=null)
                queue.add(node.next);
            temp=temp.next;
        }
        return res.next;
    }
}
```

###### [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/SLwz0R/)

双链表，一个快指针，一个慢指针，让快指针先走n个，慢指针再走

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null)
            return null;
        int index=0;
        ListNode fast=new ListNode(-1);
        ListNode slow=new ListNode(-1);
        fast.next=head;
        slow.next=head;
        ListNode slowtemp=slow;
        while(fast.next!=null&&index<n){
            fast=fast.next;
            index++;
        }
        if(fast.next==null&&index<n){
            return null;
        }
        while(fast.next!=null){
            fast=fast.next;
            slowtemp=slowtemp.next;
        }
        slowtemp.next=slowtemp.next.next;
        return slow.next;
        
    }
}
```

###### [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

方法1️⃣

直接首先while循环一遍计数，然后for循环

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode temp=head;
        int num=0;
        while(temp!=null){
            temp=temp.next;
            num++;
        }
        ListNode res=head;
        for(int i=0;i<num/2;i++){
            res=res.next;
        }
        return res;
    }
}
```

方法2️⃣

设置快指针

```java
ListNode middleNode(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
    }
    // 慢指针指向中点
    return slow;
}
```

###### [环形链表](https://leetcode.cn/problems/linked-list-cycle/)

思路：定义一个快指针和一个慢指针，如果两个能相遇，那就说明是环形

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)
                return true;
        }
        return false;
    }
}
```

###### [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

思路：**当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置**

原理：我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

![image-20231101175243112](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101175243112.png)

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

![image-20231101175916495](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101175916495.png)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)
                break;
        }
        if(fast==null||fast.next==null)
            return null;
        slow=head;
        while(fast!=slow){
            fast=fast.next;
            slow=slow.next;
        }
        return slow;

    }
}
```

###### [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

解法1️⃣

思路：将一个链表加入hashset中进行判断

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        HashSet<ListNode>hashset1=new HashSet<>();
        while(headA!=null){
            hashset1.add(headA);
            headA=headA.next;
        }
        while(headB!=null){
            if(hashset1.contains(headB))
                return headB;
            headB=headB.next;
        }
        return null;
    }
}
```

解法2️⃣

思路：将headA遍历完A之后遍历B，让headB遍历完B之后遍历A，这样如果两者能相遇就说明有交点，如果没有交点，那就都遍历完都为空，退出循环

![image-20231102160749946](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102160749946.png)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1=headA;
        ListNode p2=headB;
        while(p1!=p2){
            if(p1!=null)
                p1=p1.next;
            else
                p1=headB;
            if(p2!=null)
                p2=p2.next;
            else
                p2=headA;
        }
        return p1;
    }
}
```

###### [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null)
            return null;
        ListNode slow=head,fast=head;
        while(fast!=null){
            if(fast.val!=slow.val){
                slow=slow.next;
                slow.val=fast.val;
            }
            fast=fast.next;
        }
        slow.next=null;
        return head;
    }
}
```

##### 反转链表

###### [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode res=new ListNode(-1);
        while(head!=null){
            ListNode temp=head.next;
            head.next=res.next;
            res.next=head;
            head=temp;
        }
        return res.next;
    }
}
```

方法2️⃣：递归的方式

```java
class Solution {
    public ListNode reverseList(ListNode head) {
    	if(head==null||head.next==null){
         return head;
       }
      ListNode last=reverseList(head.next);
      head.next.next=head;
      head.next=null;
      return last;
    }
}
```

使用递归进行求解，首先考虑的是reverseList这个函数的作用，那就是进行反转，那么将reverseList(head.next)之后，链表情况

![image-20231102165719950](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102165719950.png)

![image-20231102165707289](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102165707289.png)

所以在这之后，只需要将head加入链表即可

```java
    head.next.next = head;
    head.next = null;
```

这个之后last的反转之后的根节点，返回last即可

###### [反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

思路：temp是一个完全空的链表，然后通过for循环，在left之前逐个插入，在left-right之间倒叙插入，然后再将right之后的直接插入

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode res=new ListNode(-1);
        ListNode temp=res;
        for(int i=1;i<left;i++){
            temp.next=head;
            temp=temp.next;
            head=head.next;
        }
        ListNode node2=temp;
        for(int i=left;i<=right;i++){
            ListNode node=head.next;
            head.next=temp.next;
            temp.next=head;
            head=node;
        }
        for(int i=left;i<=right;i++)
            temp=temp.next;
        temp.next=head;
        return res.next;
    }
}
```

###### [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode res=new ListNode(-1,head);
        ListNode temp=res;
        while(true){
            ListNode last=temp;
            for(int i=0;i<k;i++){
                last=last.next;
                if(last==null){
                    return res.next;
                }
            }
            ListNode cur=temp.next,node;
            for(int i=0;i<k-1;i++){
                node=cur.next;
                cur.next=node.next;
                node.next=temp.next;
                temp.next=node;
            }
            temp=cur;
        }
    }
}
```

之前反转链表的时候，因为是将一个链表插到另一个链表上，可以采用插的方式是

```java
            ListNode node=head.next;
            head.next=temp.next;
            temp.next=head;
            head=node;
```

这样不会产生循环，如果在同一条链表上进行反转插值，这样会产生循环，因为没有对head的前一个指针进行指向的更改，所以对于同一条链表的反转可以使用下面的方式进行插值

```java
                node=cur.next;
                cur.next=node.next;
                node.next=temp.next;
                temp.next=node;
```

##### 回文链表

###### [回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

回文链表是指正序和逆序遍历链表得到的序列完全相同。也就是说，如果一个链表从头到尾和从尾到头遍历的节点值都一样，那么这个链表就是回文链表。

解法1️⃣

使用栈的方式

```java
class Solution {
    public Boolean isPalindrome(ListNode head) {
        Stack<Integer>stack=new Stack<>();
        ListNode temp=head;
        while(temp!=null){
            stack.push(temp.val);
            temp=temp.next;
        }
        while(head!=null){
            if(head.val!=stack.pop()){
                return false;
            }
            head=head.next;
        }
        return true;
    }
};
```

解法2️⃣

使用双链表的方式

```java
    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            // 空链表或只有一个节点时为回文链表
            return true;
        }
        // 遍历链表并将节点值存储在列表中
        List<Integer> values = new ArrayList<>();
        ListNode current = head;
        while (current != null) {
            values.add(current.val);
            current = current.next;
        }
        // 使用双指针进行比较
        int left = 0;
        int right = values.size() - 1;
        while (left < right) {
            if (!values.get(left).equals(values.get(right))) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
```

### 数组

##### 双指针

###### [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

设置快慢指针，快慢指针从0出发，快指针一直走，当遇到快慢指针值不同时，就要进行更新，让慢指针前进一步，然后更新慢指针所在位置的值

前后指针

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0)
            return 0;
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[slow]!=nums[fast]){
                slow++;
                nums[slow]=nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
```

###### [移除元素](https://leetcode.cn/problems/remove-element/)

和上面的思路一样

前后指针

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums.length==0){
            return 0;
        }
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[fast]!=val){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

###### [移动零](https://leetcode.cn/problems/move-zeroes/)

和上面的一个思路，只不过要在最后进行补0

前后指针

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[fast]!=0){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        for(int i=slow;i<nums.length;i++)
            nums[i]=0;
        return;
    }
}
```

###### [删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

对于可以保存两个的这种情况，slow代表将要更新的位置，进行判断的是**slow-2和fast**

这个是先赋值，在slow++，是因为对于上一题来讲，两个指针都是从0开始的，所以slow代表只能是已经存在的位置，这个位置的点是这个值第一次出现，所以得slow先前进一格，再进行操作，对于这道题而言，因为是两个，所以从2开始出发的，这个时候slow代表的是重复值的下一个，这个时候就应该是赋新的值，再前进

前后指针

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0)
            return 0;
        int slow=2,fast=2;
        while (fast < nums.length) {
            if (nums[slow - 2] != nums[fast]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
}
```

###### [柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

使用单调栈的方式进行计算，往栈中加入的是序号，加入栈的规则是从数组中依次挑出数字，遇到当前值大于栈顶元素的，就加入，遇到当前值小于栈顶元素的，说明当前栈顶元素左右两边能计算的矩形的范围已经出来了，就把栈顶元素拿出来，计算面积

计算面积的步骤是拿出来的栈顶元素对应的高度为矩形高度，长度是**i-1-Stack.peek()**，Stack.peek()表示新的栈顶，这么计算的原因是防止这中间其实是有更高的被拿出去的，算长度的时候也要计算在内，这样的话就要在**最开始的时候加入-1进入栈**，因为考虑栈中正常的最后一个元素计算矩形面积的时候，如果不提前加入一个值，当pop出最后一个高度时，计算peek的时候，如果此时栈为空，就会报错，因此while的循环条件也必须是**Stack.size()>1**，因为后面那个判断条件，如果是不为0的话，heights[-1]也会报错，**右边需要多的一个值0**是用于最后把栈中所有元素都拿出来进行计算判断

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer>Stack=new Stack<>();
        int max=0;
        Stack.push(-1);
        for(int i=0;i<=heights.length;i++){
            int curHeight=i==heights.length?0:heights[i];
            while(Stack.size()>1&&curHeight<heights[Stack.peek()])            
            {
                int h=heights[Stack.pop()];
                int size=(i-1-Stack.peek())*h;
                max=Math.max(size,max);
            }
            Stack.push(i);
        }
        return max;
    }
}
```

###### [两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

解法1️⃣

这种解法有点像冒泡排序的方式

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int []res=new int[2];
        for(int i=0;i<numbers.length;i++){
            for(int j=i+1;j<numbers.length;j++){
                if(numbers[i]+numbers[j]==target){
                    res[0]=i+1;
                    res[1]=j+1;
                    return res;
                }
            }
        }
        return res;
    }
}
```

解法2️⃣

这种解法利用双指针，有点像二分查找的方式

左右指针

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int slow=0;int fast=numbers.length-1;
        int sum;
        while(slow!=fast){
            sum=numbers[slow]+numbers[fast];
            if(sum==target)
                return new int[]{slow+1,fast+1};
            else if(sum<target)
                slow++;
            else
                fast--;
        }
        return new int[]{-1,-1};
    }
}
```

###### [反转字符串](https://leetcode.cn/problems/reverse-string/)

左右指针

```java
class Solution {
    public void reverseString(char[] s) {
        if(s.length==0||s==null)
            return ;
        int slow=0;int fast=s.length-1;
        char temp;
        while(slow<fast){
            temp=s[fast];
            s[fast]=s[slow];
            s[slow]=temp;
            slow++;
            fast--;
        }
    }
}
```

###### [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

思路：使用for遍历的方式，for的每个i就是一个回文判断的出发点，从两边扩展看有没有，因为不知道该串是奇数还是偶数，所以就两个都进行查找，取最长长度

左右指针

```java
class Solution {
    public String longestPalindrome(String s) {
        String res="";
        for(int i=0;i<s.length();i++){
            String s1=judge(i,i,s);
            String s2=judge(i,i+1,s);
            res=res.length()>s1.length()?res:s1;
            res=res.length()>s2.length()?res:s2;
        }
        return res;
    }

    public String judge(int i,int j,String s){
        while(i>=0&&j<s.length()&&s.charAt(i)==s.charAt(j)){
            i--;
            j++;
        }
      	//取i+1是因为断开循环要么是越界，要么是不想等，所以当前的是不能要的
        return s.substring(i+1,j);
    }

}
```

##### 前缀

###### [ 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

可以使用双重for循环来做，不过时间复杂度高了，可以考虑利用前缀的思想，用相减的方式解决

![image-20231108153054765](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231108153054765.png)

```java
class NumMatrix {
    // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和
    private int[][] preSum;
    
    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // 构造前缀和矩阵
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 计算每个矩阵 [0, 0, i, j] 的元素和
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }
    
    // 计算子矩阵 [x1, y1, x2, y2] 的元素和
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // 目标矩阵之和由四个相邻矩阵运算获得
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
}

```

##### 差分数组

利用差分数组的思想进行解决

查分数组应用场景：多次对数组中的一部分进行增值减值的操作，这个时候就可以使用差分数组，一般就是题目给定nums[ n ]3的时候 

差分数组的原理：差分数组中每一个值代表了原数组中i-1和i之间的差值，所以当对数组中一部分进行值的修改时，使用差分数组，只需要对差分数组那个范围的两边进行修改就行了，因为中间都加，对于差分数组来说等于没加

差分数组的基本框架：首先创建一个全为0的差分数组，然后根据题目中给的值对差分数组对应节点进行赋值，注意题目一般从1开始，所以差分数组添加的时候记得减1，返回原数组也只需要查分数组从0开始一直累加即可

###### [航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int []num=new int[n];
        for(int []booking:bookings){
            num[booking[0]-1]+=booking[2];
            if(booking[1]<n){
                num[booking[1]]-=booking[2];
            }
        }
        for(int i=1;i<n;i++){
            num[i]+=num[i-1];
        }
        return num;
    }
}
```

###### [拼车](https://leetcode.cn/problems/car-pooling/)

主要是考虑在什么位置进行添加和删除值，如果是从0开始就直接i和j+1，如果是从1开始就是i-1和j，如果在范围点的不要就要减1

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int[] nums=new int[1001];
        for(int[]trip:trips){
            nums[trip[1]]+=trip[0];
            nums[trip[2]]-=trip[0];
        }
        for(int i=1;i<=1000;i++){
            nums[i]+=nums[i-1];
        }
        for(int i=0;i<=1000;i++){
            if(nums[i]>capacity)
                return false;
        }
        return true;


    }
}
```

##### 花式遍历数组

###### [反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

解法1️⃣

将字符串使用trim和split方法转化成只有非空字符串的数组，然后加入栈中，然后再从栈中提取出来进行拼接，然后返回

```java
class Solution {
    public String reverseWords(String s) {
        Stack<String>stack=new Stack<>();
        String []ss=s.trim().split(" +");
        for(String word:ss){
            stack.push(word);
        }
        String res="";
        while(!stack.isEmpty()){
            res=res.concat(" ").concat(stack.pop());
        }
        return res.substring(1);
    }
}
```

解法2️⃣

```java
class Solution {
    public String reverseWords(String s) {
        List<String>wordlist=Arrays.asList(s.trim().split(" +"));
        Collections.reverse(wordlist);
        return String.join(" ",wordlist);
    }
}
```

###### [旋转图像](https://leetcode.cn/problems/rotate-image/)

顺时针九十度反转数组，可以想到先将矩阵按照对角线进行对称，再将每一行进行反转

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
      	//按照对角线进行对称
        for(int i=0;i<n;i++)
            for(int j=i;j<n;j++){
                int temp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=temp;
            }
      	//每一行进行反转
        for(int i=0;i<n;i++){
            reverse(matrix[i]);
        }
    }
    public void reverse(int []nums){
        int i=0;int j=nums.length-1;
      	//用while循环对一维数组进行反转
        while(i<j){
            int temp=nums[j];
            nums[j]=nums[i];
            nums[i]=temp;
            i++;j--;
        }
    }
}
```

同理也可以写逆时针反转矩阵

```java
// 将二维矩阵原地逆时针旋转 90 度
void rotate2(int[][] matrix) {
    int n = matrix.length;
    // 沿左下到右上的对角线镜像对称二维矩阵
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i; j++) {
            // swap(matrix[i][j], matrix[n-j-1][n-i-1])
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][n - i - 1];
            matrix[n - j - 1][n - i - 1] = temp;
        }
    }
    // 然后反转二维矩阵的每一行
    for (int[] row : matrix) {
        reverse(row);
    }
}

void reverse(int[] arr) { /* 见上文 */}

```

###### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

螺旋遍历矩阵，可以想象为上右下左遍历矩阵，使用一个大的while循环，当list满就退出循环，在while循环里用4个if来进行遍历，就根据边界来进行判断，然后用for循环挨个把每个值加入list中

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m=matrix.length;int n=matrix[0].length;
        int upperbound=0;int buttonbound=m-1;
        int leftbound=0;int rightbound=n-1;
        ArrayList<Integer>list=new ArrayList<>();
        while(list.size()<m*n){
            if(upperbound<=buttonbound){
                for(int i=leftbound;i<=rightbound;i++){
                    list.add(matrix[upperbound][i]);
                }
                upperbound++;
            }
            if(leftbound<=rightbound){
                for(int i=upperbound;i<=buttonbound;i++){
                    list.add(matrix[i][rightbound]);
                }
                rightbound--;
            }
            if(upperbound<=buttonbound){
                for(int i=rightbound;i>=leftbound;i--){
                    list.add(matrix[buttonbound][i]);
                }
                buttonbound--;
            }
            if(leftbound<=rightbound){
                for(int i=buttonbound;i>=upperbound;i--){
                    list.add(matrix[i][leftbound]);
                }
                leftbound++;
            }
    }
    return list;
}}
```

###### [螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

和上题类似，只要按照螺旋的轨迹走一遍就行了

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int upper=0;int button=n-1;
        int left=0;int right=n-1;
        int count=1;
        int [][]res=new int[n][n];
        while(count<n*n+1){
            if(upper<=button){
                for(int i=left;i<=right;i++){
                    res[upper][i]=count++;                
                }
                upper++;
            }
            if(left<=right){
                for(int i=upper;i<=button;i++){
                    res[i][right]=count++;                
                }
                right--;
            }
            if(upper<=button){
                for(int i=right;i>=left;i--){
                    res[button][i]=count++;                
                }
                button--;
            }
            if(left<=right){
                for(int i=button;i>=upper;i--){
                    res[i][left]=count++;                
                }
                left++;
            }
        }
        return res;
    }
}
```

##### 滑动窗口

###### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

思路：

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头

**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

具体实施：

- 使用HashMap来存储每个字符出现的次数，need表示需要哪些字符，每个字符出现了多少次，window表示目前字符串中有哪些字符了，出现了多少次，两者的字符出现数量相等，就表示某字符匹配成功了，num++，当num的数量和need的大小相等时，说明匹配成功
- 使用getOrDefault(tt,0)+1方法对hashmap某一字符出现的次数进行更新
- 当匹配成功后就要进行优化，left进行++，这个时候每次也要进行判断left所在位置的那个字符是否存在与need中，如果存在就要对window中字符的数量进行修改，因为不要它了，并且在此之前还要判断window和need该字符的数量是否相等，如果相等说明去掉该字符之后，就不能匹配成功了，就需要num--

```java
class Solution {
    public String minWindow(String s, String t) {
        Map<Character,Integer>window=new HashMap<>();
        Map<Character,Integer>need=new HashMap<>();
        for(char tt:t.toCharArray()){
            need.put(tt,need.getOrDefault(tt,0)+1);
        }
        int start=0;int len=Integer.MAX_VALUE;
        int left=0;int right=0;
        int num=0;
        while(right<s.length()){
            char c=s.charAt(right);
            right++;
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c))){
                    num++;
                }
            }
            while(num==need.size()){
                if(right-left<len){
                    start=left;
                    len=right-left;
                }
                char d=s.charAt(left);
                left++;
                if(need.containsKey(d)){
                    if(need.get(d).equals(window.get(d))){
                        num--;
                    }
                    window.put(d,window.getOrDefault(d,0)-1);
                }
            }
        }
        return len==Integer.MAX_VALUE?"":s.substring(start,start+len);
    }
}
```

###### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

一样的使用滑动窗口，只不过这个计算长度的时候，在循环之后计算长度

```java
class Solution {
        public static int lengthOfLongestSubstring(String s) {
        Map<Character,Integer> window=new HashMap<>();
        int left=0;int right=0;
        int len=Integer.MIN_VALUE;
        while(right<s.length()){
            char c=s.charAt(right);
            right++;
            while(window.containsKey(c)){
                char d=s.charAt(left);
                left++;
                window.remove(d);
            }
            if(right-left>len){
                len=right-left;
            }
            window.put(c,1);
        }
        return len==Integer.MIN_VALUE?s.length():len;
    }
}
```

###### [字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        Map<Character,Integer>need=new HashMap<Character,Integer>();
        Map<Character,Integer>window=new HashMap<>();
        for(char c:s1.toCharArray()){
            need.put(c,need.getOrDefault(c,0)+1);
        }
        int left=0;int right=0;
        int num=0;
        while(right<s2.length()){
            char c=s2.charAt(right);
            right++;
            if(need.containsKey(c)){
                while(need.get(c).equals(window.get(c))){
                    char d=s2.charAt(left);
                    left++;
                    if(need.containsKey(d)){
                        if(need.get(d).equals(window.get(d)))
                            num--;
                        window.put(d,window.getOrDefault(d,0)-1);
                    }
                }
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c)))
                            num++;

            }else{
                window.clear();
                num=0;
                left=right;
            }
            if(num==need.size())
                return true;
        }
        return false;

    }
}
```

###### [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        Map<Character,Integer>need=new HashMap<>();
        Map<Character,Integer>window=new HashMap<>();
        for(char c:p.toCharArray()){
            need.put(c,need.getOrDefault(c,0)+1);
        }
        int left=0;int right=0;
        int num=0;
        List <Integer>res=new ArrayList<>();
        while(right<s.length()){
            char c=s.charAt(right);
            right++;
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c))){
                    num++;
                }
            }
            while(right-left>=p.length()){
                if(num==need.size()){
                    res.add(left);
                }
                char ss=s.charAt(left);
                left++;
                if(need.containsKey(ss)){
                    if(need.get(ss).equals(window.get(ss)))
                        num--;
                    window.put(ss,window.getOrDefault(ss,0)-1);
                }
            }
        }
        return res;
    }
}
```

##### 二分查找

###### [二分查找](https://leetcode.cn/problems/binary-search/)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(target==nums[mid])
                return mid;
            else if(target>nums[mid])
                left=mid+1;
            else
                right=mid-1;
        }
        return -1;
    }
}
```

###### [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

用二分查找的通用框架，使用两次，找到左边界和右边界

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        return new int[]{first(nums,target),last(nums,target)};
    }

    public int first(int []nums,int target){
        int left=0;int right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target)
                left=mid+1;
            else if(nums[mid]>target)
                right=mid-1;
            else
                right=mid-1;
        }
        if(left>=nums.length)
            return -1;
        return nums[left]==target?left:-1;
    }
    public int last(int []nums,int target){
        int left=0;int right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target)
                left=mid+1;
            else if(nums[mid]>target)
                right=mid-1;
            else
                left=mid+1;
        }
        if(right<0)
            return -1;
        return nums[right]==target?right:-1;
    }
}
```

##### 田忌赛马

###### [优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)

类似于田忌赛马，思路是首先对两个数组进行排序，不过对于num2来说，不能改变序列位置，不然就没有意义了，所以定义了一个对象，把他每个值进行排序，但又记录了每个值在原数组的位置，然后直接对num1数组进行排序，比较的时候，挨个取出队列中的值，因为是从大到小进行排序，也从大拿出num1的数组进行判断，如果num1的大，说明可以赢就直接讲num1该位置的值存储在新数组中num2的值对应的位置，如果更小，那就从num2中提取当前最小值进行添加，知道num1的值全部匹配完

```java
class Solution {
    int[] advantageCount(int[] nums1, int[] nums2) {
        PriorityQueue<int []>queue=new PriorityQueue<>(
            (int []p1,int []p2)->{
                return p2[1]-p1[1];
            }
        );
        for(int i=0;i<nums2.length;i++){
            queue.offer(new int[]{i,nums2[i]});
        }
        Arrays.sort(nums1);
        int []res=new int[nums1.length];
        int left=0;int right=nums1.length-1;
        while(!queue.isEmpty()){
            int []p=queue.poll();
            int i=p[0];int num=p[1];
            if(num<nums1[right]){
                res[i]=nums1[right];
                right--;
            }else{
                res[i]=nums1[left];
                left++;
            }
        }
        return res;
    }

}
```

### 二叉树

###### [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        int left=maxDepth(root.left);
        int right=maxDepth(root.right);
        int res=Math.max(left,right)+1;
        return res;
    }
}
```

###### [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

方法1️⃣：用dfs，遍历每个叶子结点找最短路径

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int min_value=Integer.MAX_VALUE;
    public int minDepth(TreeNode root) {
        if(root==null)
            return 0;
        min(root,1);
        return min_value;
    }
    public void min(TreeNode root,int count){
        if(root.left==null&&root.right==null){
            if(min_value>count){
                min_value=count;
            }
        }
        if(root.left!=null)
            min(root.left,count+1);
        if(root.right!=null)
            min(root.right,count+1);
    }
}
```



###### [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

思路：直径的长度其实是等于一个节点的左右子树深度之和，所以利用在求每个节点的最大深度时，进行不断的判断，就能找到最长直径了

```java
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans=0;
        depth(root);
        return ans;
    }
    public int depth(TreeNode node){
        if(node==null)
            return 0;
        int left=depth(node.left);
        int right=depth(node.right);
        ans=Math.max(ans,left+right);
        return Math.max(left,right)+1;
    }
}
```

###### [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

```java
class Solution {
    List <TreeNode>list=new ArrayList<TreeNode>();
    public void flatten(TreeNode root) {
        pre(root);
        TreeNode temp=root;
        for(int i=1;i<list.size();i++){
            temp.right=list.get(i);
            temp.left=null;
            temp=temp.right;
        }
    }
    public void pre(TreeNode node){
        if(node==null)
            return;
        list.add(node);
        pre(node.left);
        pre(node.right);
    }
}
```

###### [填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

使用bfs

```java
class Solution {
    public Node connect(Node root) {
        if(root==null){
            return null;
        }
        Queue<Node>queue=new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            int size=queue.size();
            for(int i=0;i<size;i++){
                Node node=queue.poll();
                if(i<size-1){
                    node.next=queue.peek();
                }
                if(node.left!=null)
                    queue.add(node.left);
                if(node.right!=null)
                    queue.add(node.right);
            }
            
        }
        return root;
    }
}
```

dfs

```java
class Solution {
    public Node connect(Node root) {
        if(root==null){
            return null;
        }
        add(root.left,root.right);
        return root;
    }
    public void add(Node node,Node node2){
        if(node==null)
            return;
        node.next=node2;
        add(node.left,node.right);
        add(node2.left,node2.right);
        add(node.right,node2.left);
    }
}
```

###### [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        TreeNode root=build(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
        return root;
    }
    public TreeNode build(int []preorder,int pl,int pr,int []inorder,int il,int ir){
        if(pl>pr)
            return null;
        int tar=preorder[pl];
        int index=0;
        for(int i=il;i<=ir;i++){
            if(inorder[i]==tar){
                index=i;
                break;
            }
        }
        int size=index-il;
        TreeNode node=new TreeNode(tar);
        node.left=build(preorder,pl+1,pl+size,inorder,il,index-1);
        node.right=build(preorder,pl+size+1,pr,inorder,index+1,ir);
        return node;
    }
}
```

###### [最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if(nums.length==0)
            return null;
        TreeNode node=build(nums,0,nums.length-1);
        return node;
    }
    public TreeNode build(int []nums,int left,int right){
        if(left>right)
            return null;
        int max=-1;
        int index=0;
        for(int i=left;i<=right;i++){
            if(nums[i]>max){
                max=nums[i];
                index=i;
            }
        }
        TreeNode root=new TreeNode(max);
        root.left=build(nums,left,index-1);
        root.right=build(nums,index+1,right);
        return root;
    }
}
```

###### [从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)

二叉搜索树用的中序遍历

```java
class Solution {
    public TreeNode bstToGst(TreeNode root) {
        add(root);
        return root;
    }
    int res=0;
    public void add(TreeNode node){
        if(node==null)
            return;
        add(node.right);
        res+=node.val;
        node.val=res;
        add(node.left);
    }
}
```

###### [二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

和上一题一样的思路，只不过是正向的

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        search(root,k);
        return res;
    }
    int res;
    int rank=0;
    public void search(TreeNode node,int k){
        if(node==null)
            return;
        search(node.left,k);
        rank++;
        if(k==rank){
            res=node.val;
            return;
        }
        search(node.right,k);

    }
}
```

###### [把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        sum(root);
        return root;
    }
    int res;
    public void sum(TreeNode node){
        if(node ==null)
            return;
        sum(node.right);
        res+=node.val;
        node.val=res;
        sum(node.left);
    }
}
```

###### [完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null)
            return 0;
        return 1+countNodes(root.left)+countNodes(root.right);
    }
}
```

### 图

##### dfs

###### [所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

使用dfs的方式进行遍历图，因为不会成环所以不需要visit数组，因为要所有路径，所以在外面定义一个二维数组，当条件匹配的时候就把一维数组加入二维数组，并且去掉一维数组的最后一个元素，继续进行其他的dfs遍历，并且由于传递的是数组，是引用变量，所以每次加入res数组的时候要创建一个新的数组加进去，不然加到res里的path数组的值也会一直变化，最后都会为0

```java
class Solution {
    LinkedList<List<Integer>>res=new LinkedList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        LinkedList<Integer>path=new LinkedList<>();
        dfs(graph,path,0);
        return res;
    }
    public void dfs(int [][]graph,LinkedList<Integer>path,int k){
        path.add(k);
        if(k==graph.length-1){
            res.add(new LinkedList<>(path));
            path.removeLast();
            return;
        }
        for(Integer n:graph[k]){
            dfs(graph,path,n);
        }
        path.removeLast();
    }
}
```

##### 拓扑排序

###### [课程表](https://leetcode.cn/problems/course-schedule/)

采用dfs的方式进行求解，首先是初始化各个数组list，然后进行建图，然后以每个节点作为根节点进行遍历

对于无向的图的话，找是否有循环，首先想到的是union+parent，对于有向的图的话，可以直接用dfs+onpath进行判断，onpath是一个数组，代表了当前的遍历路径上还在路径上的节点，因为每遍历完一个节点，要返回的时候，就会把它的onpath[x]设置为0，代表了已经剔除路径，这样的话每次进行一个新的dfs的时候只需要判断onpath，如果为1，那说明当前路径上有该节点，那说明成环了。

所以判断是否有环就可以用这种方式，遍历该点之前设置为true，遍历之后设置为false

```java
class Solution {
    int []visited;
    int []onpath;
  	//定义一个成员变量，如果circle变为true，那说明有环，最后也是返回！circle
    boolean circle=false;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        LinkedList<Integer>[]graph=new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        visited=new int[numCourses];
      	//建图
        for(int i=0;i<prerequisites.length;i++){
            graph[prerequisites[i][1]].add(prerequisites[i][0]);
        }
        onpath=new int[numCourses];
      	//对每个节点作为根节点进行遍历
        for(int i=0;i<numCourses;i++){
            dfs(graph,i);
        }
        return !circle;

    }
    public void dfs(LinkedList<Integer>[]graph,int s){
      	//在路径上，说明有环
        if(onpath[s]==1){
            circle=true;
        }
      	//visited表示可能之前其他节点作为根节点的时候，已经遍历过该点了 那么就不需要再遍历了
      	//circle如果有循环了也不需要遍历了
        if(visited[s]==1||circle){
            return;
        }
        onpath[s]=1;
        visited[s]=1;
        for(int t:graph[s]){
            dfs(graph,t);
        }
        onpath[s]=0;
    }
}
```

###### [课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

和上一题的区别是要给一个顺序，这个顺序是在进行dfs遍历的时候的后序提取然后再反转即可，使用先序是不行的，先序根据顺序有可能会让子节点跑到前面去。

```java
class Solution {
    int []visited;
    int []onpath;
    boolean circle=false;
    LinkedList<Integer>list=new LinkedList<>();
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        LinkedList<Integer>[]graph=new LinkedList[numCourses];
        for(int i=0;i<numCourses;i++){
            graph[i]=new LinkedList<>();
        }
        for(int i=0;i<prerequisites.length;i++){
            graph[prerequisites[i][1]].add(prerequisites[i][0]);
        }
        visited=new int[numCourses];
        onpath=new int[numCourses];
        for(int i=0;i<numCourses;i++){
            dfs(graph,i);
        }
        if(circle==true)
            return new int[]{};
        Collections.reverse(list);
        int[] res = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            res[i] = list.get(i);
        }
        return res;

    }
    public void dfs(LinkedList<Integer>[]graph,int s){
        if(onpath[s]==1){
            circle=true;
        }
        if(visited[s]==1||circle){
            return;
        }
        visited[s]=1;
        onpath[s]=1;
        for(int t:graph[s]){
            dfs(graph,t);
        }
        list.add(s);
        onpath[s]=0;
    }
}
```

方法2️⃣：

使用bfs的方式，即考虑出度入度的关系，把这个想成一个图，从入度为0的点开始去除，去除之后他的子节点的入度就会减1，如果不存在循环，那么所有的点都能消掉，一个会遍历numCourses次，如果存在循环，那么在收集入度为0的点时，循环内的点都不满足条件，那么就不会加入队列，就会少遍历几次，所以最后只需要判断遍历的次数是否和numCourses相等就可以找到是否有环。对于顺序，遍历的顺序就是拓扑排序的顺序。

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Queue<Integer>queue=new LinkedList<>();
        LinkedList<Integer>graph[]=new LinkedList[numCourses];
        int []in=new int[numCourses];
        for(int i=0;i<numCourses;i++){
            graph[i]=new LinkedList<>();
        }
        for(int []num:prerequisites){
            graph[num[1]].add(num[0]);
            in[num[0]]++;
        }
        for(int i=0;i<numCourses;i++){
            if(in[i]==0)
                queue.add(i);
        }
        int count=0;
        int []res=new int[numCourses]; 
        while(!queue.isEmpty()){
            int point=queue.poll();
            res[count]=point;
            count++;
            for(int x:graph[point]){
                in[x]--;
                if(in[x]==0)
                    queue.add(x);
            }
        }
        if(count==numCourses)
            return res;
        return new int[]{};
    }
}
```

##### 二分图

###### [ 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

判断是否是二分图，用dfs来进行判断，首先创建两个数组，一个visited，一个color数组，因为不一定所有节点都连接，所以要用for循环把所有点都dfs一遍，对于dfs里面，首先进行判断是否已经不是二分图了，如果已经不是了就直接返回了，否则遍历v点的所有连接点，首先判断这个点是否是访问过的，如果访问过的就判断这两个点颜色是否相同，如果没有访问过就将这个点设置为已访问，并且颜色设置为相反颜色，然后dfs该点。

```java
class Solution {
    boolean []visited;
    boolean []color;
    boolean res=true;
    public boolean isBipartite(int[][] graph) {
        int n=graph.length;
        visited=new boolean[n];
        color=new boolean[n];
        for(int i=0;i<n;i++){
            dfs(graph,i);
        }
        return res;

    }
    public void dfs(int [][]graph,int v){
        if(!res)
            return;
        for(int u:graph[v]){
            if(visited[u]){
                if(color[u]==color[v]){
                    res=false;
                    return;
                }
            }else{
                visited[u]=true;
                color[u]=!color[v];
                dfs(graph,u);
            }
        }
    }
}
```

###### [可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

和上题一样的思路，区别在于输入数组不同，这个需要自己建邻序表

```java
class Solution {
    boolean []visited;
    boolean []color;
    boolean res=true;
    public boolean possibleBipartition(int n, int[][] dislikes) {
        LinkedList<Integer>[]graph=new LinkedList[n+1];
        visited=new boolean[n+1];
        color=new boolean[n+1];
        for(int i=0;i<=n;i++){
            graph[i]=new LinkedList<>();
        }
        for(int []num:dislikes){
            graph[num[0]].add(num[1]);
            graph[num[1]].add(num[0]);
        }
        for(int i=1;i<=n;i++){
            dfs(graph,i);
        }
        return res;
    }
    public void dfs(LinkedList<Integer>[]graph,int v){
        if(!res)
            return;
        for(int u:graph[v]){
            if(visited[u]){
                if(color[u]==color[v]){
                    res=false;
                    return;
                }
            }else{
                visited[u]=true;
                color[u]=!color[v];
                dfs(graph,u);
            }
        }
    }
}
```

##### 岛屿问题

###### [被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

这题属于岛屿问题，思路是先用 for 循环遍历棋盘的**四边**，用 DFS 算法把那些与边界相连的 `O` 换成一个特殊字符，比如 `#`；然后再遍历整个棋盘，把剩下的 `O` 换成 `X`，把 `#` 恢复成 `O`。这样就能完成题目的要求，时间复杂度 O(MN)。

这道题有个点在于dfs的判断条件中不能用board[ x ] [ y ]=='X'来进行判断，因为考虑到一种情况，当前面进行遍历的时候，把周围的O变成了A，如果用这个判断条件的话就会对变成A的点继续遍历，这样的话就是遍历就不会结束，会一直遍历下去，所以要用board[ x ] [ y ]!='O'，或者加个visited数组

```java
class Solution {
    public void solve(char[][] board) {
        int m=board.length;
        int n=board[0].length;
        for(int i=0;i<m;i++){
            dfs(board,i,0);
            dfs(board,i,n-1);
        }
        for(int i=0;i<n;i++){
            dfs(board,0,i);
            dfs(board,m-1,i);
        }
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]=='O'){
                    board[i][j]='X';
                }else if(board[i][j]=='A')
                    board[i][j]='O';
            }
        }
    }
    public void dfs(char [][]board,int x,int y){
        if(x<0||x>=board.length||y<0||y>=board[0].length||board[x][y]!='O')
            return;
        board[x][y]='A';
        dfs(board,x+1,y);
        dfs(board,x-1,y);
        dfs(board,x,y+1);
        dfs(board,x,y-1);
    }

}
```

##### 并查集

###### [等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

这里的find使用的是递归的方式进行，这样的好处是能够把这个树的高度变为1，提高查询效率，这道题因为不知道字母的数量，所以parent数组直接是设置的26，不需要传递类型为char类型，只需要在传递之间减一个‘a’即可

```java
class Solution {
    int []parent=new int[26] ;
    public int find(int x){
        if(parent[x]!=x)
            parent[x]=find(parent[x]);
        return parent[x];
    }
    public void union(int x,int y){
        int xp=find(x);
        int yp=find(y);
        if(xp==yp)
            return;
        parent[xp]=yp;
    }
    public boolean equationsPossible(String[] equations) {
        for(int i=0;i<26;i++)
            parent[i]=i;
        for(String s:equations){
            if(s.charAt(1)=='='){
                int x=s.charAt(0)-'a';
                int y=s.charAt(3)-'a';
                union(x,y);
            }
        }
        boolean flag=true;
        for(String s:equations){
            if(s.charAt(1)=='!'){
                int x=find(s.charAt(0)-'a');
                int y=find(s.charAt(3)-'a');
                if(x==y){
                    flag=false;
                    break;
                }
            }
        }
        return flag;
    }
}
```

##### 最小生成树

###### [连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

使用克鲁斯卡尔法求最小生成树

```java
class Solution {
    int []parent;
    public void union(int x,int y){
        int xp=find(x);
        int yp=find(y);
        if(xp==yp)
            return;
        parent[xp]=yp;
    }

    public int find(int x){
        if(parent[x]!=x)
            parent[x]=find(parent[x]);
        return parent[x];
    }
    
    public int dist(int []x,int []y){
        return Math.abs(x[0]-y[0])+Math.abs(x[1]-y[1]);
    }

    public int minCostConnectPoints(int[][] points) {
        int v=points.length;
        parent=new int[v];
        for(int i=0;i<v;i++)
            parent[i]=i;
        int res=0;
        int count=0;
        while(count<v-1){
            int min=Integer.MAX_VALUE;
            int from=-1;int to=-1;
            for(int i=0;i<v;i++)
                for(int j=0;j<v;j++){
                    if(dist(points[i],points[j])<min&&find(i)!=find(j)){
                        from=i;
                        to=j;
                        min=dist(points[i],points[j]);
                    }
                }
            if(from!=-1&&to!=-1){
                count++;
                res+=min;
                union(from,to);
            }
        }
        return res;
    }
}
```

##### Dijkstra

###### [概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/)

方法1️⃣：使用bfs的思路，逐渐更新起始点的邻接点，使用邻接列表➕队列的方式，由于不像之前的树权重都是1，不需要管权重，这个是有权重的，所以要单独定义一个类，来记录权重

其中由于是到某个点的最小距离，也可以用if进行判断，到了那个点就可以返回，不过考虑写一个模版，所以没有加

```java
import java.util.*;

class Edge {
    int to;
    double dist;
    Edge(int to,double dist){
        this.to=to;
        this.dist=dist;
    }
}

class Solution {
    LinkedList<Edge>[]graph;
    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {
        graph=new LinkedList[n];
        for(int i=0;i<n;i++)
            graph[i]=new LinkedList<>();
        build(edges,succProb);
        double []dist=dijsktra(n,start_node);
        if(dist[end_node]!=-1)
            return dist[end_node];
        return 0;

    }
    public double[]dijsktra(int n,int start_node){
        double[]dist=new double[n];
        Arrays.fill(dist,-1);
        dist[start_node]=1;
        Queue<Edge>queue=new LinkedList<>();
        queue.add(new Edge(start_node,1));
        while(!queue.isEmpty()){
            Edge edge=queue.poll();
            int to=edge.to;
            for(Edge edge1:graph[to]){
                int edge_to=edge1.to;
                double edge_dist=dist[to]*edge1.dist;
                if(edge_dist>dist[edge_to]){
                    dist[edge_to]=edge_dist;
                    queue.add(new Edge(edge_to,dist[edge_to]));
                }
            }
        }
        return dist;
    }
    public void build(int [][]edges,double[]succProb){
        int count=0;
        for(int []edge:edges){
            graph[edge[0]].add(new Edge(edge[1],succProb[count]));
            graph[edge[1]].add(new Edge(edge[0],succProb[count]));
            count++;
        }
    }
}
```

方法2️⃣：使用邻接矩阵的方式来存储，好处是就不需要单独定义一个类来存储权重，坏处是这样的话需要定义一个很大的邻接矩阵，会造成空间上的浪费，在leetcode上会超出内存限制

```java
class Solution {
    double [][]graph;
    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {
        graph=new double[n][n];
        build(edges,succProb);
        double []dist=dijsk(n,start_node);
        if(dist[end_node]!=Integer.MIN_VALUE){
            return dist[end_node];
        }
        return 0;
    }
    public double[] dijsk(int n,int start_node){
        double dist[]=new double[n];
        boolean []visited=new boolean[n];
        Arrays.fill(dist,Integer.MIN_VALUE);
        dist[start_node]=1;
        for(int i=0;i<n-1;i++){
            int index=findMax(dist,visited);
            if(index==-1)
                break;
            visited[index]=true;
            for(int j=0;j<n;j++){
                if(graph[index][j]!=0&&dist[index]>0&&!visited[j]&&dist[index]*graph[index][j]>dist[j]){
                    dist[j]=dist[index]*graph[index][j];
                }
            }
        }
        return dist;
    }

    public int findMax(double []dist,boolean []visited){
        double max=Integer.MIN_VALUE;
        int index=0;
        for(int i=0;i<dist.length;i++){
            if(!visited[i]&&dist[i]>max){
                index=i;
                max=dist[i];
            }
        }
        return index;
    }
    public void build(int [][]edges,double[]succProb){
        int count=0;
        for(int []edge:edges){
            graph[edge[0]][edge[1]]=succProb[count];
            graph[edge[1]][edge[0]]=succProb[count];
            count++;
        }
    }
}
```

###### [最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)

需要用有序队列

```java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

class location{
    int x;
    int y;
    int dist;
    location(int x,int y,int dist){
        this.x=x;
        this.y=y;
        this.dist=dist;
    }
}

class Solution {
    static int [][]position={
      {0,1},
      {0,-1},
      {1,0},
      {-1,0}
    };
    static int [][]res;

    public static int minimumEffortPath(int[][] heights) {
        int res=dijsktra(heights);
        return res;
    }

    public static int dijsktra(int [][]heights){
        int m=heights.length;
        int n=heights[0].length;
        PriorityQueue<location> queue=new PriorityQueue<>((a,b)->{
            return a.dist-b.dist;
        });
        res= new int[m][n];
        for (int[] row : res) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        res[0][0]=0;
        queue.add(new location(0,0,0));
        while(!queue.isEmpty()){
            location l=queue.poll();
            int lx=l.x;
            int ly=l.y;
            int d=l.dist;
            if(lx==m-1&&ly==n-1){
                break;
            }
            for(int i=0;i<4;i++){
                if((lx+position[i][0])>=0&&(lx+position[i][0])<m&&(ly+position[i][1])>=0&&(ly+position[i][1])<n){
                    int x=Math.max(Math.abs(heights[lx+position[i][0]][ly+position[i][1]]-heights[lx][ly]),res[lx][ly]);
                    if(x<res[lx+position[i][0]][ly+position[i][1]]){
                        res[lx+position[i][0]][ly+position[i][1]]=x;
                        queue.add(new location(lx+position[i][0],ly+position[i][1],res[lx+position[i][0]][ly+position[i][1]]));
                    }
                }
            }
        }
        return res[m-1][n-1];
    }
}
```

###### [ 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

用一样的思路

```java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.PriorityQueue;

class Edge{
    int to;
    int dist;
    Edge(int to,int dist){
        this.to=to;
        this.dist=dist;
    }
}

class Solution {

    LinkedList<Edge>[]graph;
    public int networkDelayTime(int[][] times, int n, int k) {
        graph=new LinkedList[n+1];
        for(int i=0;i<=n;i++)
            graph[i]=new LinkedList<>();
        build(times);
        int []res=dijkstra(k,n);
        int max=0;
        for(int i=1;i<res.length;i++){
            if(max<res[i])
                max=res[i];
            if(res[i]==Integer.MAX_VALUE)
                return -1;
        }
        return max;
    }

    public int[] dijkstra(int k,int n){
        int []res=new int[n+1];
        Arrays.fill(res,Integer.MAX_VALUE);
        res[k]=0;
        PriorityQueue<Edge> queue=new PriorityQueue<>((a, b)->{
            return a.dist-b.dist;
        });
        queue.add(new Edge(k,0));
        while(!queue.isEmpty()){
            Edge edge=queue.poll();
            int curto=edge.to;
            int curdist=edge.dist;
            if(curdist<res[curto])
                continue;
            for(Edge edge1:graph[curto]){
                int next_to=edge1.to;
                int next_dist=edge1.dist;
                if(next_dist+res[curto]<res[next_to]){
                    res[next_to]=next_dist+res[curto];
                    queue.add(new Edge(next_to,res[next_to]));
                }
            }
        }
        return res;
    }

    public void build(int [][]times){
        for(int []time:times){
            int from=time[0];
            int to=time[1];
            int dist=time[2];
            graph[from].add(new Edge(to,dist));
        }
    }
}
```

###### [ K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)

这道题特殊点在于要考虑两个地方，一个是最短距离，一个是边的数量不能超过k+1

```java
class Solution {
    class State {
        int id;
        int costFromSrc;
        int nodeNumFromSrc;
        State(int id, int costFromSrc, int nodeNumFromSrc) {
            this.id = id;
            this.costFromSrc = costFromSrc;
            this.nodeNumFromSrc = nodeNumFromSrc;
        }
    }
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        List<int[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : flights) {
            int from = edge[0];
            int to = edge[1];
            int price = edge[2];
            graph[from].add(new int[]{to, price});
        }
        K++;
        return dijkstra(graph, src, K, dst);
    }
    int dijkstra(List<int[]>[] graph, int src, int k, int dst) {
        int[] distTo = new int[graph.length];
        int[] nodeNumTo = new int[graph.length];
        Arrays.fill(distTo, Integer.MAX_VALUE);
        Arrays.fill(nodeNumTo, Integer.MAX_VALUE);
        distTo[src] = 0;
        nodeNumTo[src] = 0;
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return a.costFromSrc - b.costFromSrc;
        });
        pq.offer(new State(src, 0, 0));
        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            int costFromSrc = curState.costFromSrc;
            int curNodeNumFromSrc = curState.nodeNumFromSrc;
            
            if (curNodeID == dst) {
                return costFromSrc;
            }
          	//表示当前中转站的点肯定是不行了 看看队列中的其他节点能不能通过
            if (curNodeNumFromSrc == k) {
                continue;
            }
            for (int[] neighbor : graph[curNodeID]) {
                int nextNodeID = neighbor[0];
                int costToNextNode = costFromSrc + neighbor[1];
                int nextNodeNumFromSrc = curNodeNumFromSrc + 1;
                if (distTo[nextNodeID] > costToNextNode) {
                    distTo[nextNodeID] = costToNextNode;
                    nodeNumTo[nextNodeID] = nextNodeNumFromSrc;
                }
                if (costToNextNode > distTo[nextNodeID]
                    && nextNodeNumFromSrc > nodeNumTo[nextNodeID]) {
                    continue;
                }
                pq.offer(new State(nextNodeID, costToNextNode, nextNodeNumFromSrc));
            }
        }
        return -1;
    }

}
```

### 动态规划

重叠子问题、最优子结构、状态转移方程就是动态规划三要素

**要符合「最优子结构」，子问题间必须互相独立**。

###### [ 零钱兑换](https://leetcode.cn/problems/coin-change/)

自底向上的消除，设置max是amount + 1，而不是MAX_VALUE是因为怕dp[i - coins[j]] + 1越界

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int max=amount+1;
        int []dp=new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for(int i=1;i<=amount;i++){
            for(int coin:coins){
                if(i<coin)
                    continue;
                dp[i]=Math.min(dp[i],dp[i-coin]+1);
            }
        }
        return dp[amount]==amount+1?-1:dp[amount];
    }
}
```

##### 最长递增子序列

###### [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

这道题思路比较简单，状态方程就是找到当前节点之前所有比他小的节点，比较这些点的长度。dp[i]=Math.max(dp[i],dp[j]+1)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        int []dp=new int[n];
        Arrays.fill(dp,1);
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
        }
        int max=Integer.MIN_VALUE;
        for(int res:dp)
            if(max<res)
                max=res;
        return max;
    }
}
```

###### [俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

思路是：首先对信封的宽度进行升序排序，如果宽度相同的信封就使用降序排序，这样只需要对信封的高度进行最长递增子序列的动态规划即可

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        int n=envelopes.length;
        Arrays.sort(envelopes, new Comparator<int[]>() 
        {
            public int compare(int[] a, int[] b) {
                return a[0] == b[0] ? 
                    b[1] - a[1] : a[0] - b[0];
            }
        });
        int []heights=new int[n];
        for(int i=0;i<n;i++){
            heights[i]=envelopes[i][1];
        }
        return dp_array(heights);

    }

    public int dp_array(int[]heights){
        int n=heights.length;
        int []dp=new int[n];
        Arrays.fill(dp,1);
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                if(heights[j]<heights[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
        }
        int max=-1;
        for(int i=0;i<n;i++){
            if(max<dp[i])
                max=dp[i];
        }
        return max;
    }
}
```

###### [下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)

类似于背包问题，dp数组中后面的值由上一行的三个dp值的最小值和该值的和，注意判断越界

```java
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int n=matrix.length;
        int [][]dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[0][i]=matrix[0][i];
        for(int i=1;i<n;i++){
            for(int j=0;j<n;j++){
                int l_value=j==0?Integer.MAX_VALUE:dp[i-1][j-1];
                int m_value=dp[i-1][j];
                int r_value=j==n-1?Integer.MAX_VALUE:dp[i-1][j+1];
                dp[i][j]=Math.min(Math.min(l_value,m_value),r_value)+matrix[i][j];
            }
        }
        int res=Integer.MAX_VALUE;
        for(int i=0;i<n;i++){
            if(res>dp[n-1][i])
                res=dp[n-1][i];
        }
        return res;
    }
}
```

##### 前缀问题

###### [单词拆分](https://leetcode.cn/problems/word-break/)

思路就是深度遍历，从s的0的位置开始，for循环，判断前len部分是不是wordDict中的，如果是就dfs遍历他的下一部分，要是没有的话循环结束就会返回false

```java
class Solution {
    //-1表示未处理，0表示处理为通过，1表示处理通过
    int []visited;
    HashSet<String>Dict;
    public boolean wordBreak(String s, List<String> wordDict) {
        int n=s.length();
        visited=new int[n];
        Arrays.fill(visited,-1);
        Dict=new HashSet<>(wordDict);
        return dp(s,0);
    }
    public boolean dp(String s,int i){
        if(i==s.length())
            return true;
        if(visited[i]!=-1){
            return visited[i]==0?false:true;
        }
        for(int len=1;len+i<=s.length();len++){
            String prix=s.substring(i,i+len);
            if(Dict.contains(prix)){
                boolean flag=dp(s,i+len);
                if(flag==true){
                    visited[i]=1;
                    return true;
                }
            }
        }
        visited[i]=0;
        return false;
    }
}
```

###### [单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

和上一题一样的思路，只不过需要使用一个res数组将结果进行添加，还是把问题看作开头+子问题的结构，List<String>subs=dp(s,i+len);就会返回所有的子结构的组合，只需要for循环中将前缀和子结构进行一个组合就可以得到最后的结果

```java
class Solution {
    HashSet<String>Dict;
    public List<String> wordBreak(String s, List<String> wordDict) {
        Dict=new HashSet<>(wordDict);
        return dp(s,0);
    }
    public List<String>dp(String s,int i){
        List<String>res=new LinkedList<>();
        if(i==s.length()){
            res.add("");
            return res;
        }
        for(int len=1;len+i<=s.length();len++){
            String ss=s.substring(i,i+len);
            if(Dict.contains(ss)){
                List<String>subs=dp(s,i+len);
                for(String r:subs){
                    if(r.isEmpty()){
                        res.add(ss);
                    }else{
                        res.add(ss+" "+r);
                    }
                }
            }
        }
        return res;
    }
}
```

##### 子序列问题

###### [编辑距离](https://leetcode.cn/problems/edit-distance/)

解决思路，两个字符串，从最后开始同时进行遍历，如果两个字符不等，那么就有三种方式，插入删除变化，对应了i，j不同的变化，变化一次步骤就加1

最简单的思路就是使用暴力解法，就递归进行遍历，然后每次charAt不等的时候就三种方式都遍历，求操作步数最小的值

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m=word1.length();
        int n=word2.length();
        return dp(word1,m-1,word2,n-1);
    }
    public int dp(String word1,int w1,String word2,int w2){
        if(w1==-1)
            return w2+1;
        if(w2==-1)
            return w1+1;
        if(word1.charAt(w1)==word2.charAt(w2)){
            return dp(word1,w1-1,word2,w2-1);
        }else{
            return min(
                dp(word1,w1-1,word2,w2)+1,
                dp(word1,w1-1,word2,w2-1)+1,
                dp(word1,w1,word2,w2-1)+1
            );
        }
    }

    public int min(int a,int b,int c){
        return Math.min(a,Math.min(b,c));
    }
}
```

上一种方式超时了，可以考虑下面使用dp数组的方式，思路是一样的，只不过首先设置dp数组第0行和第0列的值，代表假如一个为空的，另一个在对应字符串长度时，需要多少步才能相等

![image-20231211215441173](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231211215441173.png)

接着就是完善dp数组的过程，和dfs遍历一样，首先判断两个对应点的时候是否相等，进行dp数组的更新，每完善一个dp的值代表了当两个字符串分别为对应位置i ，j长度时需要的最低的步数

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m=word1.length();
        int n=word2.length();
        int [][]dp=new int[m+1][n+1];
        for(int i=0;i<=n;i++)
            dp[0][i]=i;
        for(int j=0;j<=m;j++)
            dp[j][0]=j;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=min(
                        dp[i-1][j]+1,
                        dp[i][j-1]+1,
                        dp[i-1][j-1]+1
                    );

                }
            }
        }
        return dp[m][n]; 
    }
    public int min(int a,int b,int c){
        return Math.min(a,Math.min(b,c));
    }
}
```

###### [最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

解法1️⃣：使用动态规划，考虑使用dp数组，状态方程的话，考虑每一个dp的值表示以num[i]结尾的最大子数组的和，那么就有两种可能要么只有自己，要么和前一个相加，

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int []dp=new int[n];
        dp[0]=nums[0];
        for(int i=1;i<n;i++){
            dp[i]=Math.max(nums[i],dp[i-1]+nums[i]);
        }
        int res=Integer.MIN_VALUE;
        for(int i=0;i<n;i++){
            if(res<dp[i])
                res=dp[i];
        }
        return res;
    }
}
```

解法2️⃣：对于这种连续的子串，就可以考虑使用滑动窗口，对于滑动窗口的方法需要考虑什么时候窗口收缩，这道题考虑是windsum小于0的时候收缩，因为窗口内的值小于0，对于新添加的元素就没必要加这一部分，只会更小，所以当窗口内的值小于0时，就不断收缩窗口

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int left=0;int right=0;
        int windsum=0;
        int res=Integer.MIN_VALUE;
        while(right<nums.length){
            windsum+=nums[right];
            right++;
            if(windsum>res)
                res=windsum;
            while(windsum<0){
                windsum-=nums[left];
                left++;
            }
        }
        return res;
    }
}
```

###### [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

思路类似于编辑距离，因为看到是两个字符串，自然就想到了编辑距离问题，将两个字符串创建一个二维的dp数组，然后状态方程也和编辑距离的类似，dpij就是两个字符串长度为i，j的时候的最值

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m=text1.length();
        int n=text2.length();
        int [][]dp=new int[m+1][n+1];
        for(int i=0;i<=m;i++)
            dp[i][0]=0;
        for(int i=0;i<=n;i++)
            dp[0][i]=0;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

###### [两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

思路一样的，对于这种两个字符串进行操作匹配的，都可以利用这种方式求解，先画一个dp表，然后根据其中的规律写状态方程，然后代码实现

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m=word1.length();
        int n=word2.length();
        int [][]dp=new int[m+1][n+1];
        for(int i=0;i<=m;i++)
            dp[i][0]=i;
        for(int j=0;j<=n;j++)
            dp[0][j]=j;
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(word1.charAt(i-1)==word2.charAt(j-1))
                    dp[i][j]=dp[i-1][j-1];
                else{
                    dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+1;
                }
            }
        }
        return dp[m][n];
    }
}
```

###### [两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)

这道题的区别是使用ascii码，我最开始算错了，是因为在最开始设置数组的第一行和第一列的时候，是直接设置的s1.charAt(i-1)，这应该是叠加的

```java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        int m=s1.length();
        int n=s2.length();
        int [][]dp=new int[m+1][n+1];
        for(int i=1;i<=m;i++)
            dp[i][0]=s1.charAt(i-1)+dp[i-1][0];
        for(int i=1;i<=n;i++)
            dp[0][i]=s2.charAt(i-1)+dp[0][i-1];
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(s1.charAt(i-1)==s2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=Math.min(
                        dp[i-1][j]+s1.charAt(i-1),
                        dp[i][j-1]+s2.charAt(j-1)
                    );
                }
            }
        }
        return dp[m][n];
    }
}
```

###### [最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

解法1️⃣：因为是求回文子序列，考虑将s反转成一个新的字符串，然后求这两个字符串的最长公共子序列

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        String s2="";
        for(int i=s.length()-1;i>=0;i--){
            s2+=s.substring(i,i+1);
        }
        int n=s.length();
        int [][]dp=new int[n+1][n+1];
        //设置边界
        //for(int i=0;i<=n;i++){
        //    dp[i][0]=0;
        //    dp[0][i]=0;
        //}
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                if(s.charAt(i-1)==s2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(
                        dp[i-1][j],
                        dp[i][j-1]
                    );
                }
            }
        return dp[n][n];
    }
}
```

解法2️⃣

对于一个回文子序列来说，去掉头尾应仍是回文子序列，按照这个为条件来建立状态方程

dp ij表示从i到j范围内字符串最长的回文子序列，只有当0≤*i*≤*j*<*n* 才会有子序列，否则为0，所以整个dp数组就是一个矩阵的上半角

对于任何长度为1的子序列来说，都是回文子序列，所以dpii都为1，然后计算从上半三角的地步开始计算，如果i，j位置的字符相等那么长度等于去掉这两个之后的最长回文子序列➕2，如果不相等，i，j不可能同时作为同一个回文子序列的首尾，所以就求最大

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n=s.length();
        int [][]dp=new int[n][n];
        for(int i=n-1;i>=0;i--){
            dp[i][i]=1;
            char c1=s.charAt(i);
            for(int j=i+1;j<n;j++){
                char c2=s.charAt(j);
                if(c1==c2){
                    dp[i][j]=dp[i+1][j-1]+2;
                }else{
                    dp[i][j]=Math.max(
                        dp[i+1][j],
                        dp[i][j-1]
                    );
                }
            }
        }
        return dp[0][n-1];
    }
}
```

##### 背包问题

**0-1背包问题**

```java
int knapsack(int W, int N, int[] wt, int[] val) {
    assert N == wt.length;
    // base case 已初始化
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w < wt[i - 1] ) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = Math.max(
                    dp[i - 1][w - wt[i-1]] + val[i-1], 
                    dp[i - 1][w]
                );
            }
        }
    }
    return dp[N][W];
}

```

###### [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

考虑到要分成两个集合值相同，就只需要满足一个集合的值等于总和的一半即可，就相当于n个物品，看是否能自由组合使值刚好等于总和的一半即可。这就相当于0-1背包问题，只不过需求从尽可能装价值更高的物品变成需要正好装入

因为不是求最值，而是求刚好，有可能满足多种情况都刚好的情况，所以dp数组需要为boolean类型，和0-1背包一样，如果当前容量j不够加入第i个物品就为上一个，如果够就判断是否能刚好满足，就要判断减去这个物品，剩下的容量是否能刚好满足

思考：这 for (int i = 0; i <= n; i++)  dp[i][0] = true;的原因：考虑到dp00为true，对于它这一列的其他元素，因为容量为0，那他只会进入if，就相当于只会被dp00赋值，所以相当于提前使用一个for循环

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int res=0;
        for(int i=0;i<nums.length;i++){
            res+=nums[i];
        }
        if(res%2==1)
            return false;
        res=res/2;
        int n=nums.length;
        boolean [][]dp=new boolean[n+1][res+1];
        for (int i = 0; i <= n; i++)
            dp[i][0] = true;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=res;j++){
                if(j<nums[i-1]){
                    dp[i][j]=dp[i-1][j];
                }else{
                    dp[i][j]=dp[i-1][j]||dp[i-1][j-nums[i-1]];
                }
            }
        return dp[n][res];
    }
}
```

###### [零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

这题属于是完全背包问题，物品的数量没有限制，所以状态方程是dp{i}{j}=dp{i-1}{j}+dp{i}{j-coins[i-1]};并且由于是求可能性，所以这个相加的，首先要将00位置设置为1，和上题一样，对于求可能性问题才这么求解，正常的背包问题第一行和第一列都是0

```java
class Solution {
    public int change(int amount, int[] coins) {
        int n=coins.length;
        int [][]dp=new int[n+1][amount+1];
        dp[0][0]=1;
        for(int i=1;i<=n;i++){
            for(int j=0;j<=amount;j++){
                if(j<coins[i-1]){
                    dp[i][j]=dp[i-1][j];
                }else{
                    dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]];
                }
            }
        }
        return dp[n][amount];
    }
}
```

##### 其他

###### [最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m=grid.length;
        int n=grid[0].length;
        int [][]dp=new int[m][n];
        dp[0][0]=grid[0][0];
        for(int i=1;i<n;i++)
            dp[0][i]=grid[0][i]+dp[0][i-1];
        for(int i=1;i<m;i++)
            dp[i][0]=grid[i][0]+dp[i-1][0];
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[m-1][n-1];

    }
}
```

##### [股票买卖问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/yi-ge-fang-3b01b/)

股票问题，如果考虑是有k次交易（1次买入+1次卖出为一次交易）的话，那就设置为三维数组，第一维表示天数，第二维表示交易次数的限制，第三维有0-1两个值，0代表当前购入股票，1代表当前已购入股票，最后的最优结果结果最后一天没有购入股票的值

对于basecase来说，存在以下情况

表示第-1天还没有进行交易，所以对于不含股票的情况，利润为0，对于含有股票的情况，是不可能含有股票的，设置为负无穷

dp(-1)(..)(0)=0

dp(-1)(..)(1)=Integer.MIN_VALUE

表示如果交易次数限制为0的话，是不允许交易的，那么这个时候不含股票的情况利润为0，含有股票的情况是不可能的，设置为负无穷

dp(..)(0)(0)=0

dp(..)(0)(1)=Integer.MIN_VALUE

###### [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

此题中限制了只能交易一次，所以三维数组中的第二维可以省略，如果第二维减1的话，就是0，basecase中都是-prices[i]，所以可以不用添加。

其中的if是因为basecase中出现-1的情况，所以只能自己把这个时候的i给赋值了

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n=prices.length;
        int [][]dp=new int[n][2];
        for(int i=0;i<n;i++){
            if(i-1==-1){
                dp[i][0]=0;
                dp[i][1]=-prices[i];
                continue;
            }
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],-prices[i]);
        }
        return dp[n-1][0];
    }
}
```

###### [买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

对于这道题，与前一题的区别在于可以交易无限次，所以也不需要三维数组中的第二维交易的限制，直接写状态方程即可

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n=prices.length;
        int [][]dp=new int[n][2];
        for(int i=0;i<n;i++){
            if(i-1==-1){
                dp[i][0]=0;
                dp[i][1]=-prices[i];
                continue;
            }
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[n-1][0];
    }
}
```

###### [买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

冷冻期就是购入之后第二天不能在买，所以只需要在稍微修改一下状态方程即可，并且为了不越界，所以考虑多加一个if进行判断

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n=prices.length;
        int[][]dp=new int[n][2];
        for(int i=0;i<n;i++){
            if(i-1==-1){
                dp[i][0]=0;
                dp[i][1]=-prices[i];
                continue;
            }
            if(i-2==-1){
                dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
                dp[i][1]=Math.max(dp[i-1][1],-prices[i]);
                continue;
            }
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-2][0]-prices[i]);
        }
        return dp[n-1][0];
    }
}
```

###### [买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

这道题也是不限制交易次数，与前面的题相比，就是多了一个交易费，只需要在每次完成交易的时候添加交易费用即可

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n=prices.length;
        int [][]dp=new int[n][2];
        for(int i=0;i<n;i++){
            if(i-1==-1){
                dp[i][0]=0;
                dp[i][1]=-prices[i];
                continue;
            }
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]-fee);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[n-1][0];
    }
}
```

###### [买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

对于这种限制交易次数的就比较难，下面是限制交易次数的模版

```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxk=2;
        int n=prices.length;
        //多了限制，所以三维数组
        int [][][]dp=new int[n][maxk+1][2];
        //定义basecase
        for(int i=0;i<n;i++){
            dp[i][0][0]=0;
            dp[i][0][1]=Integer.MIN_VALUE;
        }
        //比起之前的就是多了一个for循环，可以考虑动态规划的方式就是把所有情况进行遍历，在遍历的过程中找到最优解，对于之前的题来说也是进行遍历，只不过是因为第二维度只有0和1，所以只用了一个循环，对于这种交易次数限制的问题来说，也是一样的需要对交易次数进行遍历，在这个过程中求的最优解
        for(int i=0;i<n;i++){
            for(int k=maxk;k>=1;k--){
                if(i-1==-1){
                    dp[i][k][0]=0;
                    dp[i][k][1]=-prices[i];
                    continue;
                }
                dp[i][k][0]=Math.max(dp[i-1][k][0],dp[i-1][k][1]+prices[i]);
                dp[i][k][1]=Math.max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i]);
            }
        }
        return dp[n-1][maxk][0];
    }
}
```

###### [买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

这道题和上一道题的区别在于，交易次数是k次，k可大可小，可以直接套用上面的模版，只不过区别在于如果k很大的话，定义的数组会很大，超过了内存限制，所以考虑到因为不会进行当天交易，完成一次交易至少两天，所以实际的交易次数是不会超过n/2，所以当给的交易次数超过了n/2，就可以把问题看作是无限交易次数问题，定义二维数组，从而解决k过大，内存超出限制的问题。其他的就直接套用之前的套路即可。

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        int n=prices.length;
        if(k>=n/2)
            return maxProfit_inf(prices);
        int [][][]dp=new int[n][k+1][2];
        for(int i=0;i<n;i++){
            dp[i][0][0]=0;
            dp[i][0][1]=Integer.MIN_VALUE;
        }
        for(int i=0;i<n;i++){
            for(int j=k;j>=1;j--){
                if(i-1==-1){
                    dp[i][j][0]=0;
                    dp[i][j][1]=-prices[i];
                    continue;
                }
                dp[i][j][0]=Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]);
                dp[i][j][1]=Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i]);
            }
        }
        return dp[n-1][k][0];
    }

    public int maxProfit_inf(int []prices){
        int n=prices.length;
        int [][]dp=new int[n][2];
        for(int i=0;i<n;i++){
            if(i-1==-1){
                dp[i][0]=0;
                dp[i][1]=-prices[i];
                continue;
            }
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);
        }
        return dp[n-1][0];
    }
}
```

将前面所有问题都结合起来，即k次限制，要交易费用，要冷冻cool_n天，可以用以下代码

```java
// 同时考虑交易次数的限制、冷冻期和手续费
int maxProfit_all_in_one(int max_k, int[] prices, int cooldown, int fee) {
    int n = prices.length;
    if (n <= 0) {
        return 0;
    }
    if (max_k > n / 2) {
        // 交易次数 k 没有限制的情况
        return maxProfit_k_inf(prices, cooldown, fee);
    }

    int[][][] dp = new int[n][max_k + 1][2];
    // k = 0 时的 base case
    for (int i = 0; i < n; i++) {
        dp[i][0][1] = Integer.MIN_VALUE;
        dp[i][0][0] = 0;
    }

    for (int i = 0; i < n; i++) 
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // base case 1
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i] - fee;
                continue;
            }

            // 包含 cooldown 的 base case
            if (i - cooldown - 1 < 0) {
                // base case 2
                dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                // 别忘了减 fee
                dp[i][k][1] = Math.max(dp[i-1][k][1], -prices[i] - fee);
                continue;
            }
            dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            // 同时考虑 cooldown 和 fee
            dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-cooldown-1][k-1][0] - prices[i] - fee);     
        }
    return dp[n - 1][max_k][0];
}

// k 无限制，包含手续费和冷冻期
int maxProfit_k_inf(int[] prices, int cooldown, int fee) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // base case 1
            dp[i][0] = 0;
            dp[i][1] = -prices[i] - fee;
            continue;
        }

        // 包含 cooldown 的 base case
        if (i - cooldown - 1 < 0) {
            // base case 2
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            // 别忘了减 fee
            dp[i][1] = Math.max(dp[i-1][1], -prices[i] - fee);
            continue;
        }
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        // 同时考虑 cooldown 和 fee
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - cooldown - 1][0] - prices[i] - fee);
    }
    return dp[n - 1][0];
}

```

### 回溯算法

回溯算法一般使用dfs遍历，写dfs的时候考虑两个点第一个是返回的条件是什么，第二个是进行下一步递归。

至于dfs里面是否会用到visited数组，取决于考虑遍历的过程中是否有可能会遇到原来的值，并且要考虑递归之后是否要把visited改回来，这个取决于后面是否还需要用到该点，比如说排列组合问题，只是在当前路径用过该点，暂时不需要，在其他路径还是有可能用到该点，所以在遍历后要把visited改回来，但像图的遍历的时候，比如像岛屿问题，遍历过该点，走过这条路，后面就不会再走了，那这个时候就不用把visited改回来

像排列组合问题，要求很多条不同路径，这个时候就要遍历前将该点加入路径，遍历之后把该点去除，这样才能保证路径的正确性，并且由于java引用的特性，每次将path路径加入res中需要创建一个新的list放进去，因为放入的是地址，不然最后res会为空

###### [N 皇后](https://leetcode.cn/problems/n-queens/)

回溯问题一般就是暴力遍历，然后对不符合的情况进行减枝，类似于这种回溯的话，一般是要求路径的，对于要求路径的问题，方法最开始进行判断是否完成目标，若完成加入res数组，返回，如果没有则对该节点下一步的节点进行遍历，找到一个满足条件的，加入路径，进入递归，然后递归出来的时候表示已经遍历完了，就恢复（因为要求所有的结果，所有的情况），进行下一次判断

```java
class Solution {
    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        List<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < n; j++) {
                sb.append('.');
            }
            board.add(sb.toString());
        }
        backtrack(board, 0);
        return res;
    }
    void backtrack(List<String> board, int row) {
        if (row == board.size()) {
            res.add(new ArrayList<>(board));
            return
        }
        int n = board.get(row).length();
        for (int col = 0; col < n; col++) {
            if (!isValid(board, row, col)) {
                continue;
            }
            StringBuilder sb = new StringBuilder(board.get(row));
            sb.setCharAt(col, 'Q');
            board.set(row, sb.toString());
            backtrack(board, row + 1);
            sb.setCharAt(col, '.');
            board.set(row, sb.toString());
        }
    }
    boolean isValid(List<String> board, int row, int col) {
        int n = board.size();
        for (int i = 0; i < n; i++) {
            if (board.get(i).charAt(col) == 'Q') {
                return false;
            }
        }
        for (int i = row - 1, j = col + 1;
             i >= 0 && j < n; i--, j++) {
            if (board.get(i).charAt(j) == 'Q') {
                return false;
            }
        }
        for (int i = row - 1, j = col - 1;
             i >= 0 && j >= 0; i--, j--) {
            if (board.get(i).charAt(j) == 'Q') {
                return false;
            }
        }
        return true;
    }
}

```

对string进行处理，可以使用StringBuilder

##### 排队组合问题

这类题把所有组合想成是一个树，不同路径往下走

###### [全排列](https://leetcode.cn/problems/permutations/)

used遇到用过的是continue，不能用return，return的话这个分支就直接返回了，continue会找其他节点

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    LinkedList<Integer>path=new LinkedList<>();
    public List<List<Integer>> permute(int[] nums) {
        
        boolean []used=new boolean[nums.length];
        dfs(nums,used);
        return res;

    }
    public void dfs(int []nums,boolean []used){
        if(path.size()==nums.length){
            res.add(new LinkedList(path));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(used[i]){
                continue;
            }
            used[i]=true;
            path.add(nums[i]);
            dfs(nums,used);
            path.removeLast();
            used[i]=false;
        }
    }

}
```

###### [子集](https://leetcode.cn/problems/subsets/)

这道题也用的回溯的思想，区别在于找子集的时候，是按照顺序找到，即每次找的都是当前元素的后面，这样能避免重复，**所以对于这种按顺序找的就不需要used数组，而且由于每一个节点都是结果的一部分，所以也不需要if来进行判断是否结束。**

![image-20231221103206476](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221103206476.png)

对于这种按顺序找的实现的话，只需要在dfs中for循环每次从start开始即可，同时dfs形参需要加入这么一个变量

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    List<Integer>path=new LinkedList<>();
    public List<List<Integer>> subsets(int[] nums) {
        dfs(nums,0);
        return res;
    }
    public void dfs(int[]nums,int start){
        res.add(new LinkedList(path));
        for(int i=start;i<nums.length;i++){
            path.add(nums[i]);
            dfs(nums,i+1);
            path.removeLast();
        }
    }
}
```

###### [组合](https://leetcode.cn/problems/combinations/)

组合问题比起子集问题的区别是设定了结果集的长度为k，所以只需要加个if判断，只有path长度为k的时候才加入结果集即可，并且当path长度为k，就可以直接返回，不需要再往下进行递归了

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    List<Integer>path=new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        dfs(n,k,1);
        return res;
    }

    public void dfs(int n,int k,int start){
        if(path.size()==k){
            res.add(new LinkedList(path));
            return;
        }
        for(int i=start;i<=n;i++){
            path.add(i);
            dfs(n,k,i+1);
            path.removeLast();
        }
    }
}
```

###### [子集 II](https://leetcode.cn/problems/subsets-ii/)

这道题的区别是有集合内有重复的值，但结果集不能要重复的值，最开始的想法是在添加res数组的时候进行判断，即判断数组内是否已包含该集合，用下面代码实现

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    List<Integer>path=new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        dfs(nums,0);
        return res;
    }
    public void dfs(int []nums,int start){
        if(!res.contains(path)){
            res.add(new LinkedList(path));
        }
        for(int i=start;i<nums.length;i++){
            path.add(nums[i]);
            dfs(nums,i+1);
            path.removeLast();
        }
    }
}
```

但出错了，出错的原因是，如果[4,1,4]，则结果出现[4,1]和[1,4]，这是算两个结果，但这实际上是一个结果，对于这种情况考虑修正的话，可以对nums原数组进行重新排序，排序之后相同元素都放在一起了，就不会出现这种情况了，代码如下：

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    List<Integer>path=new LinkedList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        dfs(nums,0);
        return res;
    }
    public void dfs(int []nums,int start){
        if(!res.contains(path)){
            res.add(new LinkedList(path));
        }
        for(int i=start;i<nums.length;i++){
            path.add(nums[i]);
            dfs(nums,i+1);
            path.removeLast();
        }
    }
}
```

###### [组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

解法1️⃣：这是参照子集的解法来写的，思路是没问题，但是有几个样例超过了时间限制

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    List<Integer>path=new LinkedList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        dfs(candidates,target,0,0);
        return res;
    }
    public void dfs(int []candidates,int target,int start,int sum){
        if(sum==target&&!res.contains(path)){
            res.add(new LinkedList(path));
            return;
        }
        if(sum>target||res.contains(path)){
            return;
        }
        for(int i=start;i<candidates.length;i++){
            path.add(candidates[i]);
            sum+=candidates[i];
            dfs(candidates,target,i+1,sum);
            sum-=candidates[i];
            path.removeLast();
        }
    }
}
```

方法2️⃣：进行减枝，考虑的是当重复多个相同的值的时候，只要第一个，后面的都剪掉，剪枝的具体实施如下，除了start和他下一个可以相同以外，其他的都不可以，

```java
if(i>start&&candidates[i-1]==candidates[i])
      continue;
```

完整代码：

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    List<Integer>path=new LinkedList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        dfs(candidates,target,0,0);
        return res;
    }
    public void dfs(int []candidates,int target,int start,int sum){
        if(sum==target){
            res.add(new LinkedList(path));
            return;
        }
        if(sum>target){
            return;
        }
        for(int i=start;i<candidates.length;i++){
            if(i>start&&candidates[i-1]==candidates[i])
                continue;
            path.add(candidates[i]);
            sum+=candidates[i];
            dfs(candidates,target,i+1,sum);
            sum-=candidates[i];
            path.removeLast();
        }
    }
}
```

###### [全排列 II](https://leetcode.cn/problems/permutations-ii/)

解法1️⃣：老活，用contains来判断，其他一样

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    List<Integer>path=new LinkedList<>();
    boolean []used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        used=new boolean[nums.length];
        Arrays.sort(nums);
        dfs(nums);
        return res;
    }
    public void dfs(int []nums){
        if(path.size()==nums.length&&!res.contains(path)){
            res.add(new LinkedList(path));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(used[i])
                continue;
            path.add(nums[i]);
            used[i]=true;
            dfs(nums);
            path.removeLast();
            used[i]=false;
        }
    }
}
```

解法2️⃣：还是使用剪枝的方式

```java
class Solution {

    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> track = new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        used = new boolean[nums.length];
        backtrack(nums);
        return res;
    }

    void backtrack(int[] nums) {
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            // 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            track.add(nums[i]);
            used[i] = true;
            backtrack(nums);
            track.removeLast();
            used[i] = false;
        }
    }
}

```

###### [组合总和](https://leetcode.cn/problems/combination-sum/)

无重复可复用问题，最开始的想法是在for循环中都是从0开始，然后进行判断，但这样的话会导致重复的结果，考虑到之前子集的时候其去掉重复的结果是通过从start开始，逐渐往下进行递归i+1，对于这道题，也可以从start开始，往下递归的时候也是i开始，这样就做到了可复用

```java
class Solution {
    List<List<Integer>>res=new LinkedList<>();
    List<Integer>path=new LinkedList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(candidates,target,0,0);
        return res;
    }
    public void dfs(int []candidates,int target,int sum,int start){
        if(sum==target){
            res.add(new LinkedList(path));
            return;
        }
        if(sum>target){
            return;
        }
        for(int i=start;i<candidates.length;i++){
            path.add(candidates[i]);
            sum+=candidates[i];
            dfs(candidates,target,sum,i);
            sum-=candidates[i];
            path.removeLast();
        }
    }
}
```

###### [划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

这道题的思路也是回溯遍历，不断的进行组合，组合到一个per，就进行下一个遍历，如果都成功就返回true，如果没有就false，本质上没太大区别

```java
class Solution {
    int target;
    int []nums;
    boolean []used;
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum=Arrays.stream(nums).sum();
        if(sum%k!=0)
            return false;
        target=sum/k;
        this.nums=nums;
        used=new boolean[nums.length];
        return dfs(0,k,0);
    }

    public boolean dfs(int start,int k,int bucket){
        if(k==0){
            return true;
        }
        if(bucket==target){
            return dfs(0,k-1,0);
        }
        for(int i=start;i<nums.length;i++){
            if(used[i])
                continue;
            if(bucket+nums[i]>target)
                continue;
            used[i]=true;
            bucket+=nums[i];
            if(dfs(i+1,k,bucket))
                return true;
            used[i]=false;
            bucket-=nums[i];
        }
        return false;
    }
}
```

###### [括号生成](https://leetcode.cn/problems/generate-parentheses/)

给定括号的数量，让生成各种组合，只需要不断遍历即可，值得注意的是这个判断的方式，不需要用栈来判断，定义一个left和right两个指针来表示左括号和右括号的数量即可

```java
class Solution {
    List<String>res=new ArrayList<>();
    StringBuilder sb=new StringBuilder();
    public List<String> generateParenthesis(int n) {
        dfs(n,n);
        return res;
    }
    public void dfs(int left,int right){
        if(left<0||right<0)
            return;
        if(left>right)
            return;
        if(left==0&&right==0){
            res.add(sb.toString());
            return;
        }
        sb.append('(');
        dfs(left-1,right);
        sb.deleteCharAt(sb.length()-1);
        sb.append(')');
        dfs(left,right-1);
        sb.deleteCharAt(sb.length()-1);
    }
}
```

##### 岛屿问题

###### [飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)

方法1️⃣：使用经典的dfs遍历，定义一个方位数组，比较耗时，有一个用例没过

```java
class Solution {
    boolean [][]visited;
    int [][]p={
      {0,1},
      {0,-1},
      {1,0},
      {-1,0}
    };
    public int numEnclaves(int[][] grid) {
        int count=0;
        for(int i=1;i<grid.length-1;i++){
            for(int j=1;j<grid[0].length-1;j++){
                if(grid[i][j]==1){
                    visited=new boolean[grid.length][grid[0].length];
                    if(!dfs(grid,i,j)){
                        count++;
                    }
                }
            }
        }
        return count;
    }
    public boolean dfs(int [][]grid,int x,int y){
        if(x==0||x==grid.length-1||y==0||y==grid[0].length-1){
            return true;
        }
        for(int []to:p){
            int x_new=x+to[0];
            int y_new=y+to[1];
            if(grid[x_new][y_new]!=0&&!visited[x_new][y_new]){
                visited[x_new][y_new]=true;
                if(dfs(grid,x_new,y_new)){
                    return true;
                }
            }
        }
        return false;
    }
}
```

方法2️⃣：换一个角度思考，之前是找非边界的陆地是否能到边界，现在换个思路，首先遍历边界，把边界能到的陆地都走一遍，最后直接数哪些陆地没有遍历即可

```java
class Solution {
    boolean [][]visited;
    int [][]p={
      {0,1},
      {0,-1},
      {1,0},
      {-1,0}
    };
    public int numEnclaves(int[][] grid) {
        int count=0;
        visited=new boolean[grid.length][grid[0].length];
        for (int i = 0; i < grid.length; i++) {
            dfs(grid, i, 0);
            dfs(grid, i, grid[0].length-1);
        }
        for (int j = 1; j < grid[0].length-1; j++) {
            dfs(grid, 0, j);
            dfs(grid, grid.length - 1, j);
        }
        for(int i=1;i<grid.length-1;i++){
            for(int j=1;j<grid[0].length-1;j++){
                if(grid[i][j]==1&&!visited[i][j]){
                    count++;
                }
            }
        }
        return count;
    }
    public void dfs(int [][]grid,int x,int y){
        if(x<0||x>grid.length-1||y<0||y>grid[0].length-1||grid[x][y]!=1||visited[x][y]){
            return;
        }
        visited[x][y]=true;
        for(int []to:p){
            dfs(grid,x+to[0],y+to[1]);
        }
        return;
    }
}
```

###### [岛屿数量](https://leetcode.cn/problems/number-of-islands/)

这道题的思路是这样的，首先遍历遇到一个岛屿就count++，然后将这个岛屿及其所有邻接的地方全部淹没，后续就不会再遇到了，也可以用find-union来做，不过更麻烦一些

```java
class Solution {
    int [][]position={
      {1,0},
      {-1,0},
      {0,1},
      {0,-1}
    };
    public int numIslands(char[][] grid) {
        int m=grid.length;
        int n=grid[0].length;
        int count=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]=='1'){
                    count++;
                    dfs(grid,i,j);
                }
            }
        }
        return count;
    }

    public void dfs(char [][]grid,int x,int y){
        if(x<0||x>grid.length-1||y<0||y>grid[0].length-1||grid[x][y]=='0'){
            return;
        }
        grid[x][y]='0';
        for(int[] to:position){
            dfs(grid,x+to[0],y+to[1]);
        }
    }
}
```

###### [统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)

我的思路是：要求封闭岛屿的数量，参照上一题也是进行邻接岛屿的淹没，不过在递归的时候要进行判断，如果递归的点能到达边界，且值为0的话，那说明能和外界连通，不是封闭岛屿，将flag设置为false，如果遇到的是1，那就正常返回，通过这样的方式进行判断

```java
class Solution {
    int [][]positions={
      {0,1},
      {0,-1},
      {1,0},
      {-1,0}
    };
    boolean flag;
    public int closedIsland(int[][] grid) {
        int count=0;
        for(int i=1;i<grid.length;i++){
            for(int j=1;j<grid[0].length;j++){
                if(grid[i][j]==0){
                    flag=true;
                    dfs(grid,i,j);
                    if(flag==true)
                        count++;
                }
            }
        }
        return count;

    }
    public void dfs(int [][]grid,int x,int y){
        if(x==0||x==grid.length-1||y==0||y==grid[0].length-1){
            if(grid[x][y]==0){
                flag=false;
                return;
            }
        }
        if(grid[x][y]==1)
            return;
        grid[x][y]=1;
        for(int []position:positions){
            dfs(grid,x+position[0],y+position[1]);
        }
    }
}
```

也可以参照飞地的思路，就遍历四条边的岛屿，把边界连通的岛屿淹没掉，这样剩下的就都是封闭岛了

###### [岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

这道题的思路也是淹没，区别是淹没的过程中要统计该岛的数量，最后输出最大值

```java
class Solution {
    int [][]positions={
      {0,1},
      {0,-1},
      {1,0},
      {-1,0}
    };
    int count;
    public int maxAreaOfIsland(int[][] grid) {
        int res=Integer.MIN_VALUE;
        for(int i=0;i<grid.length;i++){
            for(int j=0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    count=0;
                    dfs(grid,i,j);
                    if(count>res){
                        res=count;
                    }
                }
            }
        }
        return res==Integer.MIN_VALUE?0:res;
    }
    public void dfs(int [][]grid,int x,int y){
        if(x<0||x>grid.length-1||y<0||y>grid[0].length-1||grid[x][y]==0){
            return;
        }
        count++;
        grid[x][y]=0;
        for(int []position:positions){
            dfs(grid,x+position[0],y+position[1]);
        }
    }
}
```

###### [统计子岛屿](https://leetcode.cn/problems/count-sub-islands/)

一样的思路，区别在于，由于是求2中是1的岛屿数量，所以对2进行遍历，在遍历2的过程中判断2中的岛屿是否1都有，如果有的话就算子岛屿，否则就不算

```java
class Solution {
    int [][]positions={
      {1,0},
      {-1,0},
      {0,1},
      {0,-1}
    };
    boolean flag;
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        int res=0;
        for(int i=0;i<grid2.length;i++){
            for(int j=0;j<grid2[0].length;j++){
                if(grid2[i][j]==1){
                    flag=true;
                    dfs(grid1,grid2,i,j);
                    if(flag==true){
                        res++;
                    }
                }
            }
        }
        return res;
    }
    public void dfs(int [][]grid1,int [][]grid2,int x,int y){
        if(x<0||x>grid2.length-1||y<0||y>grid2[0].length-1||grid2[x][y]==0){
            return;
        }
        if(grid1[x][y]!=grid2[x][y]){
            flag=false;
            return;
        }
        grid2[x][y]=0;
        for(int []position:positions){
            dfs(grid1,grid2,x+position[0],y+position[1]);
        }
    }
}
```

###### [不同岛屿数量](https://leetcode.cn/problems/number-of-distinct-islands/description/)

求地图中形状不同的岛屿数量

所以这道题的思路是将岛屿的形状记录在HashSet中，最后统计HashSet的面积即可，但如何记录形状呢，考虑序列化该岛屿，在遍历岛屿的时候，如果记录遍历整个岛屿的步骤，即每一步是向哪个方向的，递归结束后，是怎么撤回的，记录这个步骤就可以判断两个岛屿是否相同

不过这里面存在几个值得注意的地方

1. 这里面两个岛屿是否相同是两个岛屿不能有旋转之类的操作，即从同一个视图看是相同的才行
2. 遍历两个相同岛屿的时候一定是从相同的位置进行遍历的
3. 一定要加撤销的步骤，比方说「下，右，撤销右，撤销下」和「下，撤销下，右，撤销右」显然是两个不同的遍历顺序，但如果不记录撤销操作，那么它俩都是「下，右」，成了相同的遍历顺序
4. 关于记录遍历步骤，可以用StringBuilder来记录，然后再将StringBuilder toString，将入HashSet即可

```java
class Solution {
    public int numDistinctIslands(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        // 记录所有岛屿的序列化结果
        HashSet<String> islands = new HashSet<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 淹掉这个岛屿，同时存储岛屿的序列化结果
                    StringBuilder sb = new StringBuilder();
                    // 初始的方向可以随便写，不影响正确性
                    dfs(grid, i, j, sb, 666);
                    islands.add(sb.toString());
                }
            }
        }
        // 不相同的岛屿数量
        return islands.size();
    }
    void dfs(int[][] grid, int i, int j, StringBuilder sb, int dir) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n 
            || grid[i][j] == 0) {
            return;
        }
        // 前序遍历位置：进入 (i, j)
        grid[i][j] = 0;
        sb.append(dir).append(',');

        dfs(grid, i - 1, j, sb, 1); // 上
        dfs(grid, i + 1, j, sb, 2); // 下
        dfs(grid, i, j - 1, sb, 3); // 左
        dfs(grid, i, j + 1, sb, 4); // 右

        // 后序遍历位置：离开 (i, j)
        sb.append(-dir).append(',');
	}
}
```

##### 数独问题

###### [解数独](https://leetcode.cn/problems/sudoku-solver/)

这道题也是用回溯的思想，遍历每一个空的格子，找到其的值，不过和之前回溯不同的地方在于，这道题只需要求一个结果，所以可以把dfs设置为boolean，当遍历出一个正确结果，就直接返回，是下面代码体现

```java
            if(dfs(board,x,y+1)){
                return true;
            }
```

然后就是和岛屿问题不一样的是，这道题是一个组合问题，是在不断试错的过程，所以在遍历之前board(x)(y)=c，遍历之后，没有返回true，说明该方案失败，就要board(x)(y)=‘.’，岛屿问题就是一个单纯的遍历融合问题，没有这种操作，但对于迷宫问题，也有visited数组来看是否走过该路，但是遍历之后没有改回来，是因为对于迷宫问题，走不通该路径，下次再遇到还是走不通，对于这种组合问题，这次没走通，但换个组合就有可能可以走通，所以要改回来

这道题没有visited数组，是因为遍历的顺序就是从左到右，从上到下，所以也不会遇到之前走过的格子，只是如果遍历失败，就要把当前的路径抹去，换一个组合重新走

```java
class Solution {
    public void solveSudoku(char[][] board) {
        dfs(board,0,0);
    }
    public boolean dfs(char [][]board,int x,int y){
        //判断列越界
        if(y==board[0].length){
            return dfs(board,x+1,0);
        }
        //判断行越界
        if(x==board.length){
            return true;
        }
        //判断非空
        if(board[x][y]!='.'){
            return dfs(board,x,y+1);
        }
        for(char c='1';c<='9';c++){
            //判断合法
            if(!isValid(board,x,y,c))
                continue;
            board[x][y]=c;
            if(dfs(board,x,y+1)){
                return true;
            }
            board[x][y]='.';
        }
        return false;
    }
    public boolean isValid(char [][]board,int x,int y,char ch){
        for(int i=0;i<9;i++){
            //判断竖和横
            if(board[x][i]==ch||board[i][y]==ch){
                return false;
            }
            //这个判断3*3小方格内
            if (board[(x/3)*3 + i/3][(y/3)*3 + i%3] == ch)
                return false;
        }
        return true;
    }
}
```

### BFS

###### [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null)
            return 0;
        Queue<TreeNode>queue=new LinkedList<>();
        queue.add(root);
        int depth=1;
        while(!queue.isEmpty()){
            int size=queue.size();
            for(int i=0;i<size;i++){
                TreeNode node=queue.poll();
                if(node.left==null&&node.right==null){
                    return depth;
                }
                if(node.left!=null)
                    queue.add(node.left);
                if(node.right!=null)
                    queue.add(node.right);
            }
            depth++;
        }
        return depth;
    }
}
```

###### [打开转盘锁](https://leetcode.cn/problems/open-the-lock/)

这道题有意思的点在于对string的处理，一般如果是添加的话就可以转为StringBuilder，如果是就对当前的进行修改的话就可以改为toCharArray，换成char类型数组来进行处理，最后再new string

```java
class Solution {
    public int openLock(String[] deadends, String target) {
        Queue<String> queue=new LinkedList<>();
        Set<String>dead=new HashSet<>();
        int step=0;
        for(String d:deadends)
            dead.add(d);
        Set<String>visited=new HashSet<>();
        queue.add("0000");
        visited.add("0000");
        while(!queue.isEmpty()){
            int size=queue.size();
            for(int i=0;i<size;i++){
                String q=queue.poll();
                if(dead.contains(q))
                    continue;
                if(q.equals(target))
                    return step;
                for(int j=0;j<4;j++){
                    String up=plus(q,j);
                    if(!visited.contains(up)){
                        visited.add(up);
                        queue.offer(up);
                    }
                    String down=minus(q,j);
                    if(!visited.contains(down)){
                        visited.add(down);
                        queue.offer(down);
                    }
                }
            }
            step++;
        }
        return -1;
    }
    public String plus(String s,int position){
        char []array=s.toCharArray();
        if(array[position]=='9')
            array[position]='0';
        else
            array[position]+=1;
        return new String(array);
    }
    public String minus(String s,int position){
        char []array=s.toCharArray();
        if(array[position]=='0')
            array[position]='9';
        else
            array[position]-=1;
        return new String(array);
    }
}
```

###### [滑动谜题](https://leetcode.cn/problems/sliding-puzzle/)

这道题就是数组华容道，考虑用bfs来做，所以首先要转化为bfs问题，就是如何遍历的问题，考虑到每次都是0所在的位置和周围的位置进行交换，这就可以转化为bfs了

![image-20231227111320830](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231227111320830.png)

接下来就只剩一个问题，如何找到这个0所在位置是和其他哪些位置的进行交换，这里因为题目说了是2*3，所以可以考虑使用邻接表的方式，不然的话就只能使用方位数组然后进行判断越界了。

```java
class Solution {
    public int slidingPuzzle(int[][] board) {
        int m=board.length;int n=board[0].length;
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<m;i++)
            for(int j=0;j<n;j++)
                sb.append(board[i][j]);
        int[][] arcmap = new int[][]{
                {1, 3},
                {0, 4, 2},
                {1, 5},
                {0, 4},
                {3, 1, 5},
                {4, 2}
        };
        Queue<String>queue=new LinkedList<>();
        Set<String>visited=new HashSet<>();
        String target="123450";
        int step=0;
        queue.add(sb.toString());
        visited.add(sb.toString());
        while(!queue.isEmpty()){
            int size=queue.size();
            for(int i=0;i<size;i++){
                String s=queue.poll();
                if(s.equals(target)){
                    return step;
                }
                int index=0;
              	//找到这个string中的0所在的位置
                for(int k=0;k<6;k++){
                    if(s.charAt(k)=='0'){
                        index=k;
                        break;
                    }
                }
                //对0所在的位置的邻接表进行遍历
                for(int p:arcmap[index]){
                    String ss=swap(s,p,index);
                    if(!visited.contains(ss)){
                        visited.add(ss);
                        queue.add(ss);
                    }
                }
            }
            step++;
        }
        return -1;
    }
    public String swap(String s,int p,int index){
        char []array=s.toCharArray();
        char temp=array[index];
        array[index]=array[p];
        array[p]=temp;
        return new String(array);
    }
}
```

### 位运算

**判断两个数是否异号**

利用的是**补码编码**的符号位。整数编码最高位是符号位，负数的符号位是 1，非负数的符号位是 0，再借助异或的特性，可以判断出两个数字是否异号。

```java
int x = -1, y = 2;
boolean f = ((x ^ y) < 0); // true

int x = 3, y = 2;
boolean f = ((x ^ y) < 0); // false
```

**`n & (n-1)` 的运用**

**`n & (n-1)` 这个操作在算法中比较常见，作用是消除数字 `n` 的二进制表示中的最后一个 1**。

比如说7是111，7-1就是110，这个时候用&，就是110，就会消去7的最后一个1，每次消去一个，这个也可以用来求一个数其中1的数量

###### [位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        while(n!=0){
            n=n&(n-1);
            count++;
        }
        return count;
    }
}
```

###### [2 的幂](https://leetcode.cn/problems/power-of-two/)

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n<0)
            return false;
        int count=0;
        while(n!=0){
            n=n&(n-1);
            count++;
        }
        return count==1?true:false;
    }
}
```

**`a ^ a = 0` 的运用**

异或即相异为1，相同为0

一个数和它本身做异或运算结果为 0，即 `a ^ a = 0`；一个数和 0 做异或运算的结果为它本身，即 `a ^ 0 = a`

###### [只出现一次的数字](https://leetcode.cn/problems/single-number/)

我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素，比如说[2,1,2]，就是10->11->01，就是落单的1

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res=0;
        for(int n:nums){
            res^=n;
        }
        return res;
    }
}
```

###### [丢失的数字](https://leetcode.cn/problems/missing-number/)

```java
class Solution {
    public int missingNumber(int[] nums) {
        int n=nums.length;
        int res=0;
        for(int num:nums)
            res^=num;
        for(int i=0;i<=n;i++)
            res^=i;
        return res;
    }
}
```

### 分治法

###### [为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

```java
class Solution {
    public List<Integer> diffWaysToCompute(String expression) {
        List<Integer>res=new ArrayList<>();
        for(int i=0;i<expression.length();i++){
            char ch=expression.charAt(i);
            if(ch=='+'||ch=='-'||ch=='*'){
                List<Integer>left=diffWaysToCompute(expression.substring(0,i));
                List<Integer>right=diffWaysToCompute(expression.substring(i+1));
                for(int l:left){
                    for(int r:right){
                        if(ch=='+'){
                            res.add(l+r);
                        }else if(ch=='*')
                            res.add(l*r);
                        else if(ch=='-')
                            res.add(l-r);
                    }
                }
            }
        }
        if(res.isEmpty())
            res.add(Integer.parseInt(expression));
        return res;
    }
}
```

### 其他

###### [计数质数](https://leetcode.cn/problems/count-primes/)

方法1️⃣：最直接的判别法     超时

```java
class Solution {
    public int countPrimes(int n) {
        int count=0;
        for(int i=2;i<n;i++){
            if(isPrimes(i))
                count++;
        }
        return count;
    }
    public boolean isPrimes(int n){
        for(int i=2;i<=Math.sqrt(n);i++){
            if(n%i==0)
                return false;
        }
        return true;
    }
}
```

方法2️⃣：素数筛选法

这道题的思路是当某一个数是素数时，它的倍数都不是素数，所以就将它的倍数都设置为非素数即可

```java
class Solution {
    public int countPrimes(int n) {
        boolean []isPrimes=new boolean[n];
        Arrays.fill(isPrimes,true);
        for(int i=2;i*i < n;i++){
            if(isPrimes[i]){
              	//设置该素数的2倍，3倍，4倍...都为非素数
                for(int j=i*2;j<n;j+=i)
                    isPrimes[j]=false;
            }
        }
        int count=0;
        for(int i=2;i<n;i++)
            if(isPrimes[i])
                count++;
        return count;
    }
}
```

###### [分割数组为连续子序列](https://leetcode.cn/problems/split-array-into-consecutive-subsequences/)

这道题的思路是挨个判断每个数组，考虑到对于数组中的每个数字，只有两种选择，第一种是将该数字加到一个序列的后面，一个是将该数字作为一个序列的开头，所以整体思路就是对每个数字判断是否属于这两种情况，如果不属于就返回false

具体实现的话定义两个hashmap，freq记录了每个数字出现的次数，**`need` 记录哪些元素可以被接到其他子序列后面**

```java
class Solution {
    public boolean isPossible(int[] nums) {
        HashMap<Integer,Integer>freq=new HashMap<>();
        HashMap<Integer,Integer>need=new HashMap<>();
        for(int n:nums)
            freq.put(n,freq.getOrDefault(n,0)+1);
        for(int n:nums){
            if(freq.get(n)==0)
                continue;
            if(need.containsKey(n)&&need.get(n)>0){
                freq.put(n,freq.getOrDefault(n,0)-1);
                need.put(n,need.getOrDefault(n,0)-1);
                need.put(n+1,need.getOrDefault(n+1,0)+1);
            }else if(freq.containsKey(n)&&freq.get(n)>0&&freq.containsKey(n+1)&&freq.get(n+1)>0&&freq.containsKey(n+2)&&freq.get(n+2)>0){
                freq.put(n, freq.get(n) - 1);
                freq.put(n + 1, freq.get(n + 1) - 1);
                freq.put(n + 2, freq.get(n + 2) - 1);
                need.put(n + 3, need.getOrDefault(n + 3, 0) + 1);
            }else{
                return false;
            }
        }
        return true;
    }
}
```

###### [煎饼排序](https://leetcode.cn/problems/pancake-sorting/)

本质上就是一个选择排序，每次挑出当前集合中的最大值，反转两次，一次反转到数组头，一次反转到数组尾，注意是反转不是交换

```java
class Solution {
    List<Integer>res=new ArrayList<>();
    public List<Integer> pancakeSort(int[] arr) {
        sort(arr,arr.length);
        return res;
    }

    public void sort(int []arr,int n){
        if(n==1)
            return;
        int max=Integer.MIN_VALUE;
        int index=-1;
        for(int i=0;i<n;i++){
            if(arr[i]>max){
                max=arr[i];
                index=i;
            }
        }
        reverse(arr,0,index);
        res.add(index+1);
        reverse(arr,0,n-1);
        res.add(n);
        sort(arr,n-1);


    }

    public void reverse(int []arr,int i,int j){
        while(i<j){
            int temp=arr[i];
            arr[i]=arr[j];
            arr[j]=temp;
            i++;
            j--;
        }
    }
}
```

###### [字符串相乘](https://leetcode.cn/problems/multiply-strings/)

这道题因为考虑num1，num2的过长的情况，且不能使用任何内置的 BigInteger 库或直接将输入转换为整数。所以考虑模拟乘法计算式来计算

整体的思路就是按照下面的乘法式来进行计算

![image-20231229163756219](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231229163756219.png)

使用一个res的数组来记录结果，这里需要注意的是，每次i，j计算的时候所涉及到的res中的索引位置就是i+j和i+j+1

```java
class Solution {
    public String multiply(String num1, String num2) {
        int m=num1.length();int n=num2.length();
        int []res=new int[m+n];
        for(int i=m-1;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                int mul=(num1.charAt(i)-'0')*(num2.charAt(j)-'0');
                int p=i+j;
                int q=i+j+1;
              	//考虑到进位的问题，所以先让mul和res[q]相加，得到完整结果再来在res中赋值
                int sum=res[q]+mul;
                res[q]=sum%10;
                res[p]+=sum/10;
            }
        }
        int i=0;
        //这里是考虑到数组前面有空位的情况，不一定把数组中所有位子都用完了
        while(i<res.length&&res[i]==0)
            i++;
        StringBuilder sb=new StringBuilder();
        for(;i<res.length;i++)
            sb.append(res[i]);
        String s=sb.toString();
        return s.length()==0?"0":s;
    }
}
```

###### [基本计算器](https://leetcode.cn/problems/basic-calculator/)

实现计算器要考虑几个点

- 字符串怎么转数字-----》for循环转 如果不是运算符就一直num = 10 * num + (c-'0');
- 先考虑加减法，遇到加减法直接把该num加入栈
- 考虑乘除法，需要从栈中拿出一个数计算后放入栈
- 考虑括号，用递归来计算，每一个括号内部就是一个eva
- 考虑到用递归，所以用队列来存储字符串，这样每次传入就只有当前的了
- 遇到）的时候，对这种情况的判断要放到最后，因为这个属于是符号，所以要对前面所有的括号内的结果进行清算，不能提前break
- 本解法考虑的是遇到后面的运算符，就把前面的数字进行清算，所以用一个sign来记录前面的数字的符号 比如说6-2+2 最开始sign就是+，遇到c为-的时候就把+6传入栈，把sign改为-，遇到c为+，就把-2传入，sign改为+

```java
class Solution {
    public int calculate(String s) {
        Queue<Character> queue = new LinkedList<Character>();
        for(char c:s.toCharArray()){
            if(c!=' ')
                queue.add(c);
        }
        int res=eva(queue);
        return res;
    }

    public int eva(Queue<Character>queue){
        Stack<Integer>stack=new Stack<>();
        char sign='+';
        int num=0;
        while(!queue.isEmpty()){
            char c=queue.poll();
            if (Character.isDigit(c)) {
                num = 10 * num + (c-'0');
            }
            if(c=='(')
                num=eva(queue);
            if (!Character.isDigit(c)|| queue.isEmpty()) {
                if (sign == '+') {
                    stack.push(num);
                } else if (sign == '-') {
                    stack.push(-num);
                } else if (sign == '*') {
                    stack.push(stack.pop() * num);
                } else if (sign == '/') {
                    stack.push(stack.pop() / num);       
                }
                num = 0;
                sign = c;
            }
            if(c==')')
                break;
        }
        int res = 0;
        for (int i : stack) {
            res += i;
        }
        return res;

    }
}
```

###### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

和前面的柱状图求最大矩形是一样的

解法1️⃣：直接暴力搜索所有情况 超时

```java
class Solution {
    public int maxArea(int[] height) {
        int max=Integer.MIN_VALUE;
        for(int i=0;i<height.length-1;i++){
            for(int j=i+1;j<height.length;j++){
                int h=height[i]<height[j]?height[i]:height[j];
                int size=h*(j-i);
                if(size>max)
                    max=size;
            }
        }
        return max;
    }
}
```

解法2️⃣：

```java
class Solution {
    public int maxArea(int[] height) {
        int left=0;int right=height.length-1;
        int res=0;
        while(left<right){
            int size=Math.min(height[left],height[right])*(right-left);
            res=Math.max(res,size);
            if(height[left]<height[right])
                left++;
            else
                right--;
        }
        return res;
    }
}
```

###### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)

![image-20231229203109952](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231229203109952.png)

接雨水问题，可以考虑其实对于每一个可以接雨水的格子，其能接的雨水的量有两边最高点中的最低点决定，所以可以进行暴力求解

解法1️⃣：计算每个接水点的两边最高点求其接水的量，有一个用例超时

```java
class Solution {
    int trap(int[] height) {
        int n = height.length;
        int res = 0;
        for (int i = 1; i < n - 1; i++) {
            int l_max = 0, r_max = 0;
          	//求该位置右边最高点
            for (int j = i; j < n; j++)
                r_max = Math.max(r_max, height[j]);
            //求左边最高点
            for (int j = i; j >= 0; j--)
                l_max = Math.max(l_max, height[j]);
            //两个最高点的最小值就是高度
            res += Math.min(l_max, r_max) - height[i];
        }
        return res;
    }
}
```

解法2️⃣：用备忘录记录最高点，就不需要每次都再找一遍

```java
class Solution {
    int trap(int[] height) {
        int []l_max=new int[height.length];
        int []r_max=new int[height.length];
        l_max[0]=height[0];
        r_max[height.length-1]=height[height.length-1];
        for(int i=1;i<height.length;i++){
            l_max[i]=Math.max(l_max[i-1],height[i]);
        }
        for(int i=height.length-2;i>=0;i--){
            r_max[i]=Math.max(r_max[i+1],height[i]);
        }
        int res=0;
        for(int i=1;i<height.length-1;i++){
            res+=Math.min(l_max[i],r_max[i])-height[i];
        }
        return res;
    }
}
```

解法3️⃣：双指针

思路也是找两边的最大值，不过是边加边找，考虑的情况是这样的最开始有两个指针在数组的两端，所以它们分别有一端的最值是知道的，左指针的左边最大值是知道的，是自己，右指针的右边最大值也是知道的，将这两个最大值进行比较

比如说l_max更小，而此时的r_max都不一定是left位置右边的最大值，所以l_max一定是两边的最小值，所以就计算left的雨水，反之就计算right的雨水，再逐个往中间推进

这里值得注意的是while判断条件是left<right，因为按照这个逻辑走，最后left和right相聚的点一定是整个数组的最大点，所以不会存在雨水

```java
class Solution {
    int trap(int[] height) {
        int left=0;int right=height.length-1;
        int l_max=0;int r_max=0;
        int res=0;
        while(left<right){
            l_max=Math.max(l_max,height[left]);
            r_max=Math.max(r_max,height[right]);
            if(l_max<r_max){
                res+=l_max-height[left];
                left++;
            }
            else{
                res+=r_max-height[right];
                right--;
            }

        }
        return res;
    }
}
```

