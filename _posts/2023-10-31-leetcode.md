---
layout: post
title: "leetcode"
subtitle: "leetcode"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
  - java
---

##### 链表

###### [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1==null||list2==null){
            if(list1!=null)
                return list1;
            else
                return list2;
        }
        ListNode result=new ListNode(-1);
        ListNode temp=result;
        while(list1!=null&&list2!=null){
            if(list1.val>list2.val){
                temp.next=list2;
                temp=temp.next;
                list2=list2.next;
            }else{
                temp.next=list1;
                temp=temp.next;
                list1=list1.next;
            }
        }
        if(list1==null)
            temp.next=list2;
        else if(list2==null)
            temp.next=list1;
        return result.next;
    }
}
```

###### [分隔链表](https://leetcode.cn/problems/partition-list/)

思路 定义两个链表，一个存储小的，一个存储大于等于的，最后进行拼接

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode bigger=new ListNode(-1);
        ListNode biggertemp=bigger;
        ListNode smaller=new ListNode(-1);
        ListNode smallertemp=smaller;
        while(head!=null){
            if(head.val>=x){
                biggertemp.next=head;
                head=head.next;
                biggertemp=biggertemp.next;
            }else{
                smallertemp.next=head;
                head=head.next;
                smallertemp=smallertemp.next;
            }
        }
        biggertemp.next=null;
        smallertemp.next=bigger.next;
        return smaller.next;
    }
}
```

###### [ 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

解法1️⃣

思路：循环遍历，以第一个链表为标准，不断把后面的链表插入第一个链表中

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists==null||lists.length==0)
            return null;
        ListNode res=new ListNode(-1);
        res.next=lists[0];
        for(int i=1;i<lists.length;i++){
            ListNode p1=res;
            ListNode p2=lists[i];
            while(p1.next!=null&&p2!=null){
                if(p1.next.val<p2.val){
                    p1=p1.next;
                }else{
                    ListNode temp=p2.next;
                    p2.next=p1.next;
                    p1.next=p2;
                    p2=temp;
                    p1=p1.next;
                }
            }
            if(p2!=null){
                p1.next=p2;
            }
        }
        return res.next;
    }
}
```

解法2️⃣

思路：将数组中各个链表头节点加入有序队列中，然后定义一个新的链表加入其中最小的头节点，如果被加入的那个链表不为空，把它的下一个加入有序队列中，继续进行比较，知道队列为空

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0)
            return null;
        PriorityQueue<ListNode>queue=new PriorityQueue<>(
            lists.length,(a,b)->(a.val-b.val)
        );
        for(ListNode head:lists){
            if(head!=null)
                queue.add(head);
        }
        ListNode res=new ListNode(-1);
        ListNode temp=res;
        while(!queue.isEmpty()){
            ListNode node=queue.poll();
            temp.next=node;
            if(node.next!=null)
                queue.add(node.next);
            temp=temp.next;
        }
        return res.next;
    }
}
```

###### [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/SLwz0R/)

双链表，一个快指针，一个慢指针，让快指针先走n个，慢指针再走

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null)
            return null;
        int index=0;
        ListNode fast=new ListNode(-1);
        ListNode slow=new ListNode(-1);
        fast.next=head;
        slow.next=head;
        ListNode slowtemp=slow;
        while(fast.next!=null&&index<n){
            fast=fast.next;
            index++;
        }
        if(fast.next==null&&index<n){
            return null;
        }
        while(fast.next!=null){
            fast=fast.next;
            slowtemp=slowtemp.next;
        }
        slowtemp.next=slowtemp.next.next;
        return slow.next;
        
    }
}
```

###### [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

方法1️⃣

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode temp=head;
        int num=0;
        while(temp!=null){
            temp=temp.next;
            num++;
        }
        ListNode res=head;
        for(int i=0;i<num/2;i++){
            res=res.next;
        }
        return res;
    }
}
```

方法2️⃣

设置快指针

```java
ListNode middleNode(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
    }
    // 慢指针指向中点
    return slow;
}
```

###### [环形链表](https://leetcode.cn/problems/linked-list-cycle/)

思路：定义一个快指针和一个慢指针，如果两个能相遇，那就说明是环形

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)
                return true;
        }
        return false;
    }
}
```

###### [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

思路：**当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置**

原理：我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

![image-20231101175243112](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101175243112.png)

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

![image-20231101175916495](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101175916495.png)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)
                break;
        }
        if(fast==null||fast.next==null)
            return null;
        slow=head;
        while(fast!=slow){
            fast=fast.next;
            slow=slow.next;
        }
        return slow;

    }
}
```

###### [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

解法1️⃣

思路：将一个链表加入hashset中进行判断

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        HashSet<ListNode>hashset1=new HashSet<>();
        while(headA!=null){
            hashset1.add(headA);
            headA=headA.next;
        }
        while(headB!=null){
            if(hashset1.contains(headB))
                return headB;
            headB=headB.next;
        }
        return null;
    }
}
```

解法2️⃣

思路：将headA遍历完A之后遍历B，让headB遍历完B之后遍历A，这样如果两者能相遇就说明有交点，如果没有交点，那就都遍历完都为空，退出循环

![image-20231102160749946](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102160749946.png)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1=headA;
        ListNode p2=headB;
        while(p1!=p2){
            if(p1!=null)
                p1=p1.next;
            else
                p1=headB;
            if(p2!=null)
                p2=p2.next;
            else
                p2=headA;
        }
        return p1;
    }
}
```

###### [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode res=new ListNode(-1);
        while(head!=null){
            ListNode temp=head.next;
            head.next=res.next;
            res.next=head;
            head=temp;
        }
        return res.next;
    }
}
```

[反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

思路：temp是一个完全空的链表，然后通过for循环，在left之前逐个插入，在left-right之间倒叙插入，然后再将right之后的直接插入

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode res=new ListNode(-1);
        ListNode temp=res;
        for(int i=1;i<left;i++){
            temp.next=head;
            temp=temp.next;
            head=head.next;
        }
        ListNode node2=temp;
        for(int i=left;i<=right;i++){
            ListNode node=head.next;
            head.next=temp.next;
            temp.next=head;
            head=node;
        }
        for(int i=left;i<=right;i++)
            temp=temp.next;
        temp.next=head;
        return res.next;
    }
}
```

###### 递归反转链表

**反转链表**

```java
class Solution {
    public ListNode reverseList(ListNode head) {
    	if(head==null||head.next==null){
         return head;
       }
      ListNode last=reverseList(head.next);
      head.next.next=head;
      head.next=null;
      return last;
    }
}
```

使用递归进行求解，首先考虑的是reverseList这个函数的作用，那就是进行反转，那么将reverseList(head.next)之后，链表情况

![image-20231102165719950](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102165719950.png)

![image-20231102165707289](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102165707289.png)

所以在这之后，只需要将head加入链表即可

```java
    head.next.next = head;
    head.next = null;
```

这个之后last的反转之后的根节点，返回last即可

###### [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode res=new ListNode(-1,head);
        ListNode temp=res;
        while(true){
            ListNode last=temp;
            for(int i=0;i<k;i++){
                last=last.next;
                if(last==null){
                    return res.next;
                }
            }
            ListNode cur=temp.next,node;
            for(int i=0;i<k-1;i++){
                node=cur.next;
                cur.next=node.next;
                node.next=temp.next;
                temp.next=node;
            }
            temp=cur;
        }
    }
}
```

之前反转链表的时候，因为是将一个链表插到另一个链表上，可以采用插的方式是

```java
            ListNode node=head.next;
            head.next=temp.next;
            temp.next=head;
            head=node;
```

这样不会产生循环，如果在同一条链表上进行反转插值，这样会产生循环，因为没有对head的前一个指针进行指向的更改，所以对于同一条链表的反转可以使用下面的方式进行插值

```java
                node=cur.next;
                cur.next=node.next;
                node.next=temp.next;
                temp.next=node;
```

###### [回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

回文链表是指正序和逆序遍历链表得到的序列完全相同。也就是说，如果一个链表从头到尾和从尾到头遍历的节点值都一样，那么这个链表就是回文链表。

解法1️⃣

使用栈的方式

```java
class Solution {
    public Boolean isPalindrome(ListNode head) {
        Stack<Integer>stack=new Stack<>();
        ListNode temp=head;
        while(temp!=null){
            stack.push(temp.val);
            temp=temp.next;
        }
        while(head!=null){
            if(head.val!=stack.pop()){
                return false;
            }
            head=head.next;
        }
        return true;
    }
};
```

解法2️⃣

使用双链表的方式

```java
    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            // 空链表或只有一个节点时为回文链表
            return true;
        }
        // 遍历链表并将节点值存储在列表中
        List<Integer> values = new ArrayList<>();
        ListNode current = head;
        while (current != null) {
            values.add(current.val);
            current = current.next;
        }
        // 使用双指针进行比较
        int left = 0;
        int right = values.size() - 1;
        while (left < right) {
            if (!values.get(left).equals(values.get(right))) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
```

###### [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null)
            return null;
        ListNode slow=head,fast=head;
        while(fast!=null){
            if(fast.val!=slow.val){
                slow=slow.next;
                slow.val=fast.val;
            }
            fast=fast.next;
        }
        slow.next=null;
        return head;
    }
}
```

##### 数组

###### [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

设置快慢指针，快慢指针从0出发，快指针一直走，当遇到快慢指针值不同时，就要进行更新，让慢指针前进一步，然后更新慢指针所在位置的值

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0)
            return 0;
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[slow]!=nums[fast]){
                slow++;
                nums[slow]=nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
```

###### [移除元素](https://leetcode.cn/problems/remove-element/)

和上面的思路一样

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums.length==0){
            return 0;
        }
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[fast]!=val){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

###### [移动零](https://leetcode.cn/problems/move-zeroes/)

和上面的一个思路，只不过要在最后进行补0

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[fast]!=0){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        for(int i=slow;i<nums.length;i++)
            nums[i]=0;
        return;
    }
}
```

###### [删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

对于可以保存两个的这种情况，slow代表将要更新的位置，进行判断的是**slow-2和fast**

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0)
            return 0;
        int slow=2,fast=2;
        while (fast < nums.length) {
            if (nums[slow - 2] != nums[fast]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
}
```

