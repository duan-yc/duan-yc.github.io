---
layout: post
title: "leetcode"
subtitle: "leetcode"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
  - java
---

### 链表

##### 双指针

###### [分隔链表](https://leetcode.cn/problems/partition-list/)

思路 定义两个链表，一个存储小的，一个存储大于等于的，最后进行拼接

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode bigger=new ListNode(-1);
        ListNode biggertemp=bigger;
        ListNode smaller=new ListNode(-1);
        ListNode smallertemp=smaller;
        while(head!=null){
            if(head.val>=x){
                biggertemp.next=head;
                head=head.next;
                biggertemp=biggertemp.next;
            }else{
                smallertemp.next=head;
                head=head.next;
                smallertemp=smallertemp.next;
            }
        }
        biggertemp.next=null;
        smallertemp.next=bigger.next;
        return smaller.next;
    }
}
```

###### [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1==null||list2==null){
            if(list1!=null)
                return list1;
            else
                return list2;
        }
        ListNode result=new ListNode(-1);
        ListNode temp=result;
        while(list1!=null&&list2!=null){
            if(list1.val>list2.val){
                temp.next=list2;
                temp=temp.next;
                list2=list2.next;
            }else{
                temp.next=list1;
                temp=temp.next;
                list1=list1.next;
            }
        }
        if(list1==null)
            temp.next=list2;
        else if(list2==null)
            temp.next=list1;
        return result.next;
    }
}
```

###### [ 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

解法1️⃣

思路：循环遍历，以第一个链表为标准，不断把后面的链表插入第一个链表中

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists==null||lists.length==0)
            return null;
        ListNode res=new ListNode(-1);
        res.next=lists[0];
        for(int i=1;i<lists.length;i++){
            ListNode p1=res;
            ListNode p2=lists[i];
            while(p1.next!=null&&p2!=null){
                if(p1.next.val<p2.val){
                    p1=p1.next;
                }else{
                    ListNode temp=p2.next;
                    p2.next=p1.next;
                    p1.next=p2;
                    p2=temp;
                    p1=p1.next;
                }
            }
            if(p2!=null){
                p1.next=p2;
            }
        }
        return res.next;
    }
}
```

解法2️⃣

思路：将数组中各个链表头节点加入有序队列中，然后定义一个新的链表加入其中最小的头节点，如果被加入的那个链表不为空，把它的下一个加入有序队列中，继续进行比较，知道队列为空

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length==0)
            return null;
        PriorityQueue<ListNode>queue=new PriorityQueue<>(
            lists.length,(a,b)->(a.val-b.val)
        );
        for(ListNode head:lists){
            if(head!=null)
                queue.add(head);
        }
        ListNode res=new ListNode(-1);
        ListNode temp=res;
        while(!queue.isEmpty()){
            ListNode node=queue.poll();
            temp.next=node;
            if(node.next!=null)
                queue.add(node.next);
            temp=temp.next;
        }
        return res.next;
    }
}
```

###### [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/SLwz0R/)

双链表，一个快指针，一个慢指针，让快指针先走n个，慢指针再走

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null)
            return null;
        int index=0;
        ListNode fast=new ListNode(-1);
        ListNode slow=new ListNode(-1);
        fast.next=head;
        slow.next=head;
        ListNode slowtemp=slow;
        while(fast.next!=null&&index<n){
            fast=fast.next;
            index++;
        }
        if(fast.next==null&&index<n){
            return null;
        }
        while(fast.next!=null){
            fast=fast.next;
            slowtemp=slowtemp.next;
        }
        slowtemp.next=slowtemp.next.next;
        return slow.next;
        
    }
}
```

###### [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

方法1️⃣

直接首先while循环一遍计数，然后for循环

```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode temp=head;
        int num=0;
        while(temp!=null){
            temp=temp.next;
            num++;
        }
        ListNode res=head;
        for(int i=0;i<num/2;i++){
            res=res.next;
        }
        return res;
    }
}
```

方法2️⃣

设置快指针

```java
ListNode middleNode(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
    }
    // 慢指针指向中点
    return slow;
}
```

###### [环形链表](https://leetcode.cn/problems/linked-list-cycle/)

思路：定义一个快指针和一个慢指针，如果两个能相遇，那就说明是环形

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)
                return true;
        }
        return false;
    }
}
```

###### [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

思路：**当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置**

原理：我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

![image-20231101175243112](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101175243112.png)

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

![image-20231101175916495](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101175916495.png)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast=head;
        ListNode slow=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow)
                break;
        }
        if(fast==null||fast.next==null)
            return null;
        slow=head;
        while(fast!=slow){
            fast=fast.next;
            slow=slow.next;
        }
        return slow;

    }
}
```

###### [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

解法1️⃣

思路：将一个链表加入hashset中进行判断

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        HashSet<ListNode>hashset1=new HashSet<>();
        while(headA!=null){
            hashset1.add(headA);
            headA=headA.next;
        }
        while(headB!=null){
            if(hashset1.contains(headB))
                return headB;
            headB=headB.next;
        }
        return null;
    }
}
```

解法2️⃣

思路：将headA遍历完A之后遍历B，让headB遍历完B之后遍历A，这样如果两者能相遇就说明有交点，如果没有交点，那就都遍历完都为空，退出循环

![image-20231102160749946](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102160749946.png)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1=headA;
        ListNode p2=headB;
        while(p1!=p2){
            if(p1!=null)
                p1=p1.next;
            else
                p1=headB;
            if(p2!=null)
                p2=p2.next;
            else
                p2=headA;
        }
        return p1;
    }
}
```

###### [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if(head==null)
            return null;
        ListNode slow=head,fast=head;
        while(fast!=null){
            if(fast.val!=slow.val){
                slow=slow.next;
                slow.val=fast.val;
            }
            fast=fast.next;
        }
        slow.next=null;
        return head;
    }
}
```

##### 反转链表

###### [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode res=new ListNode(-1);
        while(head!=null){
            ListNode temp=head.next;
            head.next=res.next;
            res.next=head;
            head=temp;
        }
        return res.next;
    }
}
```

方法2️⃣：递归的方式

```java
class Solution {
    public ListNode reverseList(ListNode head) {
    	if(head==null||head.next==null){
         return head;
       }
      ListNode last=reverseList(head.next);
      head.next.next=head;
      head.next=null;
      return last;
    }
}
```

使用递归进行求解，首先考虑的是reverseList这个函数的作用，那就是进行反转，那么将reverseList(head.next)之后，链表情况

![image-20231102165719950](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102165719950.png)

![image-20231102165707289](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102165707289.png)

所以在这之后，只需要将head加入链表即可

```java
    head.next.next = head;
    head.next = null;
```

这个之后last的反转之后的根节点，返回last即可

###### [反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

思路：temp是一个完全空的链表，然后通过for循环，在left之前逐个插入，在left-right之间倒叙插入，然后再将right之后的直接插入

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode res=new ListNode(-1);
        ListNode temp=res;
        for(int i=1;i<left;i++){
            temp.next=head;
            temp=temp.next;
            head=head.next;
        }
        ListNode node2=temp;
        for(int i=left;i<=right;i++){
            ListNode node=head.next;
            head.next=temp.next;
            temp.next=head;
            head=node;
        }
        for(int i=left;i<=right;i++)
            temp=temp.next;
        temp.next=head;
        return res.next;
    }
}
```

###### [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode res=new ListNode(-1,head);
        ListNode temp=res;
        while(true){
            ListNode last=temp;
            for(int i=0;i<k;i++){
                last=last.next;
                if(last==null){
                    return res.next;
                }
            }
            ListNode cur=temp.next,node;
            for(int i=0;i<k-1;i++){
                node=cur.next;
                cur.next=node.next;
                node.next=temp.next;
                temp.next=node;
            }
            temp=cur;
        }
    }
}
```

之前反转链表的时候，因为是将一个链表插到另一个链表上，可以采用插的方式是

```java
            ListNode node=head.next;
            head.next=temp.next;
            temp.next=head;
            head=node;
```

这样不会产生循环，如果在同一条链表上进行反转插值，这样会产生循环，因为没有对head的前一个指针进行指向的更改，所以对于同一条链表的反转可以使用下面的方式进行插值

```java
                node=cur.next;
                cur.next=node.next;
                node.next=temp.next;
                temp.next=node;
```

##### 回文链表

###### [回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

回文链表是指正序和逆序遍历链表得到的序列完全相同。也就是说，如果一个链表从头到尾和从尾到头遍历的节点值都一样，那么这个链表就是回文链表。

解法1️⃣

使用栈的方式

```java
class Solution {
    public Boolean isPalindrome(ListNode head) {
        Stack<Integer>stack=new Stack<>();
        ListNode temp=head;
        while(temp!=null){
            stack.push(temp.val);
            temp=temp.next;
        }
        while(head!=null){
            if(head.val!=stack.pop()){
                return false;
            }
            head=head.next;
        }
        return true;
    }
};
```

解法2️⃣

使用双链表的方式

```java
    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            // 空链表或只有一个节点时为回文链表
            return true;
        }
        // 遍历链表并将节点值存储在列表中
        List<Integer> values = new ArrayList<>();
        ListNode current = head;
        while (current != null) {
            values.add(current.val);
            current = current.next;
        }
        // 使用双指针进行比较
        int left = 0;
        int right = values.size() - 1;
        while (left < right) {
            if (!values.get(left).equals(values.get(right))) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
```

### 数组

##### 双指针

###### [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

设置快慢指针，快慢指针从0出发，快指针一直走，当遇到快慢指针值不同时，就要进行更新，让慢指针前进一步，然后更新慢指针所在位置的值

前后指针

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0)
            return 0;
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[slow]!=nums[fast]){
                slow++;
                nums[slow]=nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
```

###### [移除元素](https://leetcode.cn/problems/remove-element/)

和上面的思路一样

前后指针

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        if(nums.length==0){
            return 0;
        }
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[fast]!=val){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

###### [移动零](https://leetcode.cn/problems/move-zeroes/)

和上面的一个思路，只不过要在最后进行补0

前后指针

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow=0,fast=0;
        while(fast<nums.length){
            if(nums[fast]!=0){
                nums[slow]=nums[fast];
                slow++;
            }
            fast++;
        }
        for(int i=slow;i<nums.length;i++)
            nums[i]=0;
        return;
    }
}
```

###### [删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

对于可以保存两个的这种情况，slow代表将要更新的位置，进行判断的是**slow-2和fast**

这个是先赋值，在slow++，是因为对于上一题来讲，两个指针都是从0开始的，所以slow代表只能是已经存在的位置，这个位置的点是这个值第一次出现，所以得slow先前进一格，再进行操作，对于这道题而言，因为是两个，所以从2开始出发的，这个时候slow代表的是重复值的下一个，这个时候就应该是赋新的值，再前进

前后指针

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0)
            return 0;
        int slow=2,fast=2;
        while (fast < nums.length) {
            if (nums[slow - 2] != nums[fast]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
}
```

###### [柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

使用单调栈的方式进行计算，往栈中加入的是序号，加入栈的规则是从数组中依次挑出数字，遇到当前值大于栈顶元素的，就加入，遇到当前值小于栈顶元素的，说明当前栈顶元素左右两边能计算的矩形的范围已经出来了，就把栈顶元素拿出来，计算面积

计算面积的步骤是拿出来的栈顶元素对应的高度为矩形高度，长度是**i-1-Stack.peek()**，Stack.peek()表示新的栈顶，这么计算的原因是防止这中间其实是有更高的被拿出去的，算长度的时候也要计算在内，这样的话就要在**最开始的时候加入-1进入栈**，因为考虑栈中正常的最后一个元素计算矩形面积的时候，如果不提前加入一个值，当pop出最后一个高度时，计算peek的时候，如果此时栈为空，就会报错，因此while的循环条件也必须是**Stack.size()>1**，因为后面那个判断条件，如果是不为0的话，heights[-1]也会报错，**右边需要多的一个值0**是用于最后把栈中所有元素都拿出来进行计算判断

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer>Stack=new Stack<>();
        int max=0;
        Stack.push(-1);
        for(int i=0;i<=heights.length;i++){
            int curHeight=i==heights.length?0:heights[i];
            while(Stack.size()>1&&curHeight<heights[Stack.peek()])            
            {
                int h=heights[Stack.pop()];
                int size=(i-1-Stack.peek())*h;
                max=Math.max(size,max);
            }
            Stack.push(i);
        }
        return max;
    }
}
```

###### [两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

解法1️⃣

这种解法有点像冒泡排序的方式

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int []res=new int[2];
        for(int i=0;i<numbers.length;i++){
            for(int j=i+1;j<numbers.length;j++){
                if(numbers[i]+numbers[j]==target){
                    res[0]=i+1;
                    res[1]=j+1;
                    return res;
                }
            }
        }
        return res;
    }
}
```

解法2️⃣

这种解法利用双指针，有点像二分查找的方式

左右指针

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int slow=0;int fast=numbers.length-1;
        int sum;
        while(slow!=fast){
            sum=numbers[slow]+numbers[fast];
            if(sum==target)
                return new int[]{slow+1,fast+1};
            else if(sum<target)
                slow++;
            else
                fast--;
        }
        return new int[]{-1,-1};
    }
}
```

###### [反转字符串](https://leetcode.cn/problems/reverse-string/)

左右指针

```java
class Solution {
    public void reverseString(char[] s) {
        if(s.length==0||s==null)
            return ;
        int slow=0;int fast=s.length-1;
        char temp;
        while(slow<fast){
            temp=s[fast];
            s[fast]=s[slow];
            s[slow]=temp;
            slow++;
            fast--;
        }
    }
}
```

###### [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

思路：使用for遍历的方式，for的每个i就是一个回文判断的出发点，从两边扩展看有没有，因为不知道该串是奇数还是偶数，所以就两个都进行查找，取最长长度

左右指针

```java
class Solution {
    public String longestPalindrome(String s) {
        String res="";
        for(int i=0;i<s.length();i++){
            String s1=judge(i,i,s);
            String s2=judge(i,i+1,s);
            res=res.length()>s1.length()?res:s1;
            res=res.length()>s2.length()?res:s2;
        }
        return res;
    }

    public String judge(int i,int j,String s){
        while(i>=0&&j<s.length()&&s.charAt(i)==s.charAt(j)){
            i--;
            j++;
        }
      	//取i+1是因为断开循环要么是越界，要么是不想等，所以当前的是不能要的
        return s.substring(i+1,j);
    }

}
```

##### 前缀

###### [ 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

可以使用双重for循环来做，不过时间复杂度高了，可以考虑利用前缀的思想，用相减的方式解决

![image-20231108153054765](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231108153054765.png)

```java
class NumMatrix {
    // 定义：preSum[i][j] 记录 matrix 中子矩阵 [0, 0, i-1, j-1] 的元素和
    private int[][] preSum;
    
    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) return;
        // 构造前缀和矩阵
        preSum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 计算每个矩阵 [0, 0, i, j] 的元素和
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
            }
        }
    }
    
    // 计算子矩阵 [x1, y1, x2, y2] 的元素和
    public int sumRegion(int x1, int y1, int x2, int y2) {
        // 目标矩阵之和由四个相邻矩阵运算获得
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
    }
}

```

##### 差分数组

利用差分数组的思想进行解决

查分数组应用场景：多次对数组中的一部分进行增值减值的操作，这个时候就可以使用差分数组，一般就是题目给定nums[ n ]3的时候 

差分数组的原理：差分数组中每一个值代表了原数组中i-1和i之间的差值，所以当对数组中一部分进行值的修改时，使用差分数组，只需要对差分数组那个范围的两边进行修改就行了，因为中间都加，对于差分数组来说等于没加

差分数组的基本框架：首先创建一个全为0的差分数组，然后根据题目中给的值对差分数组对应节点进行赋值，注意题目一般从1开始，所以差分数组添加的时候记得减1，返回原数组也只需要查分数组从0开始一直累加即可

###### [航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int []num=new int[n];
        for(int []booking:bookings){
            num[booking[0]-1]+=booking[2];
            if(booking[1]<n){
                num[booking[1]]-=booking[2];
            }
        }
        for(int i=1;i<n;i++){
            num[i]+=num[i-1];
        }
        return num;
    }
}
```

###### [拼车](https://leetcode.cn/problems/car-pooling/)

主要是考虑在什么位置进行添加和删除值，如果是从0开始就直接i和j+1，如果是从1开始就是i-1和j，如果在范围点的不要就要减1

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int[] nums=new int[1001];
        for(int[]trip:trips){
            nums[trip[1]]+=trip[0];
            nums[trip[2]]-=trip[0];
        }
        for(int i=1;i<=1000;i++){
            nums[i]+=nums[i-1];
        }
        for(int i=0;i<=1000;i++){
            if(nums[i]>capacity)
                return false;
        }
        return true;


    }
}
```

##### 花式遍历数组

###### [反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

解法1️⃣

将字符串使用trim和split方法转化成只有非空字符串的数组，然后加入栈中，然后再从栈中提取出来进行拼接，然后返回

```java
class Solution {
    public String reverseWords(String s) {
        Stack<String>stack=new Stack<>();
        String []ss=s.trim().split(" +");
        for(String word:ss){
            stack.push(word);
        }
        String res="";
        while(!stack.isEmpty()){
            res=res.concat(" ").concat(stack.pop());
        }
        return res.substring(1);
    }
}
```

解法2️⃣

```java
class Solution {
    public String reverseWords(String s) {
        List<String>wordlist=Arrays.asList(s.trim().split(" +"));
        Collections.reverse(wordlist);
        return String.join(" ",wordlist);
    }
}
```

###### [旋转图像](https://leetcode.cn/problems/rotate-image/)

顺时针九十度反转数组，可以想到先将矩阵按照对角线进行对称，再将每一行进行反转

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n=matrix.length;
      	//按照对角线进行对称
        for(int i=0;i<n;i++)
            for(int j=i;j<n;j++){
                int temp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=temp;
            }
      	//每一行进行反转
        for(int i=0;i<n;i++){
            reverse(matrix[i]);
        }
    }
    public void reverse(int []nums){
        int i=0;int j=nums.length-1;
      	//用while循环对一维数组进行反转
        while(i<j){
            int temp=nums[j];
            nums[j]=nums[i];
            nums[i]=temp;
            i++;j--;
        }
    }
}
```

同理也可以写逆时针反转矩阵

```java
// 将二维矩阵原地逆时针旋转 90 度
void rotate2(int[][] matrix) {
    int n = matrix.length;
    // 沿左下到右上的对角线镜像对称二维矩阵
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i; j++) {
            // swap(matrix[i][j], matrix[n-j-1][n-i-1])
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][n - i - 1];
            matrix[n - j - 1][n - i - 1] = temp;
        }
    }
    // 然后反转二维矩阵的每一行
    for (int[] row : matrix) {
        reverse(row);
    }
}

void reverse(int[] arr) { /* 见上文 */}

```

###### [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

螺旋遍历矩阵，可以想象为上右下左遍历矩阵，使用一个大的while循环，当list满就退出循环，在while循环里用4个if来进行遍历，就根据边界来进行判断，然后用for循环挨个把每个值加入list中

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m=matrix.length;int n=matrix[0].length;
        int upperbound=0;int buttonbound=m-1;
        int leftbound=0;int rightbound=n-1;
        ArrayList<Integer>list=new ArrayList<>();
        while(list.size()<m*n){
            if(upperbound<=buttonbound){
                for(int i=leftbound;i<=rightbound;i++){
                    list.add(matrix[upperbound][i]);
                }
                upperbound++;
            }
            if(leftbound<=rightbound){
                for(int i=upperbound;i<=buttonbound;i++){
                    list.add(matrix[i][rightbound]);
                }
                rightbound--;
            }
            if(upperbound<=buttonbound){
                for(int i=rightbound;i>=leftbound;i--){
                    list.add(matrix[buttonbound][i]);
                }
                buttonbound--;
            }
            if(leftbound<=rightbound){
                for(int i=buttonbound;i>=upperbound;i--){
                    list.add(matrix[i][leftbound]);
                }
                leftbound++;
            }
    }
    return list;
}}
```

###### [螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

和上题类似，只要按照螺旋的轨迹走一遍就行了

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int upper=0;int button=n-1;
        int left=0;int right=n-1;
        int count=1;
        int [][]res=new int[n][n];
        while(count<n*n+1){
            if(upper<=button){
                for(int i=left;i<=right;i++){
                    res[upper][i]=count++;                
                }
                upper++;
            }
            if(left<=right){
                for(int i=upper;i<=button;i++){
                    res[i][right]=count++;                
                }
                right--;
            }
            if(upper<=button){
                for(int i=right;i>=left;i--){
                    res[button][i]=count++;                
                }
                button--;
            }
            if(left<=right){
                for(int i=button;i>=upper;i--){
                    res[i][left]=count++;                
                }
                left++;
            }
        }
        return res;
    }
}
```

##### 滑动窗口

###### [最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

思路：

1、我们在字符串 `S` 中使用双指针中的左右指针技巧，初始化 `left = right = 0`，把索引**左闭右开**区间 `[left, right)` 称为一个「窗口」。

2、我们先不断地增加 `right` 指针扩大窗口 `[left, right)`，直到窗口中的字符串符合要求（包含了 `T` 中的所有字符）。

3、此时，我们停止增加 `right`，转而不断增加 `left` 指针缩小窗口 `[left, right)`，直到窗口中的字符串不再符合要求（不包含 `T` 中的所有字符了）。同时，每次增加 `left`，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right` 到达字符串 `S` 的尽头

**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

具体实施：

- 使用HashMap来存储每个字符出现的次数，need表示需要哪些字符，每个字符出现了多少次，window表示目前字符串中有哪些字符了，出现了多少次，两者的字符出现数量相等，就表示某字符匹配成功了，num++，当num的数量和need的大小相等时，说明匹配成功
- 使用getOrDefault(tt,0)+1方法对hashmap某一字符出现的次数进行更新
- 当匹配成功后就要进行优化，left进行++，这个时候每次也要进行判断left所在位置的那个字符是否存在与need中，如果存在就要对window中字符的数量进行修改，因为不要它了，并且在此之前还要判断window和need该字符的数量是否相等，如果相等说明去掉该字符之后，就不能匹配成功了，就需要num--

```java
class Solution {
    public String minWindow(String s, String t) {
        Map<Character,Integer>window=new HashMap<>();
        Map<Character,Integer>need=new HashMap<>();
        for(char tt:t.toCharArray()){
            need.put(tt,need.getOrDefault(tt,0)+1);
        }
        int start=0;int len=Integer.MAX_VALUE;
        int left=0;int right=0;
        int num=0;
        while(right<s.length()){
            char c=s.charAt(right);
            right++;
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c))){
                    num++;
                }
            }
            while(num==need.size()){
                if(right-left<len){
                    start=left;
                    len=right-left;
                }
                char d=s.charAt(left);
                left++;
                if(need.containsKey(d)){
                    if(need.get(d).equals(window.get(d))){
                        num--;
                    }
                    window.put(d,window.getOrDefault(d,0)-1);
                }
            }
        }
        return len==Integer.MAX_VALUE?"":s.substring(start,start+len);
    }
}
```

###### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

一样的使用滑动窗口，只不过这个计算长度的时候，在循环之后计算长度

```java
class Solution {
        public static int lengthOfLongestSubstring(String s) {
        Map<Character,Integer> window=new HashMap<>();
        int left=0;int right=0;
        int len=Integer.MIN_VALUE;
        while(right<s.length()){
            char c=s.charAt(right);
            right++;
            while(window.containsKey(c)){
                char d=s.charAt(left);
                left++;
                window.remove(d);
            }
            if(right-left>len){
                len=right-left;
            }
            window.put(c,1);
        }
        return len==Integer.MIN_VALUE?s.length():len;
    }
}
```

###### [字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        Map<Character,Integer>need=new HashMap<Character,Integer>();
        Map<Character,Integer>window=new HashMap<>();
        for(char c:s1.toCharArray()){
            need.put(c,need.getOrDefault(c,0)+1);
        }
        int left=0;int right=0;
        int num=0;
        while(right<s2.length()){
            char c=s2.charAt(right);
            right++;
            if(need.containsKey(c)){
                while(need.get(c).equals(window.get(c))){
                    char d=s2.charAt(left);
                    left++;
                    if(need.containsKey(d)){
                        if(need.get(d).equals(window.get(d)))
                            num--;
                        window.put(d,window.getOrDefault(d,0)-1);
                    }
                }
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c)))
                            num++;

            }else{
                window.clear();
                num=0;
                left=right;
            }
            if(num==need.size())
                return true;
        }
        return false;

    }
}
```

###### [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        Map<Character,Integer>need=new HashMap<>();
        Map<Character,Integer>window=new HashMap<>();
        for(char c:p.toCharArray()){
            need.put(c,need.getOrDefault(c,0)+1);
        }
        int left=0;int right=0;
        int num=0;
        List <Integer>res=new ArrayList<>();
        while(right<s.length()){
            char c=s.charAt(right);
            right++;
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(need.get(c).equals(window.get(c))){
                    num++;
                }
            }
            while(right-left>=p.length()){
                if(num==need.size()){
                    res.add(left);
                }
                char ss=s.charAt(left);
                left++;
                if(need.containsKey(ss)){
                    if(need.get(ss).equals(window.get(ss)))
                        num--;
                    window.put(ss,window.getOrDefault(ss,0)-1);
                }
            }
        }
        return res;
    }
}
```

##### 二分查找

###### [二分查找](https://leetcode.cn/problems/binary-search/)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(target==nums[mid])
                return mid;
            else if(target>nums[mid])
                left=mid+1;
            else
                right=mid-1;
        }
        return -1;
    }
}
```

###### [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

用二分查找的通用框架，使用两次，找到左边界和右边界

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        return new int[]{first(nums,target),last(nums,target)};
    }

    public int first(int []nums,int target){
        int left=0;int right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target)
                left=mid+1;
            else if(nums[mid]>target)
                right=mid-1;
            else
                right=mid-1;
        }
        if(left>=nums.length)
            return -1;
        return nums[left]==target?left:-1;
    }
    public int last(int []nums,int target){
        int left=0;int right=nums.length-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target)
                left=mid+1;
            else if(nums[mid]>target)
                right=mid-1;
            else
                left=mid+1;
        }
        if(right<0)
            return -1;
        return nums[right]==target?right:-1;
    }
}
```

##### 田忌赛马

###### [优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)

类似于田忌赛马，思路是首先对两个数组进行排序，不过对于num2来说，不能改变序列位置，不然就没有意义了，所以定义了一个对象，把他每个值进行排序，但又记录了每个值在原数组的位置，然后直接对num1数组进行排序，比较的时候，挨个取出队列中的值，因为是从大到小进行排序，也从大拿出num1的数组进行判断，如果num1的大，说明可以赢就直接讲num1该位置的值存储在新数组中num2的值对应的位置，如果更小，那就从num2中提取当前最小值进行添加，知道num1的值全部匹配完

```java
class Solution {
    int[] advantageCount(int[] nums1, int[] nums2) {
        PriorityQueue<int []>queue=new PriorityQueue<>(
            (int []p1,int []p2)->{
                return p2[1]-p1[1];
            }
        );
        for(int i=0;i<nums2.length;i++){
            queue.offer(new int[]{i,nums2[i]});
        }
        Arrays.sort(nums1);
        int []res=new int[nums1.length];
        int left=0;int right=nums1.length-1;
        while(!queue.isEmpty()){
            int []p=queue.poll();
            int i=p[0];int num=p[1];
            if(num<nums1[right]){
                res[i]=nums1[right];
                right--;
            }else{
                res[i]=nums1[left];
                left++;
            }
        }
        return res;
    }

}
```

### 二叉树

###### [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        int left=maxDepth(root.left);
        int right=maxDepth(root.right);
        int res=Math.max(left,right)+1;
        return res;
    }
}
```

###### [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

思路：直径的长度其实是等于一个节点的左右子树深度之和，所以利用在求每个节点的最大深度时，进行不断的判断，就能找到最长直径了

```java
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans=0;
        depth(root);
        return ans;
    }
    public int depth(TreeNode node){
        if(node==null)
            return 0;
        int left=depth(node.left);
        int right=depth(node.right);
        ans=Math.max(ans,left+right);
        return Math.max(left,right)+1;
    }
}
```

###### [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

```java
class Solution {
    List <TreeNode>list=new ArrayList<TreeNode>();
    public void flatten(TreeNode root) {
        pre(root);
        TreeNode temp=root;
        for(int i=1;i<list.size();i++){
            temp.right=list.get(i);
            temp.left=null;
            temp=temp.right;
        }
    }
    public void pre(TreeNode node){
        if(node==null)
            return;
        list.add(node);
        pre(node.left);
        pre(node.right);
    }
}
```

###### [填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

使用bfs

```java
class Solution {
    public Node connect(Node root) {
        if(root==null){
            return null;
        }
        Queue<Node>queue=new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            int size=queue.size();
            for(int i=0;i<size;i++){
                Node node=queue.poll();
                if(i<size-1){
                    node.next=queue.peek();
                }
                if(node.left!=null)
                    queue.add(node.left);
                if(node.right!=null)
                    queue.add(node.right);
            }
            
        }
        return root;
    }
}
```

dfs

```java
class Solution {
    public Node connect(Node root) {
        if(root==null){
            return null;
        }
        add(root.left,root.right);
        return root;
    }
    public void add(Node node,Node node2){
        if(node==null)
            return;
        node.next=node2;
        add(node.left,node.right);
        add(node2.left,node2.right);
        add(node.right,node2.left);
    }
}
```

###### [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        TreeNode root=build(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
        return root;
    }
    public TreeNode build(int []preorder,int pl,int pr,int []inorder,int il,int ir){
        if(pl>pr)
            return null;
        int tar=preorder[pl];
        int index=0;
        for(int i=il;i<=ir;i++){
            if(inorder[i]==tar){
                index=i;
                break;
            }
        }
        int size=index-il;
        TreeNode node=new TreeNode(tar);
        node.left=build(preorder,pl+1,pl+size,inorder,il,index-1);
        node.right=build(preorder,pl+size+1,pr,inorder,index+1,ir);
        return node;
    }
}
```

###### [最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if(nums.length==0)
            return null;
        TreeNode node=build(nums,0,nums.length-1);
        return node;
    }
    public TreeNode build(int []nums,int left,int right){
        if(left>right)
            return null;
        int max=-1;
        int index=0;
        for(int i=left;i<=right;i++){
            if(nums[i]>max){
                max=nums[i];
                index=i;
            }
        }
        TreeNode root=new TreeNode(max);
        root.left=build(nums,left,index-1);
        root.right=build(nums,index+1,right);
        return root;
    }
}
```

###### [从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)

二叉搜索树用的中序遍历

```java
class Solution {
    public TreeNode bstToGst(TreeNode root) {
        add(root);
        return root;
    }
    int res=0;
    public void add(TreeNode node){
        if(node==null)
            return;
        add(node.right);
        res+=node.val;
        node.val=res;
        add(node.left);
    }
}
```

###### [二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

和上一题一样的思路，只不过是正向的

```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        search(root,k);
        return res;
    }
    int res;
    int rank=0;
    public void search(TreeNode node,int k){
        if(node==null)
            return;
        search(node.left,k);
        rank++;
        if(k==rank){
            res=node.val;
            return;
        }
        search(node.right,k);

    }
}
```

###### [把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        sum(root);
        return root;
    }
    int res;
    public void sum(TreeNode node){
        if(node ==null)
            return;
        sum(node.right);
        res+=node.val;
        node.val=res;
        sum(node.left);
    }
}
```

###### [完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null)
            return 0;
        return 1+countNodes(root.left)+countNodes(root.right);
    }
}
```

### 图

##### dfs

###### [所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

使用dfs的方式进行遍历图，因为不会成环所以不需要visit数组，因为要所有路径，所以在外面定义一个二维数组，当条件匹配的时候就把一维数组加入二维数组，并且去掉一维数组的最后一个元素，继续进行其他的dfs遍历，并且由于传递的是数组，是引用变量，所以每次加入res数组的时候要创建一个新的数组加进去，不然加到res里的path数组的值也会一直变化，最后都会为0

```java
class Solution {
    LinkedList<List<Integer>>res=new LinkedList<>();
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        LinkedList<Integer>path=new LinkedList<>();
        dfs(graph,path,0);
        return res;
    }
    public void dfs(int [][]graph,LinkedList<Integer>path,int k){
        path.add(k);
        if(k==graph.length-1){
            res.add(new LinkedList<>(path));
            path.removeLast();
            return;
        }
        for(Integer n:graph[k]){
            dfs(graph,path,n);
        }
        path.removeLast();
    }
}
```

##### 拓扑排序

###### [课程表](https://leetcode.cn/problems/course-schedule/)

采用dfs的方式进行求解，首先是初始化各个数组list，然后进行建图，然后以每个节点作为根节点进行遍历

对于无向的图的话，找是否有循环，首先想到的是union+parent，对于有向的图的话，可以直接用dfs+onpath进行判断，onpath是一个数组，代表了当前的遍历路径上还在路径上的节点，因为每遍历完一个节点，要返回的时候，就会把它的onpath[x]设置为0，代表了已经剔除路径，这样的话每次进行一个新的dfs的时候只需要判断onpath，如果为1，那说明当前路径上有该节点，那说明成环了。

所以判断是否有环就可以用这种方式，遍历该点之前设置为true，遍历之后设置为false

```java
class Solution {
    int []visited;
    int []onpath;
  	//定义一个成员变量，如果circle变为true，那说明有环，最后也是返回！circle
    boolean circle=false;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        LinkedList<Integer>[]graph=new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        visited=new int[numCourses];
      	//建图
        for(int i=0;i<prerequisites.length;i++){
            graph[prerequisites[i][1]].add(prerequisites[i][0]);
        }
        onpath=new int[numCourses];
      	//对每个节点作为根节点进行遍历
        for(int i=0;i<numCourses;i++){
            dfs(graph,i);
        }
        return !circle;

    }
    public void dfs(LinkedList<Integer>[]graph,int s){
      	//在路径上，说明有环
        if(onpath[s]==1){
            circle=true;
        }
      	//visited表示可能之前其他节点作为根节点的时候，已经遍历过该点了 那么就不需要再遍历了
      	//circle如果有循环了也不需要遍历了
        if(visited[s]==1||circle){
            return;
        }
        onpath[s]=1;
        visited[s]=1;
        for(int t:graph[s]){
            dfs(graph,t);
        }
        onpath[s]=0;
    }
}
```

###### [课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

和上一题的区别是要给一个顺序，这个顺序是在进行dfs遍历的时候的后序提取然后再反转即可，使用先序是不行的，先序根据顺序有可能会让子节点跑到前面去。

```java
class Solution {
    int []visited;
    int []onpath;
    boolean circle=false;
    LinkedList<Integer>list=new LinkedList<>();
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        LinkedList<Integer>[]graph=new LinkedList[numCourses];
        for(int i=0;i<numCourses;i++){
            graph[i]=new LinkedList<>();
        }
        for(int i=0;i<prerequisites.length;i++){
            graph[prerequisites[i][1]].add(prerequisites[i][0]);
        }
        visited=new int[numCourses];
        onpath=new int[numCourses];
        for(int i=0;i<numCourses;i++){
            dfs(graph,i);
        }
        if(circle==true)
            return new int[]{};
        Collections.reverse(list);
        int[] res = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            res[i] = list.get(i);
        }
        return res;

    }
    public void dfs(LinkedList<Integer>[]graph,int s){
        if(onpath[s]==1){
            circle=true;
        }
        if(visited[s]==1||circle){
            return;
        }
        visited[s]=1;
        onpath[s]=1;
        for(int t:graph[s]){
            dfs(graph,t);
        }
        list.add(s);
        onpath[s]=0;
    }
}
```

方法2️⃣：

使用bfs的方式，即考虑出度入度的关系，把这个想成一个图，从入度为0的点开始去除，去除之后他的子节点的入度就会减1，如果不存在循环，那么所有的点都能消掉，一个会遍历numCourses次，如果存在循环，那么在收集入度为0的点时，循环内的点都不满足条件，那么就不会加入队列，就会少遍历几次，所以最后只需要判断遍历的次数是否和numCourses相等就可以找到是否有环。对于顺序，遍历的顺序就是拓扑排序的顺序。

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Queue<Integer>queue=new LinkedList<>();
        LinkedList<Integer>graph[]=new LinkedList[numCourses];
        int []in=new int[numCourses];
        for(int i=0;i<numCourses;i++){
            graph[i]=new LinkedList<>();
        }
        for(int []num:prerequisites){
            graph[num[1]].add(num[0]);
            in[num[0]]++;
        }
        for(int i=0;i<numCourses;i++){
            if(in[i]==0)
                queue.add(i);
        }
        int count=0;
        int []res=new int[numCourses]; 
        while(!queue.isEmpty()){
            int point=queue.poll();
            res[count]=point;
            count++;
            for(int x:graph[point]){
                in[x]--;
                if(in[x]==0)
                    queue.add(x);
            }
        }
        if(count==numCourses)
            return res;
        return new int[]{};
    }
}
```

##### 二分图

###### [ 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

判断是否是二分图，用dfs来进行判断，首先创建两个数组，一个visited，一个color数组，因为不一定所有节点都连接，所以要用for循环把所有点都dfs一遍，对于dfs里面，首先进行判断是否已经不是二分图了，如果已经不是了就直接返回了，否则遍历v点的所有连接点，首先判断这个点是否是访问过的，如果访问过的就判断这两个点颜色是否相同，如果没有访问过就将这个点设置为已访问，并且颜色设置为相反颜色，然后dfs该点。

```java
class Solution {
    boolean []visited;
    boolean []color;
    boolean res=true;
    public boolean isBipartite(int[][] graph) {
        int n=graph.length;
        visited=new boolean[n];
        color=new boolean[n];
        for(int i=0;i<n;i++){
            dfs(graph,i);
        }
        return res;

    }
    public void dfs(int [][]graph,int v){
        if(!res)
            return;
        for(int u:graph[v]){
            if(visited[u]){
                if(color[u]==color[v]){
                    res=false;
                    return;
                }
            }else{
                visited[u]=true;
                color[u]=!color[v];
                dfs(graph,u);
            }
        }
    }
}
```

###### [可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

和上题一样的思路，区别在于输入数组不同，这个需要自己建邻序表

```java
class Solution {
    boolean []visited;
    boolean []color;
    boolean res=true;
    public boolean possibleBipartition(int n, int[][] dislikes) {
        LinkedList<Integer>[]graph=new LinkedList[n+1];
        visited=new boolean[n+1];
        color=new boolean[n+1];
        for(int i=0;i<=n;i++){
            graph[i]=new LinkedList<>();
        }
        for(int []num:dislikes){
            graph[num[0]].add(num[1]);
            graph[num[1]].add(num[0]);
        }
        for(int i=1;i<=n;i++){
            dfs(graph,i);
        }
        return res;
    }
    public void dfs(LinkedList<Integer>[]graph,int v){
        if(!res)
            return;
        for(int u:graph[v]){
            if(visited[u]){
                if(color[u]==color[v]){
                    res=false;
                    return;
                }
            }else{
                visited[u]=true;
                color[u]=!color[v];
                dfs(graph,u);
            }
        }
    }
}
```

##### 岛屿问题

###### [被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

这题属于岛屿问题，思路是先用 for 循环遍历棋盘的**四边**，用 DFS 算法把那些与边界相连的 `O` 换成一个特殊字符，比如 `#`；然后再遍历整个棋盘，把剩下的 `O` 换成 `X`，把 `#` 恢复成 `O`。这样就能完成题目的要求，时间复杂度 O(MN)。

这道题有个点在于dfs的判断条件中不能用board[ x ] [ y ]=='X'来进行判断，因为考虑到一种情况，当前面进行遍历的时候，把周围的O变成了A，如果用这个判断条件的话就会对变成A的点继续遍历，这样的话就是遍历就不会结束，会一直遍历下去，所以要用board[ x ] [ y ]!='O'，或者加个visited数组

```java
class Solution {
    public void solve(char[][] board) {
        int m=board.length;
        int n=board[0].length;
        for(int i=0;i<m;i++){
            dfs(board,i,0);
            dfs(board,i,n-1);
        }
        for(int i=0;i<n;i++){
            dfs(board,0,i);
            dfs(board,m-1,i);
        }
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]=='O'){
                    board[i][j]='X';
                }else if(board[i][j]=='A')
                    board[i][j]='O';
            }
        }
    }
    public void dfs(char [][]board,int x,int y){
        if(x<0||x>=board.length||y<0||y>=board[0].length||board[x][y]!='O')
            return;
        board[x][y]='A';
        dfs(board,x+1,y);
        dfs(board,x-1,y);
        dfs(board,x,y+1);
        dfs(board,x,y-1);
    }

}
```

##### 并查集

###### [等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

这里的find使用的是递归的方式进行，这样的好处是能够把这个树的高度变为1，提高查询效率，这道题因为不知道字母的数量，所以parent数组直接是设置的26，不需要传递类型为char类型，只需要在传递之间减一个‘a’即可

```java
class Solution {
    int []parent=new int[26] ;
    public int find(int x){
        if(parent[x]!=x)
            parent[x]=find(parent[x]);
        return parent[x];
    }
    public void union(int x,int y){
        int xp=find(x);
        int yp=find(y);
        if(xp==yp)
            return;
        parent[xp]=yp;
    }
    public boolean equationsPossible(String[] equations) {
        for(int i=0;i<26;i++)
            parent[i]=i;
        for(String s:equations){
            if(s.charAt(1)=='='){
                int x=s.charAt(0)-'a';
                int y=s.charAt(3)-'a';
                union(x,y);
            }
        }
        boolean flag=true;
        for(String s:equations){
            if(s.charAt(1)=='!'){
                int x=find(s.charAt(0)-'a');
                int y=find(s.charAt(3)-'a');
                if(x==y){
                    flag=false;
                    break;
                }
            }
        }
        return flag;
    }
}
```

##### 最小生成树

###### [连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

使用克鲁斯卡尔法求最小生成树

```java
class Solution {
    int []parent;
    public void union(int x,int y){
        int xp=find(x);
        int yp=find(y);
        if(xp==yp)
            return;
        parent[xp]=yp;
    }

    public int find(int x){
        if(parent[x]!=x)
            parent[x]=find(parent[x]);
        return parent[x];
    }
    
    public int dist(int []x,int []y){
        return Math.abs(x[0]-y[0])+Math.abs(x[1]-y[1]);
    }

    public int minCostConnectPoints(int[][] points) {
        int v=points.length;
        parent=new int[v];
        for(int i=0;i<v;i++)
            parent[i]=i;
        int res=0;
        int count=0;
        while(count<v-1){
            int min=Integer.MAX_VALUE;
            int from=-1;int to=-1;
            for(int i=0;i<v;i++)
                for(int j=0;j<v;j++){
                    if(dist(points[i],points[j])<min&&find(i)!=find(j)){
                        from=i;
                        to=j;
                        min=dist(points[i],points[j]);
                    }
                }
            if(from!=-1&&to!=-1){
                count++;
                res+=min;
                union(from,to);
            }
        }
        return res;
    }
}
```

##### Dijkstra

###### [概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/)

方法1️⃣：使用bfs的思路，逐渐更新起始点的邻接点，使用邻接列表➕队列的方式，由于不像之前的树权重都是1，不需要管权重，这个是有权重的，所以要单独定义一个类，来记录权重

其中由于是到某个点的最小距离，也可以用if进行判断，到了那个点就可以返回，不过考虑写一个模版，所以没有加

```java
import java.util.*;

class Edge {
    int to;
    double dist;
    Edge(int to,double dist){
        this.to=to;
        this.dist=dist;
    }
}

class Solution {
    LinkedList<Edge>[]graph;
    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {
        graph=new LinkedList[n];
        for(int i=0;i<n;i++)
            graph[i]=new LinkedList<>();
        build(edges,succProb);
        double []dist=dijsktra(n,start_node);
        if(dist[end_node]!=-1)
            return dist[end_node];
        return 0;

    }
    public double[]dijsktra(int n,int start_node){
        double[]dist=new double[n];
        Arrays.fill(dist,-1);
        dist[start_node]=1;
        Queue<Edge>queue=new LinkedList<>();
        queue.add(new Edge(start_node,1));
        while(!queue.isEmpty()){
            Edge edge=queue.poll();
            int to=edge.to;
            for(Edge edge1:graph[to]){
                int edge_to=edge1.to;
                double edge_dist=dist[to]*edge1.dist;
                if(edge_dist>dist[edge_to]){
                    dist[edge_to]=edge_dist;
                    queue.add(new Edge(edge_to,dist[edge_to]));
                }
            }
        }
        return dist;
    }
    public void build(int [][]edges,double[]succProb){
        int count=0;
        for(int []edge:edges){
            graph[edge[0]].add(new Edge(edge[1],succProb[count]));
            graph[edge[1]].add(new Edge(edge[0],succProb[count]));
            count++;
        }
    }
}
```

方法2️⃣：使用邻接矩阵的方式来存储，好处是就不需要单独定义一个类来存储权重，坏处是这样的话需要定义一个很大的邻接矩阵，会造成空间上的浪费，在leetcode上会超出内存限制

```java
class Solution {
    double [][]graph;
    public double maxProbability(int n, int[][] edges, double[] succProb, int start_node, int end_node) {
        graph=new double[n][n];
        build(edges,succProb);
        double []dist=dijsk(n,start_node);
        if(dist[end_node]!=Integer.MIN_VALUE){
            return dist[end_node];
        }
        return 0;
    }
    public double[] dijsk(int n,int start_node){
        double dist[]=new double[n];
        boolean []visited=new boolean[n];
        Arrays.fill(dist,Integer.MIN_VALUE);
        dist[start_node]=1;
        for(int i=0;i<n-1;i++){
            int index=findMax(dist,visited);
            if(index==-1)
                break;
            visited[index]=true;
            for(int j=0;j<n;j++){
                if(graph[index][j]!=0&&dist[index]>0&&!visited[j]&&dist[index]*graph[index][j]>dist[j]){
                    dist[j]=dist[index]*graph[index][j];
                }
            }
        }
        return dist;
    }

    public int findMax(double []dist,boolean []visited){
        double max=Integer.MIN_VALUE;
        int index=0;
        for(int i=0;i<dist.length;i++){
            if(!visited[i]&&dist[i]>max){
                index=i;
                max=dist[i];
            }
        }
        return index;
    }
    public void build(int [][]edges,double[]succProb){
        int count=0;
        for(int []edge:edges){
            graph[edge[0]][edge[1]]=succProb[count];
            graph[edge[1]][edge[0]]=succProb[count];
            count++;
        }
    }
}
```

###### [最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)

需要用有序队列

```java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

class location{
    int x;
    int y;
    int dist;
    location(int x,int y,int dist){
        this.x=x;
        this.y=y;
        this.dist=dist;
    }
}

class Solution {
    static int [][]position={{0,1},{0,-1},{1,0},{-1,0}};
    static int [][]res;

    public static int minimumEffortPath(int[][] heights) {
        int res=dijsktra(heights);
        return res;
    }

    public static int dijsktra(int [][]heights){
        int m=heights.length;
        int n=heights[0].length;
        PriorityQueue<location> queue=new PriorityQueue<>((a,b)->{
            return a.dist-b.dist;
        });
        res= new int[m][n];
        for (int[] row : res) {
            Arrays.fill(row, Integer.MAX_VALUE);
        }
        res[0][0]=0;
        queue.add(new location(0,0,0));
        while(!queue.isEmpty()){
            location l=queue.poll();
            int lx=l.x;
            int ly=l.y;
            int d=l.dist;
            if(lx==m-1&&ly==n-1){
                break;
            }
            for(int i=0;i<4;i++){
                if((lx+position[i][0])>=0&&(lx+position[i][0])<m&&(ly+position[i][1])>=0&&(ly+position[i][1])<n){
                    int x=Math.max(Math.abs(heights[lx+position[i][0]][ly+position[i][1]]-heights[lx][ly]),res[lx][ly]);
                    if(x<res[lx+position[i][0]][ly+position[i][1]]){
                        res[lx+position[i][0]][ly+position[i][1]]=x;
                        queue.add(new location(lx+position[i][0],ly+position[i][1],res[lx+position[i][0]][ly+position[i][1]]));
                    }
                }
            }
        }
        return res[m-1][n-1];
    }
}
```

###### [ 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

用一样的思路

```java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.PriorityQueue;

class Edge{
    int to;
    int dist;
    Edge(int to,int dist){
        this.to=to;
        this.dist=dist;
    }
}

class Solution {

    LinkedList<Edge>[]graph;
    public int networkDelayTime(int[][] times, int n, int k) {
        graph=new LinkedList[n+1];
        for(int i=0;i<=n;i++)
            graph[i]=new LinkedList<>();
        build(times);
        int []res=dijkstra(k,n);
        int max=0;
        for(int i=1;i<res.length;i++){
            if(max<res[i])
                max=res[i];
            if(res[i]==Integer.MAX_VALUE)
                return -1;
        }
        return max;
    }

    public int[] dijkstra(int k,int n){
        int []res=new int[n+1];
        Arrays.fill(res,Integer.MAX_VALUE);
        res[k]=0;
        PriorityQueue<Edge> queue=new PriorityQueue<>((a, b)->{
            return a.dist-b.dist;
        });
        queue.add(new Edge(k,0));
        while(!queue.isEmpty()){
            Edge edge=queue.poll();
            int curto=edge.to;
            int curdist=edge.dist;
            if(curdist<res[curto])
                continue;
            for(Edge edge1:graph[curto]){
                int next_to=edge1.to;
                int next_dist=edge1.dist;
                if(next_dist+res[curto]<res[next_to]){
                    res[next_to]=next_dist+res[curto];
                    queue.add(new Edge(next_to,res[next_to]));
                }
            }
        }
        return res;
    }

    public void build(int [][]times){
        for(int []time:times){
            int from=time[0];
            int to=time[1];
            int dist=time[2];
            graph[from].add(new Edge(to,dist));
        }
    }
}
```

### 动态规划

重叠子问题、最优子结构、状态转移方程就是动态规划三要素

**要符合「最优子结构」，子问题间必须互相独立**。

###### [ 零钱兑换](https://leetcode.cn/problems/coin-change/)

自底向上的消除，设置max是amount + 1，而不是MAX_VALUE是因为怕dp[i - coins[j]] + 1越界

```java
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int max=amount+1;
        int []dp=new int[amount+1];
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        for(int i=1;i<=amount;i++){
            for(int coin:coins){
                if(i<coin)
                    continue;
                dp[i]=Math.min(dp[i],dp[i-coin]+1);
            }
        }
        return dp[amount]==amount+1?-1:dp[amount];
    }
}
```

##### 最长递增子序列

###### [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

这道题思路比较简单，状态方程就是找到当前节点之前所有比他小的节点，比较这些点的长度。dp[i]=Math.max(dp[i],dp[j]+1)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n=nums.length;
        int []dp=new int[n];
        Arrays.fill(dp,1);
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
        }
        int max=Integer.MIN_VALUE;
        for(int res:dp)
            if(max<res)
                max=res;
        return max;
    }
}
```

###### [俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)

思路是：首先对信封的宽度进行升序排序，如果宽度相同的信封就使用降序排序，这样只需要对信封的高度进行最长递增子序列的动态规划即可

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        int n=envelopes.length;
        Arrays.sort(envelopes, new Comparator<int[]>() 
        {
            public int compare(int[] a, int[] b) {
                return a[0] == b[0] ? 
                    b[1] - a[1] : a[0] - b[0];
            }
        });
        int []heights=new int[n];
        for(int i=0;i<n;i++){
            heights[i]=envelopes[i][1];
        }
        return dp_array(heights);

    }

    public int dp_array(int[]heights){
        int n=heights.length;
        int []dp=new int[n];
        Arrays.fill(dp,1);
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                if(heights[j]<heights[i]){
                    dp[i]=Math.max(dp[i],dp[j]+1);
                }
            }
        }
        int max=-1;
        for(int i=0;i<n;i++){
            if(max<dp[i])
                max=dp[i];
        }
        return max;
    }
}
```

###### [下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)

类似于背包问题，dp数组中后面的值由上一行的三个dp值的最小值和该值的和，注意判断越界

```java
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int n=matrix.length;
        int [][]dp=new int[n][n];
        for(int i=0;i<n;i++)
            dp[0][i]=matrix[0][i];
        for(int i=1;i<n;i++){
            for(int j=0;j<n;j++){
                int l_value=j==0?Integer.MAX_VALUE:dp[i-1][j-1];
                int m_value=dp[i-1][j];
                int r_value=j==n-1?Integer.MAX_VALUE:dp[i-1][j+1];
                dp[i][j]=Math.min(Math.min(l_value,m_value),r_value)+matrix[i][j];
            }
        }
        int res=Integer.MAX_VALUE;
        for(int i=0;i<n;i++){
            if(res>dp[n-1][i])
                res=dp[n-1][i];
        }
        return res;
    }
}
```

##### 前缀问题

###### [单词拆分](https://leetcode.cn/problems/word-break/)

思路就是深度遍历，从s的0的位置开始，for循环，判断前len部分是不是wordDict中的，如果是就dfs遍历他的下一部分，要是没有的话循环结束就会返回false

```java
class Solution {
    //-1表示未处理，0表示处理为通过，1表示处理通过
    int []visited;
    HashSet<String>Dict;
    public boolean wordBreak(String s, List<String> wordDict) {
        int n=s.length();
        visited=new int[n];
        Arrays.fill(visited,-1);
        Dict=new HashSet<>(wordDict);
        return dp(s,0);
    }
    public boolean dp(String s,int i){
        if(i==s.length())
            return true;
        if(visited[i]!=-1){
            return visited[i]==0?false:true;
        }
        for(int len=1;len+i<=s.length();len++){
            String prix=s.substring(i,i+len);
            if(Dict.contains(prix)){
                boolean flag=dp(s,i+len);
                if(flag==true){
                    visited[i]=1;
                    return true;
                }
            }
        }
        visited[i]=0;
        return false;
    }
}
```

###### [单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

和上一题一样的思路，只不过需要使用一个res数组将结果进行添加，还是把问题看作开头+子问题的结构，List<String>subs=dp(s,i+len);就会返回所有的子结构的组合，只需要for循环中将前缀和子结构进行一个组合就可以得到最后的结果

```java
class Solution {
    HashSet<String>Dict;
    public List<String> wordBreak(String s, List<String> wordDict) {
        Dict=new HashSet<>(wordDict);
        return dp(s,0);
    }
    public List<String>dp(String s,int i){
        List<String>res=new LinkedList<>();
        if(i==s.length()){
            res.add("");
            return res;
        }
        for(int len=1;len+i<=s.length();len++){
            String ss=s.substring(i,i+len);
            if(Dict.contains(ss)){
                List<String>subs=dp(s,i+len);
                for(String r:subs){
                    if(r.isEmpty()){
                        res.add(ss);
                    }else{
                        res.add(ss+" "+r);
                    }
                }
            }
        }
        return res;
    }
}
```

##### 子序列问题

###### [编辑距离](https://leetcode.cn/problems/edit-distance/)
