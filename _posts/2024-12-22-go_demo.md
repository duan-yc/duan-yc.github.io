---
layout: post
title: "go_demo"
subtitle: "go_demo"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
- go

---

go_demo

### åŸºç¡€è¯­æ³•

##### values

Go æœ‰å„ç§å€¼ç±»å‹ï¼ŒåŒ…æ‹¬å­—ç¬¦ä¸²ã€æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼ç­‰ã€‚è¿™é‡Œæ˜¯ä¸€äº›åŸºæœ¬ç¤ºä¾‹

```go
package main

import "fmt"

func main() {
	fmt.Println("go" + "lang")
	fmt.Println("1+1 =", 1+1)
	fmt.Println("7.0/3.0 =", 7.0/3.0)
	fmt.Println(true && false)
	fmt.Println(true || false)
	fmt.Println(!true)
}

```

##### å˜é‡

åœ¨ Go ä¸­ï¼Œ*å˜é‡*ç”±ç¼–è¯‘å™¨æ˜ç¡®å£°æ˜å’Œä½¿ç”¨ï¼Œä¾‹å¦‚æ£€æŸ¥å‡½æ•°è°ƒç”¨çš„ç±»å‹æ­£ç¡®æ€§

**varå¯ä»¥ä¸€æ¬¡å£°æ˜ä¸€ä¸ªæˆ–å¤šä¸ªå˜é‡**ï¼ŒGoå°†åˆ¤æ–­åˆå§‹åŒ–å˜é‡çš„ç±»å‹ï¼Œæœªè¿›è¡Œåˆå§‹åŒ–çš„å£°æ˜å˜é‡ä¸ºé›¶å€¼

**:=å¯åœ¨å‡½æ•°å†…éƒ¨ä½¿ç”¨**

```go
package main

import "fmt"

func main() {
    var a = "initial"
    fmt.Println(a)

    var b, c int = 1, 2
    fmt.Println(b, c)

    var d = true
    fmt.Println(d)

    var e int
    fmt.Println(e)

    f := "apple"
    fmt.Println(f)
}
```

##### å¸¸é‡

Goæ”¯æŒå­—ç¬¦ã€å­—ç¬¦ä¸²ã€å¸ƒå°”å€¼ã€æ•°å­—å€¼çš„å¸¸é‡

`const`å£°æ˜ä¸€ä¸ªå¸¸é‡å€¼ï¼Œ**ç”¨constå–ä»£varå³å¯**ï¼Œ**æ•°å­—å¸¸é‡æ²¡æœ‰ç±»å‹**ï¼Œé™¤éé€šè¿‡æ˜¾å¼è½¬æ¢ç­‰æ–¹å¼æŒ‡å®šç±»å‹

```go
package main

import (
    "fmt"
    "math"
)

const s string = "constant"

func main() {
    fmt.Println(s)

    const n = 500000000

    const d = 3e20 / n
    fmt.Println(d)

    fmt.Println(int64(d))

    fmt.Println(math.Sin(n))
}
```

##### for

`for`æ˜¯ Go å”¯ä¸€çš„å¾ªç¯ç»“æ„

```go
package main

import "fmt"

func main() {
    i := 1
    for i <= 3 {
       fmt.Println(i)
       i++
    }
    for j := 0; j < 5; j++ {
       fmt.Println(j)
    }
    nums := []int{1, 2, 3}
    for i := range nums {
       fmt.Println("range", i)
    }

    for {
       fmt.Println("loop")
       break
    }
    for i := 1; i <= 6; i++ {
       if i%2 == 1 {
          continue
       }
       fmt.Println(i)
    }
}
```

##### If-else

å¯ä»¥æœ‰`if`ä¸€ä¸ªä¸å¸¦ else çš„è¯­å¥ï¼Œè¯­å¥å¯ä»¥ä½äºæ¡ä»¶ä¹‹å‰ï¼Œæ­¤è¯­å¥å£°æ˜ä»»ä½•å˜é‡å¯ä»¥åœ¨è¯¥åˆ†æ”¯åŠåç»­åˆ†æ”¯ä½¿ç”¨

```go
package main

import "fmt"

func main() {
	if 7%2 == 0 {
		fmt.Println("7 is even")
	}

	if 8%2 == 0 || 7%2 == 0 {
		fmt.Println("either 8 or 7 are even")
	}
	
	if num := 9; num < 0 {
		fmt.Println(num, "is negative")
	} else if num > 0 {
		fmt.Println(num, "is positive")
	} else {
		fmt.Println(num, "is zero")
	}

}

```

##### switch

*Switch è¯­å¥*è¡¨è¾¾è·¨å¤šä¸ªåˆ†æ”¯çš„æ¡ä»¶

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	i := 2
	fmt.Print("write", i, "as")
	switch i {
	case 1:
		fmt.Println("one")
	case 2:
		fmt.Println("two")
	case 3:
		fmt.Println("three")
	}

	switch time.Now().Weekday() {
  //å¯ä»¥ä½¿ç”¨é€—å·åˆ†éš”åŒä¸€`case`è¯­å¥ä¸­çš„å¤šä¸ªè¡¨è¾¾å¼
	case time.Saturday, time.Sunday:
		fmt.Println("it's the weekend")
	default:
		fmt.Println("it's a weekday")
	}

	t := time.Now()
  //`switch`ä¸ä½¿ç”¨è¡¨è¾¾å¼æ˜¯è¡¨è¾¾ if/else é€»è¾‘çš„å¦ä¸€ç§æ–¹å¼,
	switch {
	case t.Hour() < 12:
		fmt.Println("it's before noon")
	default:
		fmt.Println("it's after noon")
	}

	whatAmI := func(i interface{}) {
    //ç±»å‹`switch`æ¯”è¾ƒçš„æ˜¯ç±»å‹è€Œä¸æ˜¯å€¼ã€‚å¯ä»¥ä½¿ç”¨å®ƒæ¥å‘ç°æ¥å£å€¼çš„ç±»å‹
		switch t := i.(type) {
		case bool:
			fmt.Println("I'm a bool")
		case int:
			fmt.Println("I'm an int")
		case string:
			fmt.Println("I'm a string")
		default:
			fmt.Printf("Don't know type %T\n", t)
		}
	}
	whatAmI(true)
	whatAmI("hey")
	whatAmI(1)
	
}

```

##### æ•°ç»„

```go
package main

import "fmt"

func main() {
    var a [5]int
    fmt.Println(a)

    a[4] = 100
    fmt.Println(a[4])
    fmt.Println(len(a))

    b := [5]int{1, 2, 3, 4, 5}
    fmt.Println(b)
		//å¯ä»¥è®©ç¼–è¯‘å™¨è®¡ç®—å…ƒç´ çš„æ•°é‡...
    b = [...]int{1, 2, 3, 4, 5}
    fmt.Println(b)
    //[100 0 0 400 500]
  	//3: 400è¡¨ç¤ºå°†3å·ä½ç½®è®¾ç½®ä¸º400ï¼Œç”±äº1å·å’Œ2å·ä½ç½®æ²¡æœ‰è®¾ç½®ï¼Œåˆ™é»˜è®¤ä¸º0
    b = [...]int{100, 3: 400, 500}
    fmt.Println(b)

    var twoD [2][3]int
    for i := 0; i < len(twoD); i++ {
       for j := 0; j < len(twoD[i]); j++ {
          twoD[i][j] = i + j
       }
    }
    fmt.Println(twoD)
    twoD = [2][3]int{
       {1, 2, 3},
       {2, 3, 4},
    }
    fmt.Println(twoD)

}
```

##### åˆ‡ç‰‡

åˆ‡ç‰‡å®é™…ä¸Šæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œ**ç»“æ„ä½“å†…éƒ¨åŒ…å«æŒ‡å‘åº•å±‚æ•°ç»„çš„æŒ‡é’ˆã€åˆ‡ç‰‡çš„é•¿åº¦ã€åˆ‡ç‰‡çš„å®¹é‡**

æ‰€ä»¥åˆ‡ç‰‡å®é™…ä¸Šæ˜¯å¯¹**åº•å±‚æ•°ç»„**çš„ä¸€ä¸ªå°è£…ï¼Œè‡ªå·±å¹¶ä¸å­˜å‚¨æ•°æ®

æ‰€ä»¥å½“ä½¿ç”¨appendæ–¹æ³•æ—¶ï¼Œå¦‚æœlen>capæ—¶ï¼Œå°±ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„æ•°ç»„ï¼ˆä¸€èˆ¬ä¸¤å€å®¹é‡ï¼‰è¿›è¡Œè¿ç§»ï¼Œä½†è¿™ä¸ªè¿‡ç¨‹å¹¶ä¸æ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œæ‰€ä»¥å¦‚æœå¤šä¸ªgoroutineåœ¨ä½¿ç”¨è¯¥åˆ‡ç‰‡çš„è¯ï¼Œå¯ä»¥è€ƒè™‘åŠ é”

```go
package main

import (
	"fmt"
	"reflect"
	"slices"
)

func main() {
	var s []string
	//[] true true
	fmt.Println(s, s == nil, len(s) == 0)

	s = make([]string, 3)
	//[  ] false 3 3
	fmt.Println(s, s == nil, len(s), cap(s))

	s[0] = "a"
	s[1] = "b"
	s[2] = "c"
	fmt.Println(s)
	fmt.Println(s[2])
	fmt.Println(len(s))
	//éœ€è¦æ¥å—è¿”å›å€¼
  //appendæ–¹æ³•çš„è¿”å›å€¼å’ŒåŸæ¥çš„å€¼æ˜¯å¦æ˜¯ç›¸åŒçš„åœ°å€ï¼Œå–å†³äºåˆ‡ç‰‡çš„å®¹é‡æ˜¯å¦è¶³å¤Ÿï¼Œå¦‚æœä¸å¤Ÿå°±ä¼šåˆ›å»ºæ–°çš„æ•°ç»„è¿›è¡Œè¿ç§»
	s = append(s, "d")
	s = append(s, "e", "f")
	//[a b c d e f]
	fmt.Println(s)

	c := make([]string, len(s))
  //è¿™é‡Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¸ é•¿åº¦ç›¸åŒçš„copyç©ºåˆ‡ç‰‡å¹¶å°†å…¶å¤åˆ¶åˆ°ä¸­
	copy(c, s)
	fmt.Println(c)

	l := s[2:5]
	//[c d e]
	fmt.Println(l)
	//å¯ä»¥åœ¨ä¸€è¡Œä¸­å£°æ˜å¹¶åˆå§‹åŒ–åˆ‡ç‰‡çš„å˜é‡
	t := []string{"a", "b", "c"}
	t2 := []string{"a", "b", "c"}
	//t==t2ï¼Œè¿™ä¸ªç”¨äºåˆ¤æ–­ä¸¤ä¸ªåˆ‡ç‰‡ä¸­çš„å†…å®¹æ˜¯å¦ç›¸åŒ
	if slices.Equal(t, t2) {
		fmt.Println("t==t2")
	}
	//å¦‚æœæƒ³æ¯”è¾ƒä¸¤ä¸ªçš„åœ°å€çš„è¯ï¼Œå¯ä»¥ä½¿ç”¨è¿”å›æˆ–è€…æ¯”è¾ƒä¸¤ä¸ªçš„æŒ‡é’ˆï¼Œä¸èƒ½ç›´æ¥ç”¨t==t2è¿›è¡Œæ¯”è¾ƒ
  //tå’Œt2çš„åœ°å€ä¸åŒ
	if reflect.ValueOf(t).Pointer() == reflect.ValueOf(t2).Pointer() {
		fmt.Println("t and t2 share the same underlying array")
	} else {
		fmt.Println("t and t2 do not share the same underlying array")
	}
	if &t[0] == &t2[0] {
		fmt.Println("t and t2 share the same underlying array")
	} else {
		fmt.Println("t and t2 do not share the same underlying array")
	}
	//åˆ‡ç‰‡å¯ä»¥ç»„æˆå¤šç»´æ•°æ®ç»“æ„ã€‚ä¸å¤šç»´æ•°ç»„ä¸åŒï¼Œå†…éƒ¨åˆ‡ç‰‡çš„é•¿åº¦å¯ä»¥å˜åŒ–
	twoD := make([][]int, 3)
	for i := 0; i < len(twoD); i++ {
		inner := i + 1
		twoD[i] = make([]int, inner)
		for j := 0; j < inner; j++ {
			twoD[i][j] = i + j
		}
	}
	//[[0] [1 2] [2 3 4]]
	fmt.Println(twoD)
}

```

##### æ˜ å°„

```go
package main

import (
	"fmt"
	"maps"
)

func main() {
	m := make(map[string]int)
	m["k1"] = 7
	m["k2"] = 13
	//map[k1:7 k2:13]
	fmt.Println(m)

	v1 := m["k2"]
	fmt.Println(v1)

	v3 := m["k3"]
	//0ï¼Œå¦‚æœé”®ä¸å­˜åœ¨ï¼Œ åˆ™è¿”å›å€¼ç±»å‹çš„é›¶å€¼
	fmt.Println(v3)

	fmt.Println(len(m))
	//å†…ç½®å‘½ä»¤deleteä»æ˜ å°„ä¸­åˆ é™¤é”®/å€¼å¯¹
	delete(m, "k2")
	//map[k1:7]
	fmt.Println(m)
	//è¦ä»mapä¸­åˆ é™¤æ‰€æœ‰clearé”®/å€¼å¯¹
	clear(m)
	//map[]
	fmt.Println(m)
	//ä»æ˜ å°„ä¸­è·å–å€¼æ—¶ï¼Œå¯é€‰çš„ç¬¬äºŒä¸ªè¿”å›å€¼æŒ‡ç¤ºæ˜ å°„ä¸­æ˜¯å¦å­˜åœ¨è¯¥é”®ã€‚
  //è¿™å¯ç”¨äºåŒºåˆ†ç¼ºå¤±é”®å’Œå…·æœ‰é›¶å€¼çš„é”®ï¼ˆå¦‚0æˆ– ï¼‰""ã€‚
  //è¿™é‡Œæˆ‘ä»¬ä¸éœ€è¦å€¼æœ¬èº«ï¼Œå› æ­¤æˆ‘ä»¬ç”¨ç©ºç™½æ ‡è¯†ç¬¦ _å¿½ç•¥å®ƒ
	_, prs := m["k2"]
	//false
	fmt.Println(prs)

	n := map[string]int{"foo": 1, "bar": 2}
	fmt.Println(n)
	//map[k:v k:v]è¯·æ³¨æ„ï¼Œä½¿ç”¨ æ‰“å°æ—¶ï¼Œåœ°å›¾ä¼šä»¥è¡¨æ ¼å½¢å¼å‡ºç°fmt.Println
	n2 := map[string]int{"foo": 1, "bar": 2}
	if maps.Equal(n, n2) {
		//true
		fmt.Println("true")
	}
}

```

##### å‡½æ•°

```go
package main

import "fmt"

func plus(a int, b int) int {
	//Go éœ€è¦æ˜¾å¼è¿”å›ï¼Œå³å®ƒä¸ä¼šè‡ªåŠ¨è¿”å›æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
	return a + b
}

func plusPlus(a, b, c int) int {
	return a + b + c
}

func vals() (int, int) {
	//å¯ä»¥å¤šè¿”å›å€¼
	return 3, 7
}

func main() {

	res := plus(1, 2)
	fmt.Println(res)

	res = plusPlus(1, 2, 3)
	fmt.Println(res)

	a, b := vals()
	fmt.Println(a, b)
	_, c := vals()
	//7
	fmt.Println(c)

}

```

##### é—­åŒ…

Go æ”¯æŒ[*åŒ¿åå‡½æ•°*](https://en.wikipedia.org/wiki/Anonymous_function)ï¼Œå¯ä»¥å½¢æˆ[*é—­åŒ…*](https://en.wikipedia.org/wiki/Closure_(computer_science))ã€‚å½“ä½ æƒ³ä»¥å†…è”æ–¹å¼å®šä¹‰å‡½æ•°è€Œä¸å¿…ä¸ºå…¶å‘½åæ—¶ï¼ŒåŒ¿åå‡½æ•°éå¸¸æœ‰ç”¨

```go
package main

import "fmt"

func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

func main() {
  //æ¯æ¬¡ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„çŠ¶æ€
	nextInt := intSeq()
	//1
	fmt.Println(nextInt())
	//2
	fmt.Println(nextInt())
	//3
	fmt.Println(nextInt())
	newInt := intSeq()
	//1
	fmt.Println(newInt())
}

```

##### é€’å½’

```go
package main

import "fmt"

func fact(n int) int {
    if n == 0 {
       return 1
    }
    return n * fact(n-1)
}

func main() {
    fmt.Println(fact(5))
    var fib func(n int) int
    fib = func(n int) int {
       if n < 2 {
          return n
       }
       return fib(n-1) + fib(n-2)
    }
    fmt.Println(fib(10))
}
```

##### rangeå‡½æ•°

```go
package main

import "fmt"

func main() {
    nums := []int{1, 2, 3}
    sum := 0
    for _, num := range nums {
       sum += num
    }
    fmt.Println(sum)
    for i, num := range nums {
       if num == 3 {
          //2
          fmt.Println(i)
       }
    }
    kvs := map[string]int{"a": 1, "b": 2}
    for k, v := range kvs {
       fmt.Println(k, v)
    }
    for k := range kvs {
       fmt.Println(k)
    }

    for i, c := range "go" {
       fmt.Println(i, c)
    }
}
```

##### æŒ‡é’ˆ

`&i`è¯­æ³•ç»™å‡ºäº† çš„å†…å­˜åœ°å€`i`ï¼Œå³ çš„æŒ‡é’ˆ`i`

```go
package main

import "fmt"

func zeroval(inval int) {
    inval = 0
}

func zeroptr(inptr *int) {
    *inptr = 0
}

func main() {
    i := 1
    fmt.Println(i)

    zeroval(i)
    fmt.Println(i)

    zeroptr(&i)
    fmt.Println(i)

}
```

##### strings

åœ¨ Go ä¸­ï¼Œ`rune` æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªè¡¨ç¤º Unicode ç ç‚¹çš„æ•´æ•°ï¼ˆæœ¬è´¨ä¸Šæ˜¯ `int32` ç±»å‹ï¼‰ã€‚

```go
package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    const s = "Zbs"
    //3
    fmt.Println(len(s))
    for i := 0; i < len(s); i++ {
       //Z b s
       fmt.Printf("%c ", s[i])
    }
    fmt.Println()
    //3ï¼Œç”¨äºè®¡ç®—å­—ç¬¦ä¸²ä¸­ Unicode å­—ç¬¦ï¼ˆå³ runeï¼‰ çš„æ•°é‡
    fmt.Println(utf8.RuneCountInString(s))

    //å¦‚æœæ²¡æœ‰%cï¼Œå°±ä¼šè¾“å‡ºasciiçš„intå€¼
    for idx, value := range s {
       //0 90
       //1 98
       //2 115
       fmt.Println(idx, value)
    }

    for i, w := 0, 0; i < len(s); i += w {
       //ç”¨äºè§£ç å­—ç¬¦ä¸²ä¸­çš„ä¸‹ä¸€ä¸ª Unicode å­—ç¬¦ï¼ˆruneï¼‰ï¼Œå¹¶è¿”å›è¯¥å­—ç¬¦ä»¥åŠå®ƒçš„å­—èŠ‚å®½åº¦
       runValue, width := utf8.DecodeRuneInString(s[i:])
       fmt.Println(width, runValue)
       w = width
       examineRunne(runValue)
    }

}
func examineRunne(r rune) {
    if r == 'b' {
       fmt.Println("b")
    } else if r == 'a' {
       fmt.Println("a")
    }
}
```

##### ç»“æ„ä½“

å¦‚æœè¦å°†ç»“æ„ä½“ä½œä¸ºå‡½æ•°çš„å‚æ•°è¿›è¡Œä¼ é€’çš„æ—¶å€™ï¼Œè¦è€ƒè™‘æ˜¯å¦è¦ä¿®æ”¹åŸç»“æ„ä½“çš„å€¼ï¼Œæ¥ç¡®å®šç»“æ„ä½“å‚æ•°è®¾ç½®ä¸ºæŒ‡é’ˆç±»å‹è¿˜æ˜¯å€¼ç±»å‹

```go
package main

import "fmt"

type person struct {
    name string
    age  int
}

func newPerson(name string, age int) *person {
    return &person{name, age}
}

func main() {
    fmt.Println(person{"Bob", 20})
    fmt.Println(person{name: "Bob", age: 20})
    fmt.Println(person{name: "Bob"})
    //&{Bob 20}
    fmt.Println(&person{name: "Bob", age: 20})
    //&{Bob 20}
  	//å°†æ–°ç»“æ„ä½“çš„åˆ›å»ºå°è£…åœ¨æ„é€ å‡½æ•°ä¸­æ˜¯ä¸€ç§æƒ¯ç”¨åšæ³•
    fmt.Println(newPerson("Bob", 20))

    s := person{name: "Bob", age: 20}
    fmt.Println(s.name)

    sp := &s
    //20
    fmt.Println(sp.age)
    sp.age = 30
    //30
    fmt.Println(s.age)

    dog := struct {
       name   string
       isGood bool
    }{
       "name",
       true,
    }
    fmt.Println(dog)
}
```

##### æ–¹æ³•

é€šè¿‡ç»“æ„ä½“ã€æ–¹æ³•ã€æ¥å£æ¥å®ç°é¢å¯¹å¯¹è±¡çš„è®¾è®¡

é€šè¿‡ç»“æ„ä½“+æ–¹æ³•å®ç°ç±»çš„ç»„åˆ

```go
package main

import "fmt"

type rect struct {
    width, height int
}
//æŒ‡é’ˆå‹æ¥æ”¶è€…ï¼Œè¿™æ ·æ–¹æ³•å†…éƒ¨çš„ä¿®æ”¹ä¼šå½±å“åˆ°ç»“æ„ä½“çš„åŸå­—æ®µ
func (r *rect) area() int {
    return r.width * r.height
}
//å€¼æ¥æ”¶è€…ï¼Œæ–¹æ³•å†…éƒ¨çš„ä¿®æ”¹ä¸ä¼šå½±å“åˆ°ç»“æ„ä½“çš„åŸå­—æ®µ
func (r rect) perim() int {
    return 2*r.width + 2*r.height
}

func main() {
    r := rect{width: 10, height: 5}

    fmt.Println("area: ", r.area())
    fmt.Println("perim:", r.perim())
		//Go è‡ªåŠ¨å¤„ç†æ–¹æ³•è°ƒç”¨æ—¶å€¼ä¸æŒ‡é’ˆä¹‹é—´çš„è½¬æ¢
    rp := &r
    fmt.Println("area: ", rp.area())
    fmt.Println("perim:", rp.perim())
  	//è¿™é‡Œå¦‚æœå®šä¹‰çš„æ˜¯æŒ‡é’ˆç±»å‹ï¼Œé‚£ä¹ˆrå°±åªèƒ½ä¼ é€’çš„æ˜¯åœ°å€
    var t *rect
    t = &r
    t.width = 0
    fmt.Println("area: ", t.area())
    fmt.Println("perim:", t.perim())
    fmt.Println("area: ", r.area())
    fmt.Println("perim:", r.perim())
}
```

##### æ¥å£

åœ¨Goä¸­å®ç°æ¥å£ï¼Œæˆ‘ä»¬åªéœ€è¦å®ç°æ¥å£é‡Œçš„æ‰€æœ‰æ–¹æ³•å³å¯

```go
package main

import (
    "fmt"
    "math"
)

type geometry interface {
    area() float64
    perim() float64
}

type rectt struct {
    width, height float64
}

type circle struct {
    radius float64
}
//åœ¨ Go ä¸­ï¼Œæ¥å£çš„å®ç°ä¾èµ–äºæ–¹æ³•æ¥æ”¶è€…çš„ç±»å‹ï¼Œè€Œæ–¹æ³•çš„è°ƒç”¨å°±éœ€è¦æŒ‰ç…§æ¥æ”¶è€…çš„ç±»å‹æ¥è¿›è¡Œè°ƒç”¨
func (r *rectt) area() float64 {
    return r.width * r.height
}
func (r *rectt) perim() float64 {
    return 2*r.width + 2*r.height
}

func (c circle) area() float64 {
    return math.Pi * c.radius * c.radius
}
func (c circle) perim() float64 {
    return 2 * math.Pi * c.radius
}
//å¦‚æœå˜é‡å…·æœ‰æ¥å£ç±»å‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è°ƒç”¨æŒ‡å®šæ¥å£ä¸­çš„æ–¹æ³•
//ç±»ä¼¼äºjavaä¸­çš„å¤šæ€
func measure(g geometry) {
    fmt.Println(g)
}

func main() {
    r := rectt{width: 10, height: 5}
    c := circle{radius: 5}
  //circleå’Œç»“æ„ç±»å‹rectéƒ½å®ç°äº†geometryæ¥å£ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™äº›ç»“æ„çš„å®ä¾‹ä½œä¸ºçš„å‚æ•°measure
  //å› ä¸ºå®ç°æ¥å£çš„æ–¹æ³•æ¥æ”¶è€…æ˜¯æŒ‡é’ˆç±»å‹ï¼Œæ‰€ä»¥è¿™é‡Œå°±éœ€è¦èµ‹åœ°å€
    measure(&r)
    measure(c)
}
```

##### æšä¸¾

æšä¸¾æ˜¯ä¸€ç§å…·æœ‰å›ºå®šæ•°é‡å¯èƒ½å€¼çš„ç±»å‹ï¼Œæ¯ä¸ªå€¼éƒ½æœ‰ä¸åŒçš„åç§°ã€‚Go æ²¡æœ‰æšä¸¾ç±»å‹ä½œä¸ºç‹¬ç‰¹çš„è¯­è¨€åŠŸèƒ½ï¼Œä½†ä½¿ç”¨ç°æœ‰çš„è¯­è¨€ä¹ è¯­å¾ˆå®¹æ˜“å®ç°æšä¸¾ã€‚

```go
package main

import "fmt"

type ServerState int

const (
	//è¿™é‡Œé€šè¿‡ iota åˆ›å»ºäº†å››ä¸ªå¸¸é‡ï¼Œåˆ†åˆ«è¡¨ç¤ºæœåŠ¡å™¨çš„å››ç§çŠ¶æ€
	//iota æ˜¯ Go ä¸­ç”¨äºç”Ÿæˆå¸¸é‡å€¼çš„ä¸€ä¸ªç‰¹æ®Šå…³é”®å­—ï¼Œå®ƒåœ¨æ¯ä¸€è¡Œå¸¸é‡å®šä¹‰ä¸­ä¼šè‡ªåŠ¨é€’å¢
	StateIdle ServerState = iota
	StateConnected
	StateError
	StateRetrying
)

var stateName = map[ServerState]string{
	StateIdle:      "idle",
	StateConnected: "connected",
	StateError:     "error",
	StateRetrying:  "retrying",
}

func (ss ServerState) String() string {
	return stateName[ss]
}

func main() {
	//è¿™é‡Œè™½ç„¶ServerStateæ˜¯intç±»å‹ï¼Œä½†ä¸èƒ½ä¼ intç±»å‹è¿›å»ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œå› ä¸ºå®ƒä»¬çš„ç±»å‹ä¸åŒã€‚
	ns := transition(StateIdle)
	fmt.Println(ns)

	ns2 := transition(ns)
	fmt.Println(ns2)
}

// transition æ¨¡æ‹ŸæœåŠ¡å™¨çš„çŠ¶æ€è½¬æ¢ï¼›å®ƒé‡‡ç”¨ç°æœ‰çŠ¶æ€å¹¶è¿”å›æ–°çŠ¶æ€
func transition(s ServerState) ServerState {
	switch s {
	case StateIdle:
		return StateConnected
	case StateConnected, StateRetrying:

		return StateIdle
	case StateError:
		return StateError
	default:
		panic(fmt.Errorf("unknown state: %s", s))
	}
}

```

##### ç»“æ„ä½“åµŒå…¥

```go
package main

import "fmt"

type base struct {
    num int
}

func (b base) describe() string {
    return fmt.Sprintf("base with num=%v", b.num)
}

type container struct {
  	//Acontainer åµŒå…¥a baseã€‚åµŒå…¥çœ‹èµ·æ¥åƒä¸€ä¸ªæ²¡æœ‰åç§°çš„å­—æ®µ
    base
    str string
}

func main() {
		//å½“ä½¿ç”¨æ–‡å­—åˆ›å»ºç»“æ„æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»æ˜ç¡®åˆå§‹åŒ–åµŒå…¥ï¼›è¿™é‡ŒåµŒå…¥çš„ç±»å‹ç”¨ä½œå­—æ®µåç§°
    co := container{
       base: base{
          num: 1,
       },
       str: "some name",
    }
		//è¿™æ ·å°±å¯ä»¥ç›´æ¥è®¿é—®å­ç»“æ„ä½“çš„å­å­—æ®µ ä¾‹å¦‚co.num
    fmt.Printf("co={num: %v, str: %v}\n", co.num, co.str)

    fmt.Println("also num:", co.base.num)
		//ç”±äºcontaineråµŒå…¥baseï¼Œ çš„æ–¹æ³• baseä¹Ÿæˆä¸º çš„æ–¹æ³•ã€‚è¿™é‡Œæˆ‘ä»¬ ç›´æ¥containeråœ¨ ä¸Šè°ƒç”¨åµŒå…¥çš„æ–¹æ³•
    fmt.Println("describe:", co.describe())

    type describer interface {
       describe() string
    }
		//åµŒå…¥å¸¦æœ‰æ–¹æ³•çš„ç»“æ„å¯ç”¨äºå°†æ¥å£å®ç°èµ‹äºˆå…¶ä»–ç»“æ„ã€‚è¿™é‡Œæˆ‘ä»¬çœ‹åˆ° acontainerç°åœ¨å®ç°äº† describeræ¥å£ï¼Œå› ä¸ºå®ƒåµŒå…¥äº†baseã€‚
    var d describer = co
    fmt.Println("describer:", d.describe())
}
```

##### æ³›å‹

```go
package main

import "fmt"

// SlicesIndex ä½¿ç”¨äº† ç±»å‹çº¦æŸï¼Œå…¶ä¸­ S ~[]E å’Œ E comparable æ˜¯å‡½æ•°çš„ç±»å‹å‚æ•°çº¦æŸ
// S å¿…é¡»æ˜¯ åˆ‡ç‰‡ç±»å‹ï¼Œå¹¶ä¸”è¯¥åˆ‡ç‰‡çš„å…ƒç´ ç±»å‹æ˜¯ E
// ~ è¿ç®—ç¬¦åœ¨è¿™é‡Œçš„ä½œç”¨æ˜¯å…è®¸ç±»å‹åˆ«åï¼Œå³å…è®¸ S ä¸ä»…ä»…æ˜¯ []E è¿™æ ·çš„åŸå§‹åˆ‡ç‰‡ç±»å‹ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªåˆ‡ç‰‡ç±»å‹çš„ç±»å‹åˆ«åï¼Œå³å¦‚æœåé¢ä½¿ç”¨è¿™ä¸ªæ–¹æ³•çš„æ—¶å€™ï¼Œä¼ é€’å‚æ•°æ—¶åˆ‡ç‰‡çš„ç±»å‹ä¸ä»…å¯ä»¥æ˜¯Eï¼Œä¹Ÿå¯ä»¥æ˜¯å…¶ä»–ç±»å‹
func SlicesIndex[S ~[]E, E comparable](s S, v E) int {
    //E comparable é™åˆ¶äº†ä¼ å…¥çš„å…ƒç´ ç±»å‹ E å¿…é¡»æ˜¯å¯ä»¥é€šè¿‡ == å’Œ != è¿ç®—ç¬¦è¿›è¡Œæ¯”è¾ƒçš„ç±»å‹
    for i := range s {
       if v == s[i] {
          return i
       }
    }
    return -1
}

// List List[T any] æ˜¯ä¸€ä¸ªæ³›å‹é“¾è¡¨ç±»å‹ï¼ŒT è¡¨ç¤ºé“¾è¡¨ä¸­èŠ‚ç‚¹çš„å…ƒç´ ç±»å‹ï¼Œany è¡¨ç¤ºå¯ä»¥æ˜¯ä»»ä½•ç±»å‹
type List[T any] struct {
    head, tail *element[T]
}

// element[T any] æ˜¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ç±»å‹
type element[T any] struct {
  //å¸¦çš„*è¯´æ˜æ˜¯åœ°å€
    next *element[T]
    val  T
}
//ä¸ºé“¾è¡¨å®šä¹‰äº†ä¸¤ä¸ªæ–¹æ³•
//æˆ‘ä»¬å¯ä»¥åƒåœ¨å¸¸è§„ç±»å‹ä¸Šä¸€æ ·åœ¨æ³›å‹ç±»å‹ä¸Šå®šä¹‰æ–¹æ³•ï¼Œä½†å¿…é¡»ä¿ç•™ç±»å‹å‚æ•°ã€‚ç±»å‹æ˜¯List[T]ï¼Œè€Œä¸æ˜¯List
func (lst *List[T]) Push(v T) {
    if lst.tail == nil {
       lst.head = &element[T]{val: v}
       lst.tail = lst.head
    } else {
       lst.tail.next = &element[T]{val: v}
       lst.tail = lst.tail.next
    }
}

func (lst *List[T]) AllElements() []T {
    var elems []T
    for e := lst.head; e != nil; e = e.next {
       elems = append(elems, e.val)
    }
    return elems
}

func main() {
    var s = []string{"foo", "bar", "zoo"}

    fmt.Println("index of zoo:", SlicesIndex(s, "zoo"))

    _ = SlicesIndex[[]string, string](s, "zoo")

    lst := List[int]{}
    lst.Push(10)
    lst.Push(13)
    lst.Push(23)
    fmt.Println("list:", lst.AllElements())
}
```

##### rangeè¿­ä»£å™¨

è¿­ä»£å™¨å‡½æ•°å°†å¦ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œ`yield`æŒ‰ç…§æƒ¯ä¾‹è°ƒç”¨è¯¥å‡½æ•°ï¼ˆä½†åç§°å¯ä»¥ä»»æ„ï¼‰ã€‚å®ƒå°†è°ƒç”¨`yield`æˆ‘ä»¬æƒ³è¦è¿­ä»£çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶æ³¨æ„`yield`çš„è¿”å›å€¼ä»¥é˜²å¯èƒ½æå‰ç»ˆæ­¢ã€‚

```go
package main

import (
	"fmt"
	"iter"
	"slices"
)

type List[T any] struct {
	head, tail *element[T]
}

type element[T any] struct {
	next *element[T]
	val  T
}

func (lst *List[T]) Push(v T) {
	if lst.tail == nil {
		lst.head = &element[T]{val: v}
		lst.tail = lst.head
	} else {
		lst.tail.next = &element[T]{val: v}
		lst.tail = lst.tail.next
	}
}

func (lst *List[T]) All() iter.Seq[T] {
	return func(yield func(T) bool) {

		for e := lst.head; e != nil; e = e.next {
			if !yield(e.val) {
				return
			}
		}
	}
}
//è¿­ä»£ï¼ˆIterationï¼‰ ä¸ä¸€å®šä¾èµ–äºç‰¹å®šçš„æ•°æ®ç»“æ„ï¼Œç”šè‡³ä¸éœ€è¦æ˜¯æœ‰é™çš„ï¼ˆæ¯”å¦‚æ— é™åºåˆ—ï¼‰
func genFib() iter.Seq[int] {
	return func(yield func(int) bool) {
		a, b := 1, 1

		for {
			if !yield(a) {
				return
			}
			a, b = b, a+b
		}
	}
}

func main() {
	lst := List[int]{}
	lst.Push(10)
	lst.Push(13)
	lst.Push(23)
	//ç”±äºList.Allè¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¸¸è§„rangeå¾ªç¯ä¸­ä½¿ç”¨å®ƒ
	for e := range lst.All() {
		fmt.Println(e)
	}
	//åƒåˆ‡ç‰‡è¿™æ ·çš„åŒ…æœ‰è®¸å¤šæœ‰ç”¨çš„å‡½æ•°å¯ä»¥ä¸è¿­ä»£å™¨ä¸€èµ·ä½¿ç”¨
	all := slices.Collect(lst.All())
	fmt.Println("all:", all)
	
	for n := range genFib() {

		if n >= 10 {
			break
		}
		fmt.Println(n)
	}
}

```

é“¾è¡¨ä»¥å‰çš„å®šä¹‰æ–¹å¼å¦‚ä¸‹

```go
package main

import "fmt"

type ListNode struct {
	next *ListNode
	val  int
}

func main() {
	head := &ListNode{}
	node := head
	for node != nil {
		if node.next == nil {
			node.next = &ListNode{nil, 1}
			break
		}
		node = node.next
	}
	for head != nil {
		fmt.Println(head.val)
		head = head.next
	}
	
}

```

##### é”™è¯¯

åœ¨ Go ä¸­ï¼Œé€šè¿‡æ˜¾å¼ã€å•ç‹¬çš„è¿”å›å€¼ä¼ è¾¾é”™è¯¯æ˜¯ä¸€ç§æƒ¯ç”¨åšæ³•

```go
package main

import (
	"errors"
	"fmt"
)

func f(arg int) (int, error) {
	if arg == 42 {
		//errors.Newerrorä½¿ç”¨ç»™å®šçš„é”™è¯¯æ¶ˆæ¯æ„é€ ä¸€ä¸ªåŸºæœ¬å€¼
		return -1, errors.New("can't work with 42")
	}

	return arg + 3, nil
}
//æ ‡è®°é”™è¯¯æ˜¯ä¸€ä¸ªé¢„å…ˆå£°æ˜çš„å˜é‡ï¼Œç”¨äºè¡¨ç¤ºç‰¹å®šçš„é”™è¯¯æƒ…å†µ
var ErrOutOfTea = fmt.Errorf("no more tea available")
var ErrPower = fmt.Errorf("can't boil water")

func makeTea(arg int) error {
	if arg == 2 {
		return ErrOutOfTea
	} else if arg == 4 {
		//è¿™é‡Œæ˜¯åŒ…è£…é”™è¯¯ï¼Œå› ä¸ºåœ¨å¹³æ—¶ä½¿ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œå¸Œæœ›ä¸ä»…è¿”å›é”™è¯¯ï¼Œè¿˜å¯ä»¥è¿”å›é”™è¯¯ä¸Šä¸‹æ–‡ä¿¡æ¯
    //å°†ä¸€ä¸ªé”™è¯¯åŒ…è£…åˆ°å¦ä¸€ä¸ªé”™è¯¯ä¸­ï¼Œå¹¶ä¸”ä¿ç•™åŸå§‹é”™è¯¯ä¿¡æ¯ï¼Œè¿™æ ·å¯ä»¥æ„å»ºä¸€ä¸ªé”™è¯¯é“¾
    //è¿™é‡Œçš„å‡½æ•°makeTeaå°±æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œæ ¹æ®ä¼ é€’çš„å‚æ•°æ¥æ¨¡æ‹Ÿå‡ºä¸åŒçš„é”™è¯¯
		return fmt.Errorf("making tea: %w", ErrPower)
	}
	return nil
}

func main() {
	for _, i := range []int{7, 42} {

		if r, e := f(i); e != nil {
			fmt.Println("f failed:", e)
		} else {
			fmt.Println("f worked:", r)
		}
	}

	for i := 1; i <= 5; i++ {
		if err := makeTea(i); err != nil {
			//errors.Isæ£€æŸ¥ç»™å®šé”™è¯¯ï¼ˆæˆ–å…¶é“¾ä¸­çš„ä»»ä½•é”™è¯¯ï¼‰æ˜¯å¦ä¸ç‰¹å®šé”™è¯¯å€¼åŒ¹é…
			if errors.Is(err, ErrOutOfTea) {
				fmt.Println("We should buy new tea!")
			} else if errors.Is(err, ErrPower) {
				fmt.Println("Now it is dark.")
			} else {
				fmt.Printf("unknown error: %s\n", err)
			}
			continue
		}

		fmt.Println("Tea is ready!")
	}
}

```

##### è‡ªå®šä¹‰é”™è¯¯

```go
package main

import (
	"errors"
	"fmt"
)

// ä½¿ç”¨ç»“æ„ä½“è‡ªå®šä¹‰ä¸€ä¸ªé”™è¯¯
type argError struct {
	arg     int
	message string
}

// å®ç°erroræ¥å£
func (e *argError) Error() string {
	return fmt.Sprintf("%d - %s", e.arg, e.message)
}

func f1(arg int) (int, error) {
	if arg == 42 {
		//æ–¹æ³•çš„æ¥æ”¶è€…ä½¿ç”¨çš„æ˜¯æŒ‡é’ˆç±»å‹ï¼Œæ‰€ä»¥è¿™é‡Œè¦ç”¨&
		return -1, &argError{arg, "can't work with it"}
	}
	return arg + 3, nil
}

func main() {

	_, err := f1(42)
	var ae *argError
	//è¿™é‡Œçš„errors.Asä¼šæ£€æŸ¥erræ˜¯å¦æ˜¯aeç±»å‹çš„é”™è¯¯ï¼Œå¦‚æœæ˜¯çš„è¯ï¼Œå°±ä¼šå°†errèµ‹å€¼ç»™ae
	//errors.Asèµ‹å€¼çš„æ—¶å€™ï¼Œè¦æ±‚è¢«èµ‹å€¼çš„å˜é‡å¿…é¡»æ˜¯æŒ‡é’ˆç±»å‹ï¼Œè¿™æ ·æ‰å¯ä»¥è¿›è¡Œä¿®æ”¹
	//æ‰€ä»¥è¿™é‡Œä¼ é€’çš„æ˜¯aeçš„åœ°å€ï¼Œå°½ç®¡aeæœ¬æ¥å°±æ˜¯ä¸€ä¸ªå¼•ç”¨åœ°å€
	if errors.As(err, &ae) {
		fmt.Println(ae.arg)
		fmt.Println(ae.message)
	} else {
		fmt.Println("err doesn't match argError")
	}
}
/*
è¿™é‡Œæœ€åçš„è¾“å‡ºæ˜¯
42
can't work with it
*/
```

##### panic

`panic` æ˜¯ Go ä¸­çš„ä¸€ç§æœºåˆ¶ï¼Œç”¨äºåœ¨ç¨‹åºé‡åˆ°æ— æ³•æ¢å¤çš„é”™è¯¯æ—¶ç»ˆæ­¢ç¨‹åºçš„æ­£å¸¸æ‰§è¡Œ

ä¸€æ—¦ `panic` è§¦å‘ï¼Œå½“å‰å‡½æ•°åœæ­¢æ‰§è¡Œï¼Œå¹¶å‘ä¸Šçº§å‡½æ•°ä¼ æ’­ï¼Œå¦‚æœæ²¡æœ‰ `recover()` æ¥æ•è· `panic`ï¼Œç¨‹åºå°†ç»ˆæ­¢å¹¶è¾“å‡ºè°ƒç”¨æ ˆ

åœ¨ä¸‹é¢è¿™æ®µä»£ç ä¸­ï¼Œç¨‹åºåœ¨æ‰§è¡Œå®Œpanic("a problem")åï¼Œå°±ä¼šåœæ­¢æ‰§è¡Œåç»­çš„éƒ¨åˆ†

```go
package main

import "os"

func main() {

    //panic() ç”¨äºä¸­æ­¢ç¨‹åºå¹¶æŠ›å‡ºé”™è¯¯ä¿¡æ¯
    //panic è§¦å‘æ—¶ï¼Œç¨‹åºä¼šç«‹å³ç»ˆæ­¢ï¼Œå¹¶æ‰“å°å‡ºè°ƒç”¨æ ˆ
    panic("a problem")

    _, err := os.Create("/tmp/file")
    if err != nil {
       panic(err)
    }
}
```

å¯ä»¥ä½¿ç”¨recoverå‡½æ•°æ•è·panicå¹¶ç»§ç»­æ‰§è¡Œç¨‹åºï¼Œå…¶åŸç†æ˜¯ï¼š

1. `panic` ä¼šç«‹å³ç»ˆæ­¢å½“å‰å‡½æ•°ï¼Œå¹¶å¼€å§‹å‘ä¸Šå›æº¯è°ƒç”¨æ ˆï¼ˆstack unwindingï¼‰ã€‚
2. ç›´åˆ° `defer` ä¸­çš„ `recover()` è¢«è°ƒç”¨ï¼Œæ‰å¯ä»¥æ•è· `panic` å¹¶æ¢å¤æ§åˆ¶æƒã€‚

`recover()` åªèƒ½æ•è· `panic` å¹¶é˜²æ­¢ç¨‹åºå´©æºƒï¼Œä½† `panic` å‘ç”Ÿåçš„ä»£ç ä¸ä¼šå†ç»§ç»­æ‰§è¡Œï¼Œè¾“å‡ºï¼š

```
File created successfully
Recovered from panic: a problem
```

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered from panic:", r)
        }
    }()

    _, err := os.Create("/tmp/file")
    if err != nil {
        panic(err)
    }
    fmt.Println("File created successfully")

    panic("a problem")
}

```

##### Defer

*Defer*ç”¨äºç¡®ä¿å‡½æ•°è°ƒç”¨åœ¨ç¨‹åºæ‰§è¡Œçš„ç¨åé˜¶æ®µæ‰§è¡Œï¼Œé€šå¸¸ç”¨äºæ¸…ç†ç›®çš„

```go
package main

import (
	"fmt"
	"os"
)

func main() {

	f := createFile("/tmp/defer.txt")
	defer closeFile(f)
	writeFile(f)
}

func createFile(p string) *os.File {
	fmt.Println("creating")
	f, err := os.Create(p)
	if err != nil {
		panic(err)
	}
	return f
}

func writeFile(f *os.File) {
	fmt.Println("writing")
	fmt.Fprintln(f, "data")
}

func closeFile(f *os.File) {
	fmt.Println("closing")
	err := f.Close()

	if err != nil {
		panic(err)
	}
}

```

##### recover

Go å¯ä»¥ä½¿ç”¨å†…ç½®å‡½æ•°ä» panic ä¸­*æ¢å¤*

æ¯”å¦‚ä½¿ç”¨reoveråï¼Œå¦‚æœæŸä¸ªå®¢æˆ·ç«¯è¿æ¥å‡ºç°ä¸¥é‡é”™è¯¯ï¼ŒæœåŠ¡å™¨ä¸ä¼šå´©æºƒã€‚ç›¸åï¼ŒæœåŠ¡å™¨ä¼šå…³é—­è¯¥è¿æ¥å¹¶ç»§ç»­ä¸ºå…¶ä»–å®¢æˆ·ç«¯æä¾›æœåŠ¡ã€‚äº‹å®ä¸Šï¼Œè¿™æ­£æ˜¯ Go`net/http` é»˜è®¤ä¸º HTTP æœåŠ¡å™¨æ‰€åšçš„

recoveréœ€è¦ä½¿ç”¨deferï¼Œä¸ç„¶æ˜¯ä¸èƒ½è§¦å‘çš„

```go
package main

import "fmt"

func mayPanic() {
	panic("a problem")
}

func main() {

	defer func() {
		if r := recover(); r != nil {

			fmt.Println("Recovered. Error:\n", r)
		}
	}()

	mayPanic()

	fmt.Println("After mayPanic()")
}

```

##### å­—ç¬¦ä¸²å‡½æ•°

```go
package main

import (
	"fmt"
	s "strings"
)

var p = fmt.Println

func main() {
	//trueï¼Œæ£€æŸ¥å­å­—ç¬¦ä¸² es æ˜¯å¦å­˜åœ¨äº "test" ä¸­
	p("Contains:  ", s.Contains("test", "es"))
	//2ï¼Œç»Ÿè®¡å­—ç¬¦ä¸² "test" ä¸­å­å­—ç¬¦ä¸² "t" å‡ºç°çš„æ¬¡æ•°
	p("Count:     ", s.Count("test", "t"))
	//trueï¼Œæ£€æŸ¥å­—ç¬¦ä¸² "test" æ˜¯å¦ä»¥ "te" å¼€å¤´
	p("HasPrefix: ", s.HasPrefix("test", "te"))
	//trueï¼Œæ£€æŸ¥å­—ç¬¦ä¸² "test" æ˜¯å¦ä»¥ "st" ç»“å°¾
	p("HasSuffix: ", s.HasSuffix("test", "st"))
	//1ï¼Œè¿”å›å­å­—ç¬¦ä¸² "e" åœ¨ "test" ä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ç´¢å¼•ä½ç½®
	p("Index:     ", s.Index("test", "e"))
	//a-bï¼Œå°† []string{"a", "b"} ç”¨ "-" è¿æ¥ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²
	p("Join:      ", s.Join([]string{"a", "b"}, "-"))
	//aaaaaï¼Œå°†å­—ç¬¦ä¸² "a" é‡å¤ 5 æ¬¡
	p("Repeat:    ", s.Repeat("a", 5))
	//å°†å­—ç¬¦ä¸² "foo" ä¸­çš„ "o" æ›¿æ¢æˆ "0"ï¼Œ-1è¡¨ç¤ºæ›¿æ¢æ‰€æœ‰çš„
	p("Replace:   ", s.Replace("foo", "o", "0", -1))
	//1è¡¨ç¤ºåªæ›¿æ¢ç¬¬ä¸€ä¸ªåŒ¹é…çš„ "o" ä¸º "0"
	p("Replace:   ", s.Replace("foo", "o", "0", 1))
	//[]string{"a", "b", "c", "d", "e"}ï¼Œä½¿ç”¨ "-" ä½œä¸ºåˆ†éš”ç¬¦æ‹†åˆ†å­—ç¬¦ä¸² "a-b-c-d-e"
	p("Split:     ", s.Split("a-b-c-d-e", "-"))
	//å°†å­—ç¬¦ä¸² "TEST" è½¬æ¢ä¸ºå°å†™
	p("ToLower:   ", s.ToLower("TEST"))
	//å°†å­—ç¬¦ä¸² "test" è½¬æ¢ä¸ºå¤§å†™
	p("ToUpper:   ", s.ToUpper("test"))
}

```

##### å­—ç¬¦ä¸²æ ¼å¼åŒ–

ä½¿ç”¨fmt.Printfè¿›è¡Œè¾“å‡ºæ—¶çš„ä¸€äº›è¾“å‡ºæ ¼å¼

```go
package main

import (
	"fmt"
	"os"
)

type point struct {
	x, y int
}

func main() {

	p := point{1, 2}
	//struct1: {1 2}ï¼Œä»¥é»˜è®¤æ ¼å¼æ‰“å° p
	fmt.Printf("struct1: %v\n", p)
	//struct2: {x:1 y:2}ï¼Œç»“æ„ä½“å­—æ®µå + å€¼
	fmt.Printf("struct2: %+v\n", p)
	//struct3: main.point{x:1, y:2}ï¼Œä»¥ Go è¯­æ³•çš„æ–¹å¼æ‰“å° p
	fmt.Printf("struct3: %#v\n", p)
	//type: main.pointï¼Œæ‰“å°å˜é‡çš„ç±»å‹
	fmt.Printf("type: %T\n", p)
	//bool: trueï¼Œæ‰“å°å¸ƒå°”å€¼ true æˆ– false
	fmt.Printf("bool: %t\n", true)
	//int: 123ï¼Œä»¥åè¿›åˆ¶æ ¼å¼æ‰“å°æ•´æ•°
	fmt.Printf("int: %d\n", 123)
	//bin: 1110ï¼Œä»¥äºŒè¿›åˆ¶æ ¼å¼æ‰“å°æ•´æ•°
	fmt.Printf("bin: %b\n", 14)
	//char: !ï¼Œæ‰“å°å¯¹åº” Unicode ç ç‚¹çš„å­—ç¬¦ï¼ˆ33 å¯¹åº” !ï¼‰ã€‚
	fmt.Printf("char: %c\n", 33)
	//hex: 1c8ï¼Œä»¥å°å†™åå…­è¿›åˆ¶æ‰“å°æ•´æ•°
	fmt.Printf("hex: %x\n", 456)
	//float1: 78.900000ï¼Œä»¥æµ®ç‚¹æ•°æ ¼å¼ï¼ˆå°æ•°ç‚¹å½¢å¼ï¼‰æ‰“å°
	fmt.Printf("float1: %f\n", 78.9)
	//float2: 1.234000e+08ï¼Œä»¥ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤º
	fmt.Printf("float2: %e\n", 123400000.0)
	fmt.Printf("float3: %E\n", 123400000.0)
	//str1: "string"ï¼Œæ‰“å°å­—ç¬¦ä¸²
	fmt.Printf("str1: %s\n", "\"string\"")
	//str2: "\"string\""ï¼Œä»¥å¸¦å¼•å·çš„å­—ç¬¦ä¸²æ ¼å¼æ‰“å°
	fmt.Printf("str2: %q\n", "\"string\"")
	//str3: 6865782074686973ï¼Œä»¥åå…­è¿›åˆ¶æ ¼å¼æ‰“å°å­—ç¬¦ä¸²çš„å­—èŠ‚å€¼
	fmt.Printf("str3: %x\n", "hex this")
	//pointer: 0xc00000e0c0ï¼Œä»¥åå…­è¿›åˆ¶æ ¼å¼æ‰“å°å˜é‡çš„å†…å­˜åœ°å€
	fmt.Printf("pointer: %p\n", &p)
	//width1: |    12|   345|ï¼Œä»¥å®½åº¦ 6 å³å¯¹é½æ‰“å°æ•´æ•°ï¼Œä¸è¶³éƒ¨åˆ†å¡«å……ç©ºæ ¼
	fmt.Printf("width1: |%6d|%6d|\n", 12, 345)
	//width2: |  1.20|  3.45|ï¼Œä»¥å®½åº¦ 6 å³å¯¹é½ï¼Œä¿ç•™ 2 ä½å°æ•°
	fmt.Printf("width2: |%6.2f|%6.2f|\n", 1.2, 3.45)
	//width3: |1.20  |3.45  |ï¼Œä»¥å®½åº¦ 6 å·¦å¯¹é½ï¼Œä¿ç•™ 2 ä½å°æ•°
	fmt.Printf("width3: |%-6.2f|%-6.2f|\n", 1.2, 3.45)
	//width4: |   foo|     b|ï¼Œå³å¯¹é½å­—ç¬¦ä¸²ï¼Œå®½åº¦ 6
	fmt.Printf("width4: |%6s|%6s|\n", "foo", "b")
	//width5: |foo   |b     |ï¼Œå·¦å¯¹é½å­—ç¬¦ä¸²ï¼Œå®½åº¦ 6
	fmt.Printf("width5: |%-6s|%-6s|\n", "foo", "b")
	//sprintf: a stringï¼Œå°†æ ¼å¼åŒ–ç»“æœå­˜å‚¨ä¸ºå­—ç¬¦ä¸²ï¼Œä¸è¾“å‡º
	s := fmt.Sprintf("sprintf: a %s", "string")
	fmt.Println(s)
	//io: an errorï¼Œæ ¼å¼åŒ–ç»“æœè¾“å‡ºåˆ°æŒ‡å®šçš„ io.Writerï¼ˆè¿™é‡Œæ˜¯ os.Stderrï¼‰
	fmt.Fprintf(os.Stderr, "io: an %s\n", "error")
}

```

##### text/template

ä½¿ç”¨ `text/template` åŒ…åˆ›å»ºå’Œè§£ææ¨¡æ¿ï¼Œç„¶åå°†ä¸åŒçš„æ•°æ®å¡«å……åˆ°æ¨¡æ¿ä¸­è¿›è¡Œæ ¼å¼åŒ–è¾“å‡º

```go
package main

import (
    "os"
    "text/template"
)

func main() {
    //åˆ›å»ºåä¸º t1 çš„æ¨¡æ¿
    t1 := template.New("t1")
    //Parse("Value is {{.}}\n") è§£ææ¨¡æ¿å­—ç¬¦ä¸²
    //{{.}} ä»£è¡¨æ¨¡æ¿ä¸­çš„æ•°æ®ï¼Œä¼šè¢« Execute() æ—¶æä¾›çš„æ•°æ®æ›¿æ¢
    t1, err := t1.Parse("Value is {{.}}\n")
    if err != nil {
       panic(err)
    }
    //template.Must() ç¡®ä¿æ¨¡æ¿è§£ææˆåŠŸï¼Œå¦‚æœå¤±è´¥å°±ä¼šè°ƒç”¨panicç»ˆæ­¢ç¨‹åº
    t1 = template.Must(t1.Parse("Value: {{.}}\n"))
    //è¿™é‡Œå°±æ˜¯å¯¹å‰é¢çš„t1æ¨¡ç‰ˆè¿›è¡Œå¡«å……æ•°æ®
    //"some text" è¢«æ›¿æ¢åˆ° {{.}}
    t1.Execute(os.Stdout, "some text")
    //5 è¢«æ›¿æ¢åˆ° {{.}}
    t1.Execute(os.Stdout, 5)
    //[]string{"Go", "Rust", "C++", "C#"} å°† []string ä½œä¸ºä¸€ä¸ªæ•´ä½“è¢«æ‰“å°
    t1.Execute(os.Stdout, []string{
       "Go",
       "Rust",
       "C++",
       "C#",
    })
    //Create å‡½æ•°æ˜¯ä¸€ä¸ªæ¨¡æ¿è¾…åŠ©å‡½æ•°ï¼Œå¯ä»¥æ ¹æ® name å’Œ t åˆ›å»ºå¹¶è§£æä¸€ä¸ªæ–°æ¨¡æ¿
    //template.Must() ä¿è¯è§£ææˆåŠŸ
    Create := func(name, t string) *template.Template {
       return template.Must(template.New(name).Parse(t))
    }
    //ä½¿ç”¨æ¨¡ç‰ˆè¾…åŠ©å‡½æ•°åˆ›å»ºäº†t2æ¨¡ç‰ˆ
    t2 := Create("t2", "Name: {{.Name}}\n")
    //ä½¿ç”¨ç»“æ„ä½“å¯¹t2æ¨¡ç‰ˆå¡«å……æ•°æ®
    //è¾“å‡ºName: Jane Doe
    t2.Execute(os.Stdout, struct {
       Name string
    }{"Jane Doe"})
    //ä½¿ç”¨mapå¯¹æ¨¡ç‰ˆå¡«å……æ•°æ®
    //è¾“å‡ºName: Mickey Mouse
    t2.Execute(os.Stdout, map[string]string{
       "Name": "Mickey Mouse",
    })
    //åˆ›å»ºifåˆ¤æ–­çš„æ¨¡ç‰ˆ
    t3 := Create("t3",
       "{{if . -}} yes {{else -}} no {{end}}\n")
    t3.Execute(os.Stdout, "not empty")
    t3.Execute(os.Stdout, "")
    //åˆ›å»ºrangeéå†çš„æ¨¡ç‰ˆ
    t4 := Create("t4",
       "Range: {{range .}}{{.}} {{end}}\n")
    t4.Execute(os.Stdout,
       []string{
          "Go",
          "Rust",
          "C++",
          "C#",
       })
}
```

##### æ­£åˆ™è¡¨è¾¾å¼

ä¸‹é¢æ˜¯å…³äºæ­£åˆ™çš„ä¸€äº›å‡½æ•°ä½¿ç”¨

```go
package main

import (
    "bytes"
    "fmt"
    "regexp"
)

func main() {

    //pï¼šåŒ¹é…å­—ç¬¦ p,([a-z]+)ï¼šåŒ¹é…ä¸€ä¸ªæˆ–å¤šä¸ªå°å†™å­—æ¯ï¼Œä½œä¸ºæ•è·ç»„,chï¼šåŒ¹é…å­—ç¬¦ ch
    //å³æŸ¥æ‰¾ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¸”ä»¥på¼€å¤´ï¼Œchç»“å°¾
    //peachä¸­å«æœ‰pï¼Œæ•…åŒ¹é…è¯¥æ¨¡å¼ï¼Œå› æ­¤ match è¿”å› trueã€‚
    match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
    fmt.Println(match)
    //Compile() è§£ææ­£åˆ™è¡¨è¾¾å¼å¹¶è¿”å› *Regexp å¯¹è±¡ rï¼Œåç»­å¯ä»¥ä½¿ç”¨ r è¿›è¡ŒåŒ¹é…å’ŒæŸ¥æ‰¾
    r, _ := regexp.Compile("p([a-z]+)ch")
    //ä½¿ç”¨rè¿›è¡Œæ­£åˆ™åŒ¹é…ï¼Œè¿”å› trueã€‚
    fmt.Println(r.MatchString("peach"))
    //æŸ¥æ‰¾ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹ï¼šr.FindString()ï¼Œpeachæ˜¯ç¬¬ä¸€ä¸ªï¼Œæ‰€ä»¥è¿”å›peach
    fmt.Println(r.FindString("peach punch"))
    //r.FindStringIndex("peach punch")ï¼šè¿”å›ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„èµ·å§‹å’Œç»“æŸç´¢å¼•ã€‚
    //peachåœ¨0-5çš„ä½ç½®ï¼Œæ‰€ä»¥è¾“å‡º[0,5]
    fmt.Println("idx:", r.FindStringIndex("peach punch"))
    //è¿™é‡Œè¦æ±‚è¿”å›åŒ¹é…å­—ç¬¦ä¸²å’Œæ•è·ç»„ï¼ˆpå’Œchä¹‹é—´çš„å­—ç¬¦ä¸²ï¼‰
    //è¾“å‡º[peach ea]
    fmt.Println(r.FindStringSubmatch("peach punch"))
    //è¿”å›åŒ¹é…å­—ç¬¦ä¸²å’Œæ•è·ç»„çš„ç´¢å¼•
    //[0 5 1 3]
    fmt.Println(r.FindStringSubmatchIndex("peach punch"))
    //r.FindAllString() æ‰¾åˆ°æ‰€æœ‰åŒ¹é…é¡¹ï¼Œ-1 ä½œä¸º n çš„å€¼ï¼Œè¡¨ç¤ºè¿”å›æ‰€æœ‰åŒ¹é…é¡¹
    //[peach punch pinch]
    fmt.Println(r.FindAllString("peach punch pinch", -1))
    //è¿”å›æ‰€æœ‰åŒ¹é…é¡¹çš„ç´¢å¼•
    fmt.Println("all:", r.FindAllStringSubmatchIndex(
       "peach punch pinch", -1))
    //2ä»£è¡¨åªè¿”å›æ‰¾åˆ°æœ€å¤š 2 ä¸ªåŒ¹é…é¡¹
    fmt.Println(r.FindAllString("peach punch pinch", 2))
    //åŒ¹é… byte åˆ‡ç‰‡ï¼Œè¿”å›true
    fmt.Println(r.Match([]byte("peach")))
    //å’Œregexp.Compileæ•ˆæœå·®ä¸å¤šï¼Œä½†æ˜¯å½“é‡åˆ°åŒ¹é…ä¸åˆ°çš„æ—¶å€™ä¼španic
    r = regexp.MustCompile("p([a-z]+)ch")
    fmt.Println("regexp:", r)
    //å­—ç¬¦ä¸²æ›¿æ¢ï¼Œå°† peach æ›¿æ¢ä¸º <fruit>
    //è¾“å‡º  a <fruit>
    fmt.Println(r.ReplaceAllString("a peach", "<fruit>"))
    //r.ReplaceAllFunc() å°†åŒ¹é…é¡¹é€šè¿‡ bytes.ToUpper è¿›è¡Œè½¬æ¢
    in := []byte("a peach")
    out := r.ReplaceAllFunc(in, bytes.ToUpper)
    //è¾“å‡º a PEACH
    fmt.Println(string(out))
}
```

##### JSON

å°†åŸºæœ¬æ•°æ®ç±»å‹ã€åˆ‡ç‰‡ã€mapã€ç»“æ„ä½“ç¼–ç ä¸º JSONï¼ˆ`Marshal`ï¼‰ã€‚

å°† JSON å­—ç¬¦ä¸²è§£ç ä¸º Go ç»“æ„ä½“æˆ– mapï¼ˆ`Unmarshal`ï¼‰ã€‚

é€šè¿‡ `Encoder` å’Œ `Decoder` è¿›è¡Œ JSON çš„æµå¼ç¼–ç å’Œè§£ç ã€‚

```go
package main

import (
    "encoding/json"
    "fmt"
    "os"
    "strings"
)

type response1 struct {
    Page   int
    Fruits []string
}

type response2 struct {
    Page   int      `json:"page"`
    Fruits []string `json:"fruits"`
}

func main() {
    //å°†å¸ƒå°”å€¼ true ç¼–ç ä¸º JSON
    bolB, _ := json.Marshal(true)
    fmt.Println(string(bolB))
    //å°†æ•´æ•° 1 ç¼–ç ä¸º JSON
    intB, _ := json.Marshal(1)
    fmt.Println(string(intB))
    //å°†æµ®ç‚¹æ•° 2.34 ç¼–ç ä¸º JSON
    fltB, _ := json.Marshal(2.34)
    fmt.Println(string(fltB))
    //å°†å­—ç¬¦ä¸² gopher ç¼–ç ä¸º JSON
    strB, _ := json.Marshal("gopher")
    fmt.Println(string(strB))
    //å°†å­—ç¬¦ä¸²åˆ‡ç‰‡ç¼–ç ä¸º JSON
    slcD := []string{"apple", "peach", "pear"}
    slcB, _ := json.Marshal(slcD)
    fmt.Println(string(slcB))
    //å°† map ç¼–ç ä¸º JSON
    mapD := map[string]int{"apple": 5, "lettuce": 7}
    mapB, _ := json.Marshal(mapD)
    fmt.Println(string(mapB))
    //ç»“æ„ä½“æ²¡æœ‰ä½¿ç”¨ JSON æ ‡ç­¾ï¼Œæ‰€ä»¥å­—æ®µåä»¥å¤§å†™å½¢å¼è¾“å‡º
    //è¾“å‡º  {"Page":1,"Fruits":["apple","peach","pear"]}
    //è¿™é‡Œè¦å°†å€¼ä¼ ç»™json.Marshalï¼Œä½¿ç”¨æŒ‡é’ˆå¯ä»¥é¿å…æ‹·è´æ•´ä¸ªç»“æ„ä½“æ•°æ®
    res1D := &response1{
       Page:   1,
       Fruits: []string{"apple", "peach", "pear"}}
    res1B, _ := json.Marshal(res1D)
    fmt.Println(string(res1B))
    //response2 ä½¿ç”¨äº† json æ ‡ç­¾ï¼š Page è¢«æ˜ å°„ä¸º page Fruits è¢«æ˜ å°„ä¸º fruits
    //è¾“å‡º  {"page":1,"fruits":["apple","peach","pear"]}
    res2D := &response2{
       Page:   1,
       Fruits: []string{"apple", "peach", "pear"}}
    res2B, _ := json.Marshal(res2D)
    fmt.Println(string(res2B))

    byt := []byte(`{"num":6.13,"strs":["a","b"]}`)

    //interface{} ä½œä¸ºå€¼çš„ç±»å‹ï¼Œè¡¨ç¤ºé”®å¯¹åº”çš„å€¼å¯ä»¥æ˜¯ä»»æ„ç±»å‹
    var dat map[string]interface{}
    //å°† JSON å­—èŠ‚æ•°ç»„è§£æä¸º map
    if err := json.Unmarshal(byt, &dat); err != nil {
       panic(err)
    }
    fmt.Println(dat)
    //dat["num"] è¢«è§£æä¸º float64ï¼Œé€šè¿‡ç±»å‹æ–­è¨€è®¿é—®
    num := dat["num"].(float64)
    fmt.Println(num)

    strs := dat["strs"].([]interface{})
    str1 := strs[0].(string)
    fmt.Println(str1)
    //å°† JSON è§£æåˆ° res
    //è¿™é‡Œä¸éœ€è¦ä¿®æ”¹æ•°æ®ä¹‹ç±»çš„ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥æ˜¯å€¼ç±»å‹
    str := `{"page": 1, "fruits": ["apple", "peach"]}`
    res := response2{}
    json.Unmarshal([]byte(str), &res)
    fmt.Println(res)
    fmt.Println(res.Fruits[0])

    //å®ƒå°†æ•°æ®ç¼–ç æˆ JSON æ ¼å¼ï¼Œå¹¶å†™å…¥åˆ°æŒ‡å®šçš„ io.Writer
    enc := json.NewEncoder(os.Stdout)
    d := map[string]int{"apple": 5, "lettuce": 7}
    //enc.Encode(d) å°† d ç¼–ç ä¸º JSON å¹¶å†™å…¥æ ‡å‡†è¾“å‡º
    enc.Encode(d)
    //å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º io.Reader
    dec := json.NewDecoder(strings.NewReader(str))
    //è§£æ JSON å¹¶å­˜å‚¨åˆ° res1
    res1 := response2{}
    dec.Decode(&res1)
    fmt.Println(res1)
}
```

##### XML

```go
package main

import (
    "encoding/xml"
    "fmt"
)

type Plant struct {
    //æŒ‡å®š XML æ ¹å…ƒç´ çš„åç§°ä¸º <plant>...<plant/>
    XMLName xml.Name `xml:"plant"`
    //å°† Id ç¼–ç ä¸º XML å±æ€§
    Id int `xml:"id,attr"`
    //å°† Name æ˜ å°„åˆ° XML æ ‡ç­¾ <name>
    Name   string   `xml:"name"`
    Origin []string `xml:"origin"`
}

// fmt.Stringer æ¥å£åªæœ‰ä¸€ä¸ªæ–¹æ³•
func (p Plant) String() string {
    return fmt.Sprintf("Plant id=%v, name=%v, origin=%v",
       p.Id, p.Name, p.Origin)
}

func main() {
    //åˆ›å»º Plant å®ä¾‹
    coffee := &Plant{Id: 27, Name: "Coffee"}
    coffee.Origin = []string{"Ethiopia", "Brazil"}
    //å°† coffee ç»“æ„ä½“ç¼–ç ä¸ºæ ¼å¼åŒ–çš„ XML
    out, _ := xml.MarshalIndent(coffee, " ", "  ")
    /*
     <plant id="27">
       <name>Coffee</name>
       <origin>Ethiopia</origin>
       <origin>Brazil</origin>
     </plant>

    */
    fmt.Println(string(out))
    //æ·»åŠ  XML å¤´ä¿¡æ¯
    fmt.Println(xml.Header + string(out))

    var p Plant
    //è§£æ XML æ•°æ®åˆ° Plant ç»“æ„ä½“
    if err := xml.Unmarshal(out, &p); err != nil {
       panic(err)
    }
    fmt.Println(p)

    tomato := &Plant{Id: 81, Name: "Tomato"}
    tomato.Origin = []string{"Mexico", "California"}

    //å®šä¹‰åµŒå¥—ç»“æ„ Nesting
    type Nesting struct {
       XMLName xml.Name `xml:"nesting"`
       Plants  []*Plant `xml:"parent>child>plant"`
    }

    nesting := &Nesting{}
    nesting.Plants = []*Plant{coffee, tomato}
    //ç¼–ç åµŒå¥— XML ç»“æ„
    //xml.MarshalIndent() å°† nesting ç»“æ„ä½“ç¼–ç ä¸ºæ ¼å¼åŒ–çš„ XML å­—ç¬¦ä¸²
    out, _ = xml.MarshalIndent(nesting, " ", "  ")
    fmt.Println(string(out))
}
```

##### time

å…³äºæ—¶é—´ç±»çš„ä¸€äº›ç”¨æ³•

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	p := fmt.Println
	//è¿”å›å½“å‰çš„æœ¬åœ°æ—¶é—´ï¼Œç±»å‹ä¸º time.Time
	now := time.Now()
	p(now)
	//time.Date() åˆ›å»ºä¸€ä¸ªç‰¹å®šçš„æ—¶é—´
	then := time.Date(
		2009, 11, 17, 20, 34, 58, 651387237, time.UTC)
	p(then)

	p(then.Year())
	p(then.Month())
	p(then.Day())
	p(then.Hour())
	p(then.Minute())
	p(then.Second())
	p(then.Nanosecond())
	//è·å–æ—¶åŒº
	p(then.Location())

	p(then.Weekday())
	////æ—¶é—´æ¯”è¾ƒï¼Œè¿”å›å¸ƒå°”å€¼
	p(then.Before(now))
	p(then.After(now))
	p(then.Equal(now))
	//è®¡ç®—æ—¶é—´å·®
	diff := now.Sub(then)
	p(diff)
	//å°†æ—¶é—´å·®è½¬æ¢ä¸ºä¸åŒå•ä½
	p(diff.Hours())
	p(diff.Minutes())
	p(diff.Seconds())
	p(diff.Nanoseconds())
	//å‘ then æ·»åŠ  diff æ—¶é—´å·®ã€‚
	p(then.Add(diff))
	p(then.Add(-diff))
}

```

##### Epoch





### å¹¶å‘

##### Goroutines

goroutineæ˜¯ä¸€ä¸ªè½»é‡çº§çš„æ‰§è¡Œçº¿ç¨‹

```go
package main

import (
	"fmt"
	"time"
)

func ff(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
	}
}

func main() {
	//è¿™æ˜¯ä¸€ä¸ªæ™®é€šçš„å‡½æ•°è°ƒç”¨ï¼Œè¿è¡Œåœ¨ main goroutine ä¸­
	//å› æ­¤å®ƒä¼šé¡ºåºæ‰§è¡Œå¹¶å®Œæˆåæ‰ç»§ç»­å‘ä¸‹æ‰§è¡Œ
	ff("direct")

	//main çº¿ç¨‹ä¸ä¼šç­‰å¾…å®ƒå®Œæˆï¼Œç›´æ¥ç»§ç»­æ‰§è¡Œä¸‹ä¸€è¡Œä»£ç ã€‚
	go ff("goroutine")

	//å¯åŠ¨ä¸€ä¸ª goroutine è¿›è¡ŒåŒ¿åå‡½æ•°è°ƒç”¨
	go func(msg string) {
		fmt.Println(msg)
	}("going")

	//è¿™ä¸ª Sleep çš„ç›®çš„æ˜¯ç»™ goroutine è¿è¡Œçš„æ—¶é—´
	//å¦åˆ™ main å¯èƒ½ä¼šç›´æ¥ç»“æŸï¼Œå¯¼è‡´ goroutine æ²¡æœºä¼šè¿è¡Œ
	//å³ä½¿æ˜¯goroutineæ­£åœ¨æ‰§è¡Œï¼Œåªè¦ä¸»çº¿ç¨‹ç»“æŸï¼Œgoroutineä¹Ÿä¼šè¢«ä¸­æ–­
	time.Sleep(time.Second)
	fmt.Println("done")
}

```

ä½†æ˜¯è¿™é‡Œä½¿ç”¨çš„sleepæ–¹æ³•ä¸å¤ªå¥½ï¼Œæœ€å¥½è¿˜æ˜¯ä½¿ç”¨waitgroup

```go
package main

import (
	"fmt"
	"sync"
)

func ff(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
	}
}

func main() {
	//ä½¿ç”¨waitgroupçš„æ–¹å¼
	var wg sync.WaitGroup

	ff("direct")
	//æ·»åŠ ä¸¤ä¸ªè¦ç­‰å¾…çš„goroutine
	wg.Add(2)

	go func() {
		//è¿™é‡Œéœ€è¦åŠ wg.Done()ï¼Œç”¨äºwgçš„è®¡æ•°ï¼Œè¦ä¸¤æ¬¡ä¸»çº¿ç¨‹æ‰ä¼šç»“æŸç­‰å¾…ï¼Œå¦åˆ™å°±ä¼šæ­»é”
		defer wg.Done()
		ff("goroutine")
	}()

	go func(msg string) {
		defer wg.Done()
		fmt.Println(msg)
	}("going")
	//ä¸»çº¿ç¨‹åœ¨è¿™ä¸ªä½ç½®ç­‰å¾…
	wg.Wait()
	fmt.Println("done")
}

```

##### Channels

Channelç”¨äºgoroutineä¹‹é—´çš„æ¶ˆæ¯é€šä¿¡

æ— ç¼“å†²é€šé“ä¼šé˜»å¡å‘é€æ–¹å’Œæ¥æ”¶æ–¹ï¼Œä¼šä¸€ç›´ç­‰å¾…å‘é€æ–¹å’Œæ¥æ”¶æ–¹éƒ½å‡†å¤‡å¥½äº†ï¼Œä¸¤è¾¹æ‰ä¼šè§£é™¤é˜»å¡ï¼Œè¿›è¡Œæ‰§è¡Œä¸‹å»

**ä¸‹é¢æ‰§è¡Œè¿‡ç¨‹åˆ†æ**

- **Step 1**: `go func() { messages <- "ping" }()` å¯åŠ¨ä¸€ä¸ª goroutineï¼Œå¹¶è¯•å›¾å‘é€ `"ping"`ã€‚
- **Step 2**: **ç”±äº `messages` æ˜¯æ— ç¼“å†²é€šé“ï¼Œ`messages <- "ping"` ä¸èƒ½ç«‹å³å®Œæˆ**ï¼Œå®ƒå¿…é¡»ç­‰ `msg := <-messages` æ‰§è¡Œæ—¶ï¼Œæ‰ä¼šçœŸæ­£å‘é€æ•°æ®ã€‚
- **Step 3**: `msg := <-messages` åœ¨ `main` goroutine ä¸­æ‰§è¡Œï¼Œæ­¤æ—¶ `messages <- "ping"` **è§£é™¤é˜»å¡**ï¼Œæ•°æ®ä¼ é€’å‘ç”Ÿï¼Œä¸¤ä¸ª goroutine åŒæ—¶ç»§ç»­æ‰§è¡Œã€‚
- **Step 4**: `"ping"` è¢«æ‰“å°ï¼Œç¨‹åºç»“æŸã€‚

```go
package main

import "fmt"

func main() {

	//è¿™åˆ›å»ºäº†ä¸€ä¸ªæ— ç¼“å†²é€šé“ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå‘é€å’Œæ¥æ”¶æ“ä½œéƒ½ä¼šé˜»å¡ï¼Œç›´åˆ°å¯¹æ–¹å‡†å¤‡å¥½
	messages := make(chan string)

	//åˆ›å»ºä¸€ä¸ªgoroutineï¼Œå°†æ¶ˆæ¯ä¼ å…¥é€šé“
	//ç”±äº messages æ˜¯æ— ç¼“å†²é€šé“ï¼Œå‘é€æ“ä½œä¼šé˜»å¡ï¼Œç›´åˆ° main çº¿ç¨‹æ¥æ”¶æ•°æ®
	go func() { messages <- "ping" }()
	//å°†æ¶ˆæ¯ä»é€šé“ä¸­å–å‡ºæ¥
	//main çº¿ç¨‹åœ¨è¿™é‡Œé˜»å¡ï¼Œç­‰å¾… messages é€šé“é‡Œæœ‰æ•°æ®
	msg := <-messages
	fmt.Println(msg)
}

```

##### ç¼“å†²é€šé“

ğŸ”¹ **æ— ç¼“å†²é€šé“ = ç”Ÿäº§è€… & æ¶ˆè´¹è€…å¿…é¡»åŒæ—¶å°±ç»ª** 

ğŸ”¹ **å¸¦ç¼“å†²é€šé“ = å…è®¸ç”Ÿäº§è€…å…ˆå­˜å‚¨æ•°æ®ï¼Œæ¶ˆè´¹è€…ç¨åå–å‡º**

å¯¹äºç¼“å†²é€šé“è€Œè¨€ï¼Œå¦‚æœé€šé“ä¸ºç©ºï¼Œé‚£å°±ä¼šé˜»å¡æ¶ˆè´¹è€…ï¼Œå¦‚æœé€šé“æ˜¯æ»¡çš„ï¼Œå°±ä¼šé˜»å¡ç”Ÿäº§è€…

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	messages := make(chan string, 2) // åˆ›å»ºä¸€ä¸ªç¼“å†²åŒºå¤§å°ä¸º 2 çš„é€šé“

	// ç”Ÿäº§è€… goroutine
	go func() {
		messages <- "hello"
		fmt.Println("Sent: hello") // ç«‹å³æ‰§è¡Œï¼Œä¸ä¼šé˜»å¡
		messages <- "world"
		fmt.Println("Sent: world") // ç«‹å³æ‰§è¡Œï¼Œä¸ä¼šé˜»å¡
		// ç”±äºç¼“å†²åŒºå·²æ»¡ï¼Œä¸‹é¢çš„å‘é€ä¼šé˜»å¡ï¼Œç›´åˆ°æœ‰æ¶ˆè´¹è€…æ¥æ”¶æ•°æ®
		messages <- "!"
		fmt.Println("Sent: !") // è¿™è¡Œä»£ç ä¼šç­‰å¾…
	}()

	// è®©ç”Ÿäº§è€…å…ˆæ‰§è¡Œä¸€ä¼šå„¿
	time.Sleep(2 * time.Second)

	// æ¶ˆè´¹è€…å–å‡ºæ•°æ®
	fmt.Println("Received:", <-messages)
	fmt.Println("Received:", <-messages)
	fmt.Println("Received:", <-messages) // è¿™é‡Œæ‰ä¼šè§£é™¤ç¬¬ä¸‰ä¸ªæ¶ˆæ¯çš„é˜»å¡
}

```

æ­£å¸¸æƒ…å†µä¸‹**ç”Ÿäº§è€…** å’Œ **æ¶ˆè´¹è€…** åªèƒ½**ä¸€æ¬¡å‘é€æˆ–æ¥æ”¶ä¸€ä¸ªæ•°æ®**ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡ä¼ åˆ‡ç‰‡ã€æˆ–è€…ä½¿ç”¨range é€šé“çš„æ–¹å¼ä¸€æ¬¡ä¼ é€’æˆ–è€…æ¥æ”¶å¤šä¸ªæ•°æ®

##### é€šé“åŒæ­¥

é€šè¿‡è®©ä¸»çº¿ç¨‹ä½œä¸ºæ¥æ”¶è€…é˜»å¡æ¥æ”¶æ¶ˆæ¯æ¥è¾¾åˆ°çº¿ç¨‹çš„åŒæ­¥

```go
package main

import (
	"fmt"
	"time"
)

func worker(done chan bool) {
	fmt.Println("worker")
	time.Sleep(time.Second)
	fmt.Println("done")

	done <- true

}

func main() {
	done := make(chan bool, 1)
	go worker(done)
	<-done

}

```

##### é€šé“æ–¹å‘

å½“ä½¿ç”¨é€šé“ä½œä¸ºå‡½æ•°å‚æ•°æ—¶ï¼Œå¯ä»¥æŒ‡å®šé€šé“çš„æ–¹å‘ï¼Œæ¥æé«˜ç¨‹åºçš„å®‰å…¨æ€§

```go
package main

import "fmt"

func ping(pings chan<- string, msg string) {
	pings <- msg
}

func pong(pings <-chan string, pongs chan<- string) {
	msg := <-pings
	pongs <- msg
}

func main() {
	pings := make(chan string, 1)
	pongs := make(chan string, 1)
	ping(pings, "passed message")
	pong(pings, pongs)
	fmt.Println(<-pongs)
}

```

##### select

å°†channelå’Œselectç»“åˆèµ·æ¥

`select` è¯­å¥ä½¿å¾—ä¸€ä¸ª goroutine å¯ä»¥ç­‰å¾…å¤šä¸ª **channel** çš„æ“ä½œï¼ˆæ¥æ”¶æˆ–å‘é€ï¼‰ã€‚å®ƒä¼š**é˜»å¡**ç›´åˆ°å…¶ä¸­ä¸€ä¸ª `case` å¯ä»¥æ‰§è¡Œï¼ˆå³æŸä¸ª channel å®Œæˆäº†æ¥æ”¶æˆ–å‘é€ï¼‰ã€‚å¦‚æœæœ‰å¤šä¸ª `case` åŒæ—¶å‡†å¤‡å¥½ï¼Œ`select` ä¼šéšæœºé€‰æ‹©å…¶ä¸­ä¸€ä¸ªæ‰§è¡Œ

```go
package main

import (
    "fmt"
    "time"
)

func main() {

    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 <- "two"
    }()
		//å¦‚æœå•ç‹¬æ¥æ”¶ä¸¤ä¸ªé‚£å°±ä¼š3sï¼Œè€Œä½¿ç”¨selectä¼šå¹¶è¡Œå¤„ç†ä¸¤ä¸ªé€šé“ï¼Œè¿™æ ·åªä¼šç”¨2s
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("received", msg1)
        case msg2 := <-c2:
            fmt.Println("received", msg2)
        }
    }
}
```

##### è¶…æ—¶

è¿™é‡Œæ˜¯æ¨¡æ‹Ÿä¸€ä¸ªè¶…æ—¶çš„åœºæ™¯ï¼Œå³åœ¨è°ƒç”¨å…¶ä»–åº”ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œè™½ç„¶éœ€è¦è¯¥åº”ç”¨çš„è¿”å›å€¼ï¼Œä½†æ˜¯ä¸»çº¿ç¨‹æœ‰æå…¶ä¸¥æ ¼çš„æ—¶é—´è¦æ±‚ï¼Œæ‰€ä»¥å½“è¶…è¿‡è§„å®šæ—¶é—´åï¼Œä¸»çº¿ç¨‹å°±ä¼šå†³å®šè¿›è¡Œè¶…æ—¶å¤„ç†ï¼Œæ”¾å¼ƒè¿”å›å€¼

è¿™é‡Œä½¿ç”¨åˆ°çš„å°±æ˜¯selectï¼Œ`<-time.After` ç­‰å¾…åœ¨ 1 ç§’çš„è¶…æ—¶åå‘é€å€¼

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	//è¿™é‡Œä½¿ç”¨çš„ç¼“å†²é€šé“ï¼Œè¿™æ ·goroutineåœ¨å°†æ•°æ®æ”¾å…¥é€šé“åï¼Œå°±å¯ä»¥ç»“æŸ
	c1 := make(chan string,1)
	go func() {
		//æ¨¡å‹åº”ç”¨éœ€è¦2sæ‰èƒ½è¿”å›ç»“æœ
		time.Sleep(2 * time.Second)
		c1 <- "result 1"
	}()
	//selectæ˜¯æ¯æ¬¡åªä¼šé€‰æ‹©ä¸€ä¸ªcaseé‡Œé¢çš„æ‰§è¡Œï¼Œç„¶åå°±ä¼šè·³è¿‡
	//æ‰€ä»¥è¿™é‡Œå³ä¾¿resæ²¡æœ‰ä»é€šé“ä¸­æ¥æ”¶å€¼ï¼Œä¹Ÿä¸ä¼šé˜»å¡ï¼Œåœ¨æ‰§è¡Œè¿‡è¶…æ—¶å¤„ç†ä¹‹åï¼Œå°±ä¼šå¾€ä¸‹è¿›è¡Œæ‰§è¡Œ
	select {
	case res := <-c1:
		fmt.Println(res)
    //å¦‚æœè¶…è¿‡1sï¼Œå°±ä¼šæ‰§è¡Œè¿™æ¡è¯­å¥ï¼Œè¿›è¡Œè¶…æ—¶å¤„ç†
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	}

	c2 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c2 <- "result 2"
	}()
	select {
	case res := <-c2:
		fmt.Println(res)
	case <-time.After(3 * time.Second):
		fmt.Println("timeout 2")
	}
}

/*
timeout 1
result 2
*/
```

##### éé˜»å¡é€šé“æ“ä½œ

`select` è¿˜å¯ä»¥é…åˆ `default` è¯­å¥æ¥å®ç° **éé˜»å¡æ“ä½œ**ã€‚å¦‚æœæ‰€æœ‰çš„ `case` éƒ½ä¸èƒ½ç«‹åˆ»æ‰§è¡Œï¼Œ`select` ä¼šè¿›å…¥ `default`ï¼Œé¿å…é˜»å¡

```go
package main

import "fmt"

func main() {
	messages := make(chan string)
	signals := make(chan bool)

	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	default:
		fmt.Println("no message received")
	}

	msg := "hi"
	select {
	case messages <- msg:
		fmt.Println("sent message", msg)
	default:
		fmt.Println("no message sent")
	}

	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	case sig := <-signals:
		fmt.Println("received signal", sig)
	default:
		fmt.Println("no activity")
	}
}

```

##### å…³é—­é€šé“

å…³é—­é€šé“å¯ä»¥ç”¨äºä¸çŸ¥é“é€šé“å†…å®¹æœ‰å¤šå°‘ï¼Œè¦ä½¿ç”¨forå¾ªç¯ä¸€ç›´æ¥æ”¶çš„æƒ…å†µ

```go
package main

import "fmt"

func main() {
	jobs := make(chan int, 5)
	done := make(chan bool)

	go func() {
    //è¿™é‡Œä½¿ç”¨æ­»å¾ªç¯ï¼Œä¸€ç›´ä»é€šé“ä¸­è·å–å€¼
    //åªæœ‰é€šé“å·²ç»å…³é—­ï¼Œä¸”æ²¡æœ‰å‰©ä½™æ•°æ®æ—¶çš„æ—¶å€™moreå°±ä¼šä¸ºfalse
		for {
      //ä½¿ç”¨çš„æ˜¯æœ‰ç¼“å†²çš„é€šé“ï¼Œæ‰€ä»¥ä½œä¸ºæ¥æ”¶è€…ï¼Œå½“é€šé“æœ‰å†…å®¹å°±ä¼šè¿›è¡Œä¸‹å»ï¼Œæ²¡æœ‰å°±ä¼šé˜»å¡
			j, more := <-jobs
			if more {
				fmt.Println("received job", j)
			} else {
				fmt.Println("received all jobs")
				done <- true
				return
			}
		}
	}()
	//å› ä¸ºä½¿ç”¨çš„æ˜¯ç¼“å†²é€šé“ï¼Œæ‰€ä»¥å¯ä»¥ä¸€æ¬¡æ€§å…¨æ”¾è¿›é€šé“ï¼Œå¾€ä¸‹èµ°ä¸‹å»
	for j := 1; j <= 3; j++ {
		jobs <- j
		fmt.Println("sent job", j)
	}
  //å…³é—­é€šé“
	close(jobs)
	fmt.Println("sent all jobs")
	//ä½¿ç”¨é€šé“é˜»å¡çš„æ–¹å¼ç­‰goroutineç»“æŸ
	<-done
	//åªæœ‰é€šé“å·²ç»å…³é—­ï¼Œä¸”æ²¡æœ‰å‰©ä½™æ•°æ®æ—¶ï¼Œokä¸ºfalse
	_, ok := <-jobs
	fmt.Println("received more jobs:", ok)
}
```

##### rangeé€šé“

```go
package main

import "fmt"

func main() {

	queue := make(chan string, 2)
	queue <- "one"
	queue <- "two"
	close(queue)
	//å…³é—­é€šé“åï¼Œä¹Ÿå¯ä»¥ç»§ç»­éå†ï¼Œä»é€šé“ä¸­å–å€¼
	for elem := range queue {
		fmt.Println(elem)
	}
}

```

##### è®¡æ•°å™¨

æˆ‘ä»¬ç»å¸¸å¸Œæœ›åœ¨æœªæ¥çš„æŸä¸ªæ—¶é—´ç‚¹æ‰§è¡Œ Go ä»£ç ï¼Œæˆ–è€…ä»¥æŸä¸ªé—´éš”é‡å¤æ‰§è¡Œã€‚Go çš„å†…ç½® *è®¡æ—¶å™¨*å’Œä»£ç è¡Œè·åŠŸèƒ½ä½¿è¿™ä¸¤é¡¹ä»»åŠ¡éƒ½å˜å¾—ç®€å•

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	//åˆ›å»ºäº†ä¸€ä¸ªå®šæ—¶å™¨ timer1ï¼Œå®ƒå°†åœ¨ 2 ç§’åè§¦å‘ï¼Œå¹¶é€šè¿‡ timer1.C å‘é€ä¸€ä¸ªå€¼
	timer1 := time.NewTimer(2 * time.Second)
	//ç”¨äºé˜»å¡å½“å‰ goroutineï¼Œç›´åˆ°å®šæ—¶å™¨çš„ channel C è¢«è§¦å‘ï¼ˆä¹Ÿå°±æ˜¯ 2 ç§’åï¼‰
	<-timer1.C
	fmt.Println("Timer 1 fired")

	timer2 := time.NewTimer(2 * time.Second)
	go func() {
		//ç„¶åå¯åŠ¨ä¸€ä¸ªæ–°çš„ goroutine æ¥ç›‘å¬ timer2.C
		//è¿™é‡Œå¦‚æœå®šæ—¶å™¨æ˜¯è¢«å…³é—­çš„ï¼Œé€šé“å°±ä¼šç«‹åˆ»å…³é—­ï¼Œè¿”å›0å€¼ï¼Œåé¢çš„å°±ä¸æ‰§è¡Œäº†
		fmt.Println("1")
		//è¯­å¥ç«‹å³è¿”å›å¹¶ç»§ç»­æ‰§è¡Œä»£ç ï¼Œdefer è¯­å¥ç¡®å®æ²¡æœ‰æœºä¼šæ‰§è¡Œ
		defer fmt.Println("2")
		<-timer2.C
		fmt.Println("Timer 2 fired")
	}()
	//è°ƒç”¨ä¼šå°è¯•åœæ­¢å®šæ—¶å™¨ã€‚
	//å¦‚æœå®šæ—¶å™¨è¿˜æ²¡æœ‰è§¦å‘ï¼Œå®ƒä¼šæˆåŠŸåœæ­¢ï¼Œè¿”å› trueã€‚
	//å¦‚æœå®šæ—¶å™¨å·²ç»è§¦å‘ï¼Œå®ƒä¼šè¿”å› false
	time.Sleep(time.Second)
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

	time.Sleep(2 * time.Second)
}
/*
Timer 1 fired
1
Timer 2 stopped
*/
```

##### ticker

timerç”¨äºæƒ³æœªæ¥æŸæ®µæ—¶é—´ååšä¸€ä»¶äº‹ï¼Œtickerç”¨äºæƒ³è¦å®šæœŸé‡å¤åšæŸä»¶äº‹

tickerå’Œtimeræœ‰ç±»ä¼¼çš„æœºåˆ¶ï¼Œé€šè¿‡é€šé“æ¥å‘é€æ¶ˆæ¯ï¼Œè¡¨ç¤ºçŠ¶æ€

```go
package main

import (
    "fmt"
    "time"
)

func main() {

    ticker := time.NewTicker(500 * time.Millisecond)
    done := make(chan bool)

    go func() {
       for {
          select {
          case <-done:
             return
          //æ¯éš”500 * time.Millisecondå‘é€ä¸€æ¬¡
          case t := <-ticker.C:
             fmt.Println("Tick at", t)
          }
       }
    }()
		//ä¸»çº¿ç¨‹ä¼šåœ¨è¿™é˜»å¡ä¸€æ®µæ—¶é—´ï¼Œä»¥ä¾¿tickerå¤šå‘é€å‡ æ¬¡
    time.Sleep(1600 * time.Millisecond)
  	//å…³é—­ticker
    ticker.Stop()
    done <- true
    fmt.Println("Ticker stopped")
}
```

##### worker-pools

 ä¸»è¦ç”¨äºå¤„ç†**å¤§é‡å¹¶å‘ä»»åŠ¡**ï¼ŒåŒæ—¶åˆè¦**æ§åˆ¶èµ„æºä½¿ç”¨**ã€‚

å®ƒè§£å†³çš„æ ¸å¿ƒé—®é¢˜æ˜¯ï¼š**æœ‰å¾ˆå¤šä»»åŠ¡è¦å¤„ç†ï¼Œä½†ä¸èƒ½æ— é™åˆ¶åœ°å¼€å¯ goroutine æˆ–çº¿ç¨‹ï¼Œå¦åˆ™ä¼šè€—å°½èµ„æº**ã€‚

æœ¬è´¨ä¸Šç›¸å½“äºjavaä¸­çš„çº¿ç¨‹æ± ï¼Œé€šè¿‡é€šé“æ¥ä¼ é€’ä»»åŠ¡ï¼Œè¿™æ®µä»£ç çš„ä½œç”¨å°±æ˜¯åˆ›å»ºäº†ä¸‰ä¸ªçº¿ç¨‹ï¼Œä¸æ–­çš„ä»jobsä¸­å–ä»»åŠ¡æ‰§è¡Œ

```go
package main

import (
    "fmt"
    "time"
)

func worker1(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
       fmt.Println("worker", id, "started job", j)
       time.Sleep(time.Second)
       fmt.Println("worker", id, "finished job", j)
       results <- j * 2
    }
}

func main() {
    const numJobs = 5
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)
    for w := 1; w <= 3; w++ {
      //å¯åŠ¨äº† 3 ä¸ªå¹¶å‘çš„ workerï¼ˆworker1 ~ worker3ï¼‰ï¼Œå®ƒä»¬å…±äº«åŒä¸€ä¸ª jobs é€šé“
       go worker1(w, jobs, results)
    }
    for j := 1; j <= numJobs; j++ {
      //å‘ jobs é€šé“å‘é€ 5 ä¸ªä»»åŠ¡ï¼ˆ1 åˆ° 5ï¼‰
       jobs <- j
    }
  	//å‘é€å®Œä»»åŠ¡åå…³é—­ jobs é€šé“ï¼Œé€šçŸ¥æ‰€æœ‰ worker æ²¡æœ‰ä»»åŠ¡äº†
    close(jobs)
    for a := 1; a <= numJobs; a++ {
      //ä¸»çº¿ç¨‹é€æ¬¡ä»é€šé“ä¸­æ‹¿å–ç»“æœï¼Œä¸»è¦ç”¨äºé˜»å¡ä¸»çº¿ç¨‹
       <-results
    }
}
```

##### WaitGroups

è¦ç­‰å¾…å¤šä¸ª goroutine å®Œæˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨WaitGroups

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker2(id int) {
	fmt.Printf("Worker %d starting\n", id)

	time.Sleep(time.Second)
	fmt.Printf("Worker %d done\n", id)
}

func main() {

	var wg sync.WaitGroup

	for i := 1; i <= 5; i++ {
		//å¯åŠ¨å¤šä¸ª goroutine å¹¶å¢åŠ æ¯ä¸ª goroutine çš„ WaitGroup è®¡æ•°å™¨
		wg.Add(1)
		//åˆ›å»ºä¸€ä¸ªé—­åŒ…ï¼Œè¿™ä¸ªçš„ç›®çš„æ˜¯å› ä¸ºwaitgroupéœ€è¦ä½¿ç”¨doneæ‰èƒ½ç®—ç»“æŸä¸€ä¸ª
		//æ‰€ä»¥æ˜¯éœ€è¦defer wg.Done()ï¼Œä¸ºäº†è§£å¶ï¼Œä¸å°†æ— å…³ä»£ç å†™åˆ°worker2ä¸­ï¼Œæ‰€ä»¥å°±å¦åˆ›å»ºäº†ä¸€ä¸ªfunc
		go func() {
			defer wg.Done()
			worker2(i)
		}()
	}

	wg.Wait()

}

```

##### é™æµ

åœ¨æœåŠ¡ç«¯å¤„ç†è¯·æ±‚æ—¶ï¼Œ**é™æµ**ç”¨äºé˜²æ­¢æœåŠ¡è¿‡è½½ã€‚å®ƒé€šè¿‡æ§åˆ¶å•ä½æ—¶é—´å†…å¤„ç†çš„è¯·æ±‚æ•°é‡ï¼Œé¿å…ç³»ç»Ÿèµ„æºè¢«è€—å°½ã€‚

Go çš„ `time.Tick` å’Œ `channel` çš„ç»„åˆå¯ä»¥å®ç°éå¸¸ç®€æ´çš„é™æµé€»è¾‘ã€‚

```go
package main

import (
    "fmt"
    "time"
)

func main() {

    //1ã€åŸºæœ¬é™æµ
    //åˆ›å»ºä¸€ä¸ªç¼“å†²é€šé“ requestsï¼Œæ¨¡æ‹Ÿè¦å¤„ç†çš„ 5 ä¸ªè¯·æ±‚ã€‚
    requests := make(chan int, 5)
    for i := 1; i <= 5; i++ {
       requests <- i
    }
    //ç”¨äºå…³é—­é€šé“ï¼Œå½“ä½ é€šè¿‡ range éå†é€šé“æ—¶ï¼Œå¦‚æœä¸å…³é—­é€šé“ï¼Œæ¥æ”¶æ–¹å°±æ— æ³•çŸ¥é“æ•°æ®ä½•æ—¶ç»“æŸ
    close(requests)
    //limiter æ˜¯ä¸€ä¸ªå®šæ—¶å™¨é€šé“ï¼Œæ¯ 200ms å‘å‡ºä¸€ä¸ªäº‹ä»¶ã€‚ä½œç”¨æ˜¯é™åˆ¶å¤„ç†é€Ÿç‡ä¸º æ¯ 200ms ä¸€ä¸ªè¯·æ±‚
    limiter := time.Tick(200 * time.Millisecond)

    //æ¯æ¬¡å¤„ç†è¯·æ±‚å‰ï¼Œä» limiter ä¸­è¯»å–ä¸€ä¸ªå€¼ï¼Œç›¸å½“äºâ€œç­‰å¾…è®¸å¯â€ï¼Œç¡®ä¿å¤„ç†é¢‘ç‡ä¸ä¼šè¶…è¿‡é™åˆ¶
    for req := range requests {
       <-limiter
       fmt.Println("request", req, time.Now())
    }
    //2ã€çªå‘é™æµ
    //åˆ›å»ºä¸€ä¸ªé™åˆ¶å™¨ï¼Œç±»ä¼¼äºåˆ›å»ºä¸€ä¸ªæ•°é‡ä¸º3çš„ä»¤ç‰Œæ¡¶
    burstyLimiter := make(chan time.Time, 3)

    for i := 0; i < 3; i++ {
       burstyLimiter <- time.Now()
    }
    //åå°åç¨‹æ¯ 200ms å‘ burstyLimiter æ·»åŠ ä¸€ä¸ªè®¸å¯ï¼ˆå¦‚æœæ²¡æ»¡ï¼‰ï¼Œä»¥ä¾¿æŒç»­è¡¥å……â€œçªå‘ä»¤ç‰Œâ€ã€‚
    go func() {
       for t := range time.Tick(200 * time.Millisecond) {
          burstyLimiter <- t
       }
    }()
    //åˆ›å»ºä¸€ä¸ªå¤§å°ä¸º5çš„ä»»åŠ¡éœ€æ±‚
    burstyRequests := make(chan int, 5)
    for i := 1; i <= 5; i++ {
       burstyRequests <- i
    }
    close(burstyRequests)
    //éå†ä»»åŠ¡éœ€æ±‚ï¼Œåªæœ‰åœ¨ä»¤ç‰Œæ¡¶ä¸­æœ‰ä»¤ç‰Œçš„æ—¶å€™ï¼Œæ‰ä¼šå»æ‰§è¡Œä»»åŠ¡ï¼Œä»¥æ­¤æ¥é™æµ
    for req := range burstyRequests {
       <-burstyLimiter
       fmt.Println("request", req, time.Now())
    }
}
```

##### åŸå­è®¡æ•°å™¨

ç”¨å¹¶å‘å®‰å…¨çš„æ–¹å¼ç»Ÿè®¡ä¸€ä¸ªå˜é‡åœ¨å¤šåç¨‹ä¸­è¢«ç´¯åŠ çš„æ€»æ¬¡æ•°

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

func main() {

    //å®šä¹‰ä¸€ä¸ª atomic.Uint64 ç±»å‹å˜é‡ ops
    //ç¡®ä¿å¤šçº¿ç¨‹ç¯å¢ƒä¸‹è¯»å†™å˜é‡æ˜¯åŸå­çš„ï¼Œå³ä¸å¯åˆ†å‰²çš„æ“ä½œï¼Œä¸ä¼šäº§ç”Ÿç«äº‰æ¡ä»¶ï¼ˆdata raceï¼‰
    var ops atomic.Uint64

    var wg sync.WaitGroup

    for i := 0; i < 50; i++ {
       wg.Add(1)

       go func() {
          for c := 0; c < 1000; c++ {
						
             ops.Add(1)
          }

          wg.Done()
       }()
    }

    wg.Wait()
		//50000
    fmt.Println("ops:", ops.Load())
}
```

##### äº’æ–¥é”

é€šè¿‡ `sync.Mutex` æ¥å®ç°**äº’æ–¥é”**ï¼Œç¡®ä¿å¤šä¸ª goroutine åœ¨å¹¶å‘ä¿®æ”¹èµ„æºæ—¶ä¸ä¼šå‘ç”Ÿæ•°æ®ç«äº‰

```go
package main

import (
    "fmt"
    "sync"
)

type Container struct {
    //äº’æ–¥é”ï¼Œä¿æŠ¤ counters å˜é‡
    mu sync.Mutex
    //å­˜å‚¨è®¡æ•°å™¨çš„ mapï¼Œé”®æ˜¯å­—ç¬¦ä¸²ï¼Œå€¼æ˜¯å¯¹åº”çš„è®¡æ•°
    counters map[string]int
}

func (c *Container) inc(name string) {
    //åŠ é”ï¼Œé˜²æ­¢å…¶ä»– goroutine åŒæ—¶è®¿é—® counters
    //è¿™æ ·ä¿è¯åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®map
    c.mu.Lock()
    defer c.mu.Unlock()
    c.counters[name]++
}

func main() {
    c := Container{

       counters: map[string]int{"a": 0, "b": 0},
    }

    var wg sync.WaitGroup
    //doIncrement æ˜¯ä¸€ä¸ªé—­åŒ…ï¼ˆclosureï¼‰ï¼Œç”¨äºé€’å¢æŒ‡å®š name çš„è®¡æ•°å™¨ n æ¬¡
    doIncrement := func(name string, n int) {
       for i := 0; i < n; i++ {
          c.inc(name)
       }
       wg.Done()
    }

    wg.Add(3)
    go doIncrement("a", 10000)
    go doIncrement("a", 10000)
    go doIncrement("b", 10000)

    wg.Wait()
    fmt.Println(c.counters)
}
```

##### çŠ¶æ€ Goroutines

åœ¨goä¸­ä¸ä»…å¯ä»¥ä½¿ç”¨äº’æ–¥é”æ¥å®ç°å¤šçº¿ç¨‹ä¸‹èµ„æºå…±äº«ï¼Œè¿˜å¯ä»¥ä½¿ç”¨goroutine å’Œé€šé“çš„å†…ç½®åŒæ­¥åŠŸèƒ½æ¥å®ç°ç›¸åŒçš„ç»“æœï¼Œé€šè¿‡é€šä¿¡å¹¶è®©æ¯æ®µæ•°æ®éƒ½å½’ 1 ä¸ª goroutine æ‰€æœ‰

è¿™ç§æ–¹å¼å®ç°å¹¶å‘å®‰å…¨çš„åŸç†æ˜¯é€šè¿‡å•ä¸ªgoroutineçš„funcæ¥ç®¡ç†stateè¿™ä¸ªèµ„æºï¼Œå…¶ä»–å¤šä¸ªgoroutinesæƒ³è¦è®¿é—®éƒ½æ˜¯é€šè¿‡å°†è¯·æ±‚æ”¾å…¥å¯¹åº”çš„é€šé“ä¸­ï¼Œç”±è¿™ä¸ªå•ä¸ªçš„goroutinueè¿›è¡Œå¤„ç†

```go
package main

import (
    "fmt"
    "math/rand"
    "sync/atomic"
    "time"
)

// ç”¨äºè¯»å– map çš„æ“ä½œ
type readOp struct {
    key int
    //ç”¨äºè¿”å›è¯»å–çš„å€¼
    resp chan int
}

// ç”¨äºå†™å…¥ map çš„æ“ä½œ
type writeOp struct {
    key int
    val int
    //ç”¨äºç¡®è®¤å†™å…¥æˆåŠŸ
    resp chan bool
}

func main() {
    //é€šè¿‡ atomic æ¥è¿›è¡ŒåŸå­è®¡æ•°ï¼Œç¡®ä¿å¹¶å‘å®‰å…¨
    var readOps uint64
    var writeOps uint64
    //ç”¨äºæ¥æ”¶è¯»è¯·æ±‚çš„é€šé“
    reads := make(chan readOp)
    //ç”¨äºæ¥æ”¶å†™è¯·æ±‚çš„é€šé“
    writes := make(chan writeOp)
  	//è¿™ä¸ªå‡½æ•°çš„ä½œç”¨å°±æ˜¯ä¸æ–­æ¥æ”¶è¯·æ±‚ï¼Œå¯¹stateè¿›è¡Œä¿®æ”¹
    go func() {
       //ç»´æŠ¤ä¸€ä¸ª map[int]int ä½œä¸ºå…±äº«çŠ¶æ€
       var state = make(map[int]int)
       for {
          //é€šè¿‡ select æ¥ç›‘å¬ reads å’Œ writes é€šé“
          select {
          //æ¥æ”¶åˆ°è¯»è¯·æ±‚åï¼Œå°†stateä¸­å¯¹åº”çš„å€¼ä¼ ç»™resp
          case read := <-reads:
             read.resp <- state[read.key]
          //æ¥æ”¶åˆ°å†™è¯·æ±‚åï¼Œå°†è¦å†™çš„å€¼è®°å½•åœ¨stateä¸­ï¼Œå¹¶ä¿®æ”¹é€šé“ä¸­çš„çŠ¶æ€
          case write := <-writes:
             state[write.key] = write.val
             write.resp <- true

          }
       }
    }()
    for r := 0; r < 100; r++ {
       go func() {
          for {
             //åˆ›å»ºä¸€ä¸ªè¯»è¯·æ±‚
             read := readOp{
                key:  rand.Intn(5),
                resp: make(chan int),
             }
             //å‘é€è¯»è¯·æ±‚
             reads <- read
             //ç­‰å¾…è¿”å›å€¼
             <-read.resp
             atomic.AddUint64(&readOps, 1)
             time.Sleep(time.Millisecond)
          }
       }()
    }
    for w := 0; w < 10; w++ {
       go func() {
          for {
             //åˆ›å»ºä¸€ä¸ªå†™è¯·æ±‚
             write := writeOp{
                key:  rand.Intn(5),
                val:  rand.Intn(100),
                resp: make(chan bool)}
             //å‘é€å†™è¯·æ±‚
             writes <- write
             <-write.resp
             atomic.AddUint64(&writeOps, 1)
             time.Sleep(time.Millisecond)
          }
       }()
    }

    time.Sleep(time.Second)
    //è·å–readOpsçš„å€¼
    readOpsFinal := atomic.LoadUint64(&readOps)
    fmt.Println("readOps:", readOpsFinal)
    writeOpsFinal := atomic.LoadUint64(&writeOps)
    fmt.Println("writeOps:", writeOpsFinal)

}
```

### æ’åº

##### åŸºæœ¬æ’åº

```go
package main

import (
	"fmt"
	"slices"
)

func main() {

	strs := []string{"c", "a", "b"}
  //å¯¹åˆ‡ç‰‡è¿›è¡Œå‡åºæ’åº
	slices.Sort(strs)
	fmt.Println("Strings:", strs)

	ints := []int{7, 2, 4}
	slices.Sort(ints)
	fmt.Println("Ints:   ", ints)
	//æ£€æŸ¥åˆ‡ç‰‡æ˜¯å¦å·²ç»æ’åº
	s := slices.IsSorted(ints)
	fmt.Println("Sorted: ", s)
}

```

##### è‡ªå®šä¹‰æ’åº

å³è‡ªå®šä¹‰æ’åºï¼Œæƒ³è¦è®©é›†åˆæŒ‰ç…§è‡ªå·±è§„å®šçš„æ–¹å¼è¿›è¡Œæ’åº

å¯ä»¥ä½¿ç”¨cmp.Compare()â•slices.SortFunc(slice, func(a, b T) int)å®ç°

```go
package main

import (
    "cmp"
    "fmt"
    "slices"
)

func main() {
    fruits := []string{"peach", "banana", "kiwi"}

    lenCmp := func(a, b string) int {
       //å‡åº
       //return cmp.Compare(len(a), len(b))
       //é™åº
       return cmp.Compare(len(b), len(a))
    }

    slices.SortFunc(fruits, lenCmp)
    fmt.Println(fruits)

    type Person struct {
       name string
       age  int
    }

    people := []Person{
       Person{name: "Jax", age: 37},
       Person{name: "TJ", age: 25},
       Person{name: "Alex", age: 72},
    }

    strcutcmp := func(a, b Person) int {
       return cmp.Compare(a.age, b.age)
    }
    slices.SortFunc(people, strcutcmp)
    fmt.Println(people)
}
```

