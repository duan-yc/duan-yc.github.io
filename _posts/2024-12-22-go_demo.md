---
layout: post
title: "go_demo"
subtitle: "go_demo"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
- go

---

go_demo

##### values

Go æœ‰å„ç§å€¼ç±»å‹ï¼ŒåŒ…æ‹¬å­—ç¬¦ä¸²ã€æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼ç­‰ã€‚è¿™é‡Œæ˜¯ä¸€äº›åŸºæœ¬ç¤ºä¾‹

```go
package main

import "fmt"

func main() {
	fmt.Println("go" + "lang")
	fmt.Println("1+1 =", 1+1)
	fmt.Println("7.0/3.0 =", 7.0/3.0)
	fmt.Println(true && false)
	fmt.Println(true || false)
	fmt.Println(!true)
}

```

##### å˜é‡

åœ¨ Go ä¸­ï¼Œ*å˜é‡*ç”±ç¼–è¯‘å™¨æ˜ç¡®å£°æ˜å’Œä½¿ç”¨ï¼Œä¾‹å¦‚æ£€æŸ¥å‡½æ•°è°ƒç”¨çš„ç±»å‹æ­£ç¡®æ€§

**varå¯ä»¥ä¸€æ¬¡å£°æ˜ä¸€ä¸ªæˆ–å¤šä¸ªå˜é‡**ï¼ŒGoå°†åˆ¤æ–­åˆå§‹åŒ–å˜é‡çš„ç±»å‹ï¼Œæœªè¿›è¡Œåˆå§‹åŒ–çš„å£°æ˜å˜é‡ä¸ºé›¶å€¼

**:=å¯åœ¨å‡½æ•°å†…éƒ¨ä½¿ç”¨**

```go
package main

import "fmt"

func main() {
    var a = "initial"
    fmt.Println(a)

    var b, c int = 1, 2
    fmt.Println(b, c)

    var d = true
    fmt.Println(d)

    var e int
    fmt.Println(e)

    f := "apple"
    fmt.Println(f)
}
```

##### å¸¸é‡

Goæ”¯æŒå­—ç¬¦ã€å­—ç¬¦ä¸²ã€å¸ƒå°”å€¼ã€æ•°å­—å€¼çš„å¸¸é‡

`const`å£°æ˜ä¸€ä¸ªå¸¸é‡å€¼ï¼Œ**ç”¨constå–ä»£varå³å¯**ï¼Œ**æ•°å­—å¸¸é‡æ²¡æœ‰ç±»å‹**ï¼Œé™¤éé€šè¿‡æ˜¾å¼è½¬æ¢ç­‰æ–¹å¼æŒ‡å®šç±»å‹

```go
package main

import (
    "fmt"
    "math"
)

const s string = "constant"

func main() {
    fmt.Println(s)

    const n = 500000000

    const d = 3e20 / n
    fmt.Println(d)

    fmt.Println(int64(d))

    fmt.Println(math.Sin(n))
}
```

##### for

`for`æ˜¯ Go å”¯ä¸€çš„å¾ªç¯ç»“æ„

```go
package main

import "fmt"

func main() {
    i := 1
    for i <= 3 {
       fmt.Println(i)
       i++
    }
    for j := 0; j < 5; j++ {
       fmt.Println(j)
    }
    nums := []int{1, 2, 3}
    for i := range nums {
       fmt.Println("range", i)
    }

    for {
       fmt.Println("loop")
       break
    }
    for i := 1; i <= 6; i++ {
       if i%2 == 1 {
          continue
       }
       fmt.Println(i)
    }
}
```

##### If-else

å¯ä»¥æœ‰`if`ä¸€ä¸ªä¸å¸¦ else çš„è¯­å¥ï¼Œè¯­å¥å¯ä»¥ä½äºæ¡ä»¶ä¹‹å‰ï¼Œæ­¤è¯­å¥å£°æ˜ä»»ä½•å˜é‡å¯ä»¥åœ¨è¯¥åˆ†æ”¯åŠåç»­åˆ†æ”¯ä½¿ç”¨

```go
package main

import "fmt"

func main() {
	if 7%2 == 0 {
		fmt.Println("7 is even")
	}

	if 8%2 == 0 || 7%2 == 0 {
		fmt.Println("either 8 or 7 are even")
	}
	
	if num := 9; num < 0 {
		fmt.Println(num, "is negative")
	} else if num > 0 {
		fmt.Println(num, "is positive")
	} else {
		fmt.Println(num, "is zero")
	}

}

```

##### switch

*Switch è¯­å¥*è¡¨è¾¾è·¨å¤šä¸ªåˆ†æ”¯çš„æ¡ä»¶

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	i := 2
	fmt.Print("write", i, "as")
	switch i {
	case 1:
		fmt.Println("one")
	case 2:
		fmt.Println("two")
	case 3:
		fmt.Println("three")
	}

	switch time.Now().Weekday() {
  //å¯ä»¥ä½¿ç”¨é€—å·åˆ†éš”åŒä¸€`case`è¯­å¥ä¸­çš„å¤šä¸ªè¡¨è¾¾å¼
	case time.Saturday, time.Sunday:
		fmt.Println("it's the weekend")
	default:
		fmt.Println("it's a weekday")
	}

	t := time.Now()
  //`switch`ä¸ä½¿ç”¨è¡¨è¾¾å¼æ˜¯è¡¨è¾¾ if/else é€»è¾‘çš„å¦ä¸€ç§æ–¹å¼,
	switch {
	case t.Hour() < 12:
		fmt.Println("it's before noon")
	default:
		fmt.Println("it's after noon")
	}

	whatAmI := func(i interface{}) {
    //ç±»å‹`switch`æ¯”è¾ƒçš„æ˜¯ç±»å‹è€Œä¸æ˜¯å€¼ã€‚å¯ä»¥ä½¿ç”¨å®ƒæ¥å‘ç°æ¥å£å€¼çš„ç±»å‹
		switch t := i.(type) {
		case bool:
			fmt.Println("I'm a bool")
		case int:
			fmt.Println("I'm an int")
		case string:
			fmt.Println("I'm a string")
		default:
			fmt.Printf("Don't know type %T\n", t)
		}
	}
	whatAmI(true)
	whatAmI("hey")
	whatAmI(1)
	
}

```

##### æ•°ç»„

```go
package main

import "fmt"

func main() {
    var a [5]int
    fmt.Println(a)

    a[4] = 100
    fmt.Println(a[4])
    fmt.Println(len(a))

    b := [5]int{1, 2, 3, 4, 5}
    fmt.Println(b)
		//å¯ä»¥è®©ç¼–è¯‘å™¨è®¡ç®—å…ƒç´ çš„æ•°é‡...
    b = [...]int{1, 2, 3, 4, 5}
    fmt.Println(b)
    //[100 0 0 400 500]
  	//3: 400è¡¨ç¤ºå°†3å·ä½ç½®è®¾ç½®ä¸º400ï¼Œç”±äº1å·å’Œ2å·ä½ç½®æ²¡æœ‰è®¾ç½®ï¼Œåˆ™é»˜è®¤ä¸º0
    b = [...]int{100, 3: 400, 500}
    fmt.Println(b)

    var twoD [2][3]int
    for i := 0; i < len(twoD); i++ {
       for j := 0; j < len(twoD[i]); j++ {
          twoD[i][j] = i + j
       }
    }
    fmt.Println(twoD)
    twoD = [2][3]int{
       {1, 2, 3},
       {2, 3, 4},
    }
    fmt.Println(twoD)

}
```

##### åˆ‡ç‰‡

åˆ‡ç‰‡å®é™…ä¸Šæ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œ**ç»“æ„ä½“å†…éƒ¨åŒ…å«æŒ‡å‘åº•å±‚æ•°ç»„çš„æŒ‡é’ˆã€åˆ‡ç‰‡çš„é•¿åº¦ã€åˆ‡ç‰‡çš„å®¹é‡**

æ‰€ä»¥åˆ‡ç‰‡å®é™…ä¸Šæ˜¯å¯¹**åº•å±‚æ•°ç»„**çš„ä¸€ä¸ªå°è£…ï¼Œè‡ªå·±å¹¶ä¸å­˜å‚¨æ•°æ®

æ‰€ä»¥å½“ä½¿ç”¨appendæ–¹æ³•æ—¶ï¼Œå¦‚æœlen>capæ—¶ï¼Œå°±ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„æ•°ç»„ï¼ˆä¸€èˆ¬ä¸¤å€å®¹é‡ï¼‰è¿›è¡Œè¿ç§»ï¼Œä½†è¿™ä¸ªè¿‡ç¨‹å¹¶ä¸æ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œæ‰€ä»¥å¦‚æœå¤šä¸ªgoroutineåœ¨ä½¿ç”¨è¯¥åˆ‡ç‰‡çš„è¯ï¼Œå¯ä»¥è€ƒè™‘åŠ é”

```go
package main

import (
	"fmt"
	"reflect"
	"slices"
)

func main() {
	var s []string
	//[] true true
	fmt.Println(s, s == nil, len(s) == 0)

	s = make([]string, 3)
	//[  ] false 3 3
	fmt.Println(s, s == nil, len(s), cap(s))

	s[0] = "a"
	s[1] = "b"
	s[2] = "c"
	fmt.Println(s)
	fmt.Println(s[2])
	fmt.Println(len(s))
	//éœ€è¦æ¥å—è¿”å›å€¼
  //appendæ–¹æ³•çš„è¿”å›å€¼å’ŒåŸæ¥çš„å€¼æ˜¯å¦æ˜¯ç›¸åŒçš„åœ°å€ï¼Œå–å†³äºåˆ‡ç‰‡çš„å®¹é‡æ˜¯å¦è¶³å¤Ÿï¼Œå¦‚æœä¸å¤Ÿå°±ä¼šåˆ›å»ºæ–°çš„æ•°ç»„è¿›è¡Œè¿ç§»
	s = append(s, "d")
	s = append(s, "e", "f")
	//[a b c d e f]
	fmt.Println(s)

	c := make([]string, len(s))
  //è¿™é‡Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªä¸ é•¿åº¦ç›¸åŒçš„copyç©ºåˆ‡ç‰‡å¹¶å°†å…¶å¤åˆ¶åˆ°ä¸­
	copy(c, s)
	fmt.Println(c)

	l := s[2:5]
	//[c d e]
	fmt.Println(l)
	//å¯ä»¥åœ¨ä¸€è¡Œä¸­å£°æ˜å¹¶åˆå§‹åŒ–åˆ‡ç‰‡çš„å˜é‡
	t := []string{"a", "b", "c"}
	t2 := []string{"a", "b", "c"}
	//t==t2ï¼Œè¿™ä¸ªç”¨äºåˆ¤æ–­ä¸¤ä¸ªåˆ‡ç‰‡ä¸­çš„å†…å®¹æ˜¯å¦ç›¸åŒ
	if slices.Equal(t, t2) {
		fmt.Println("t==t2")
	}
	//å¦‚æœæƒ³æ¯”è¾ƒä¸¤ä¸ªçš„åœ°å€çš„è¯ï¼Œå¯ä»¥ä½¿ç”¨è¿”å›æˆ–è€…æ¯”è¾ƒä¸¤ä¸ªçš„æŒ‡é’ˆï¼Œä¸èƒ½ç›´æ¥ç”¨t==t2è¿›è¡Œæ¯”è¾ƒ
  //tå’Œt2çš„åœ°å€ä¸åŒ
	if reflect.ValueOf(t).Pointer() == reflect.ValueOf(t2).Pointer() {
		fmt.Println("t and t2 share the same underlying array")
	} else {
		fmt.Println("t and t2 do not share the same underlying array")
	}
	if &t[0] == &t2[0] {
		fmt.Println("t and t2 share the same underlying array")
	} else {
		fmt.Println("t and t2 do not share the same underlying array")
	}
	//åˆ‡ç‰‡å¯ä»¥ç»„æˆå¤šç»´æ•°æ®ç»“æ„ã€‚ä¸å¤šç»´æ•°ç»„ä¸åŒï¼Œå†…éƒ¨åˆ‡ç‰‡çš„é•¿åº¦å¯ä»¥å˜åŒ–
	twoD := make([][]int, 3)
	for i := 0; i < len(twoD); i++ {
		inner := i + 1
		twoD[i] = make([]int, inner)
		for j := 0; j < inner; j++ {
			twoD[i][j] = i + j
		}
	}
	//[[0] [1 2] [2 3 4]]
	fmt.Println(twoD)
}

```

##### æ˜ å°„

```go
package main

import (
	"fmt"
	"maps"
)

func main() {
	m := make(map[string]int)
	m["k1"] = 7
	m["k2"] = 13
	//map[k1:7 k2:13]
	fmt.Println(m)

	v1 := m["k2"]
	fmt.Println(v1)

	v3 := m["k3"]
	//0ï¼Œå¦‚æœé”®ä¸å­˜åœ¨ï¼Œ åˆ™è¿”å›å€¼ç±»å‹çš„é›¶å€¼
	fmt.Println(v3)

	fmt.Println(len(m))
	//å†…ç½®å‘½ä»¤deleteä»æ˜ å°„ä¸­åˆ é™¤é”®/å€¼å¯¹
	delete(m, "k2")
	//map[k1:7]
	fmt.Println(m)
	//è¦ä»mapä¸­åˆ é™¤æ‰€æœ‰clearé”®/å€¼å¯¹
	clear(m)
	//map[]
	fmt.Println(m)
	//ä»æ˜ å°„ä¸­è·å–å€¼æ—¶ï¼Œå¯é€‰çš„ç¬¬äºŒä¸ªè¿”å›å€¼æŒ‡ç¤ºæ˜ å°„ä¸­æ˜¯å¦å­˜åœ¨è¯¥é”®ã€‚
  //è¿™å¯ç”¨äºåŒºåˆ†ç¼ºå¤±é”®å’Œå…·æœ‰é›¶å€¼çš„é”®ï¼ˆå¦‚0æˆ– ï¼‰""ã€‚
  //è¿™é‡Œæˆ‘ä»¬ä¸éœ€è¦å€¼æœ¬èº«ï¼Œå› æ­¤æˆ‘ä»¬ç”¨ç©ºç™½æ ‡è¯†ç¬¦ _å¿½ç•¥å®ƒ
	_, prs := m["k2"]
	//false
	fmt.Println(prs)

	n := map[string]int{"foo": 1, "bar": 2}
	fmt.Println(n)
	//map[k:v k:v]è¯·æ³¨æ„ï¼Œä½¿ç”¨ æ‰“å°æ—¶ï¼Œåœ°å›¾ä¼šä»¥è¡¨æ ¼å½¢å¼å‡ºç°fmt.Println
	n2 := map[string]int{"foo": 1, "bar": 2}
	if maps.Equal(n, n2) {
		//true
		fmt.Println("true")
	}
}

```

##### å‡½æ•°

```go
package main

import "fmt"

func plus(a int, b int) int {
	//Go éœ€è¦æ˜¾å¼è¿”å›ï¼Œå³å®ƒä¸ä¼šè‡ªåŠ¨è¿”å›æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼
	return a + b
}

func plusPlus(a, b, c int) int {
	return a + b + c
}

func vals() (int, int) {
	//å¯ä»¥å¤šè¿”å›å€¼
	return 3, 7
}

func main() {

	res := plus(1, 2)
	fmt.Println(res)

	res = plusPlus(1, 2, 3)
	fmt.Println(res)

	a, b := vals()
	fmt.Println(a, b)
	_, c := vals()
	//7
	fmt.Println(c)

}

```

##### é—­åŒ…

Go æ”¯æŒ[*åŒ¿åå‡½æ•°*](https://en.wikipedia.org/wiki/Anonymous_function)ï¼Œå¯ä»¥å½¢æˆ[*é—­åŒ…*](https://en.wikipedia.org/wiki/Closure_(computer_science))ã€‚å½“ä½ æƒ³ä»¥å†…è”æ–¹å¼å®šä¹‰å‡½æ•°è€Œä¸å¿…ä¸ºå…¶å‘½åæ—¶ï¼ŒåŒ¿åå‡½æ•°éå¸¸æœ‰ç”¨

```go
package main

import "fmt"

func intSeq() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

func main() {
  //æ¯æ¬¡ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„çŠ¶æ€
	nextInt := intSeq()
	//1
	fmt.Println(nextInt())
	//2
	fmt.Println(nextInt())
	//3
	fmt.Println(nextInt())
	newInt := intSeq()
	//1
	fmt.Println(newInt())
}

```

##### é€’å½’

```go
package main

import "fmt"

func fact(n int) int {
    if n == 0 {
       return 1
    }
    return n * fact(n-1)
}

func main() {
    fmt.Println(fact(5))
    var fib func(n int) int
    fib = func(n int) int {
       if n < 2 {
          return n
       }
       return fib(n-1) + fib(n-2)
    }
    fmt.Println(fib(10))
}
```

##### rangeå‡½æ•°

```go
package main

import "fmt"

func main() {
    nums := []int{1, 2, 3}
    sum := 0
    for _, num := range nums {
       sum += num
    }
    fmt.Println(sum)
    for i, num := range nums {
       if num == 3 {
          //2
          fmt.Println(i)
       }
    }
    kvs := map[string]int{"a": 1, "b": 2}
    for k, v := range kvs {
       fmt.Println(k, v)
    }
    for k := range kvs {
       fmt.Println(k)
    }

    for i, c := range "go" {
       fmt.Println(i, c)
    }
}
```

##### æŒ‡é’ˆ

`&i`è¯­æ³•ç»™å‡ºäº† çš„å†…å­˜åœ°å€`i`ï¼Œå³ çš„æŒ‡é’ˆ`i`

```go
package main

import "fmt"

func zeroval(inval int) {
    inval = 0
}

func zeroptr(inptr *int) {
    *inptr = 0
}

func main() {
    i := 1
    fmt.Println(i)

    zeroval(i)
    fmt.Println(i)

    zeroptr(&i)
    fmt.Println(i)

}
```

##### strings

åœ¨ Go ä¸­ï¼Œ`rune` æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªè¡¨ç¤º Unicode ç ç‚¹çš„æ•´æ•°ï¼ˆæœ¬è´¨ä¸Šæ˜¯ `int32` ç±»å‹ï¼‰ã€‚

```go
package main

import (
    "fmt"
    "unicode/utf8"
)

func main() {
    const s = "Zbs"
    //3
    fmt.Println(len(s))
    for i := 0; i < len(s); i++ {
       //Z b s
       fmt.Printf("%c ", s[i])
    }
    fmt.Println()
    //3ï¼Œç”¨äºè®¡ç®—å­—ç¬¦ä¸²ä¸­ Unicode å­—ç¬¦ï¼ˆå³ runeï¼‰ çš„æ•°é‡
    fmt.Println(utf8.RuneCountInString(s))

    //å¦‚æœæ²¡æœ‰%cï¼Œå°±ä¼šè¾“å‡ºasciiçš„intå€¼
    for idx, value := range s {
       //0 90
       //1 98
       //2 115
       fmt.Println(idx, value)
    }

    for i, w := 0, 0; i < len(s); i += w {
       //ç”¨äºè§£ç å­—ç¬¦ä¸²ä¸­çš„ä¸‹ä¸€ä¸ª Unicode å­—ç¬¦ï¼ˆruneï¼‰ï¼Œå¹¶è¿”å›è¯¥å­—ç¬¦ä»¥åŠå®ƒçš„å­—èŠ‚å®½åº¦
       runValue, width := utf8.DecodeRuneInString(s[i:])
       fmt.Println(width, runValue)
       w = width
       examineRunne(runValue)
    }

}
func examineRunne(r rune) {
    if r == 'b' {
       fmt.Println("b")
    } else if r == 'a' {
       fmt.Println("a")
    }
}
```

##### ç»“æ„ä½“

å¦‚æœè¦å°†ç»“æ„ä½“ä½œä¸ºå‡½æ•°çš„å‚æ•°è¿›è¡Œä¼ é€’çš„æ—¶å€™ï¼Œè¦è€ƒè™‘æ˜¯å¦è¦ä¿®æ”¹åŸç»“æ„ä½“çš„å€¼ï¼Œæ¥ç¡®å®šç»“æ„ä½“å‚æ•°è®¾ç½®ä¸ºæŒ‡é’ˆç±»å‹è¿˜æ˜¯å€¼ç±»å‹

```go
package main

import "fmt"

type person struct {
    name string
    age  int
}

func newPerson(name string, age int) *person {
    return &person{name, age}
}

func main() {
    fmt.Println(person{"Bob", 20})
    fmt.Println(person{name: "Bob", age: 20})
    fmt.Println(person{name: "Bob"})
    //&{Bob 20}
    fmt.Println(&person{name: "Bob", age: 20})
    //&{Bob 20}
  	//å°†æ–°ç»“æ„ä½“çš„åˆ›å»ºå°è£…åœ¨æ„é€ å‡½æ•°ä¸­æ˜¯ä¸€ç§æƒ¯ç”¨åšæ³•
    fmt.Println(newPerson("Bob", 20))

    s := person{name: "Bob", age: 20}
    fmt.Println(s.name)

    sp := &s
    //20
    fmt.Println(sp.age)
    sp.age = 30
    //30
    fmt.Println(s.age)

    dog := struct {
       name   string
       isGood bool
    }{
       "name",
       true,
    }
    fmt.Println(dog)
}
```

##### æ–¹æ³•

é€šè¿‡ç»“æ„ä½“ã€æ–¹æ³•ã€æ¥å£æ¥å®ç°é¢å¯¹å¯¹è±¡çš„è®¾è®¡

é€šè¿‡ç»“æ„ä½“+æ–¹æ³•å®ç°ç±»çš„ç»„åˆ

```go
package main

import "fmt"

type rect struct {
    width, height int
}
//æŒ‡é’ˆå‹æ¥æ”¶è€…ï¼Œè¿™æ ·æ–¹æ³•å†…éƒ¨çš„ä¿®æ”¹ä¼šå½±å“åˆ°ç»“æ„ä½“çš„åŸå­—æ®µ
func (r *rect) area() int {
    return r.width * r.height
}
//å€¼æ¥æ”¶è€…ï¼Œæ–¹æ³•å†…éƒ¨çš„ä¿®æ”¹ä¸ä¼šå½±å“åˆ°ç»“æ„ä½“çš„åŸå­—æ®µ
func (r rect) perim() int {
    return 2*r.width + 2*r.height
}

func main() {
    r := rect{width: 10, height: 5}

    fmt.Println("area: ", r.area())
    fmt.Println("perim:", r.perim())
		//Go è‡ªåŠ¨å¤„ç†æ–¹æ³•è°ƒç”¨æ—¶å€¼ä¸æŒ‡é’ˆä¹‹é—´çš„è½¬æ¢
    rp := &r
    fmt.Println("area: ", rp.area())
    fmt.Println("perim:", rp.perim())
  	//è¿™é‡Œå¦‚æœå®šä¹‰çš„æ˜¯æŒ‡é’ˆç±»å‹ï¼Œé‚£ä¹ˆrå°±åªèƒ½ä¼ é€’çš„æ˜¯åœ°å€
    var t *rect
    t = &r
    t.width = 0
    fmt.Println("area: ", t.area())
    fmt.Println("perim:", t.perim())
    fmt.Println("area: ", r.area())
    fmt.Println("perim:", r.perim())
}
```

##### æ¥å£

åœ¨Goä¸­å®ç°æ¥å£ï¼Œæˆ‘ä»¬åªéœ€è¦å®ç°æ¥å£é‡Œçš„æ‰€æœ‰æ–¹æ³•å³å¯

```go
package main

import (
    "fmt"
    "math"
)

type geometry interface {
    area() float64
    perim() float64
}

type rectt struct {
    width, height float64
}

type circle struct {
    radius float64
}
//åœ¨ Go ä¸­ï¼Œæ¥å£çš„å®ç°ä¾èµ–äºæ–¹æ³•æ¥æ”¶è€…çš„ç±»å‹ï¼Œè€Œæ–¹æ³•çš„è°ƒç”¨å°±éœ€è¦æŒ‰ç…§æ¥æ”¶è€…çš„ç±»å‹æ¥è¿›è¡Œè°ƒç”¨
func (r *rectt) area() float64 {
    return r.width * r.height
}
func (r *rectt) perim() float64 {
    return 2*r.width + 2*r.height
}

func (c circle) area() float64 {
    return math.Pi * c.radius * c.radius
}
func (c circle) perim() float64 {
    return 2 * math.Pi * c.radius
}
//å¦‚æœå˜é‡å…·æœ‰æ¥å£ç±»å‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è°ƒç”¨æŒ‡å®šæ¥å£ä¸­çš„æ–¹æ³•
//ç±»ä¼¼äºjavaä¸­çš„å¤šæ€
func measure(g geometry) {
    fmt.Println(g)
}

func main() {
    r := rectt{width: 10, height: 5}
    c := circle{radius: 5}
  //circleå’Œç»“æ„ç±»å‹rectéƒ½å®ç°äº†geometryæ¥å£ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™äº›ç»“æ„çš„å®ä¾‹ä½œä¸ºçš„å‚æ•°measure
  //å› ä¸ºå®ç°æ¥å£çš„æ–¹æ³•æ¥æ”¶è€…æ˜¯æŒ‡é’ˆç±»å‹ï¼Œæ‰€ä»¥è¿™é‡Œå°±éœ€è¦èµ‹åœ°å€
    measure(&r)
    measure(c)
}
```

##### æšä¸¾

æšä¸¾æ˜¯ä¸€ç§å…·æœ‰å›ºå®šæ•°é‡å¯èƒ½å€¼çš„ç±»å‹ï¼Œæ¯ä¸ªå€¼éƒ½æœ‰ä¸åŒçš„åç§°ã€‚Go æ²¡æœ‰æšä¸¾ç±»å‹ä½œä¸ºç‹¬ç‰¹çš„è¯­è¨€åŠŸèƒ½ï¼Œä½†ä½¿ç”¨ç°æœ‰çš„è¯­è¨€ä¹ è¯­å¾ˆå®¹æ˜“å®ç°æšä¸¾ã€‚

```go
package main

import "fmt"

type ServerState int

const (
	//è¿™é‡Œé€šè¿‡ iota åˆ›å»ºäº†å››ä¸ªå¸¸é‡ï¼Œåˆ†åˆ«è¡¨ç¤ºæœåŠ¡å™¨çš„å››ç§çŠ¶æ€
	//iota æ˜¯ Go ä¸­ç”¨äºç”Ÿæˆå¸¸é‡å€¼çš„ä¸€ä¸ªç‰¹æ®Šå…³é”®å­—ï¼Œå®ƒåœ¨æ¯ä¸€è¡Œå¸¸é‡å®šä¹‰ä¸­ä¼šè‡ªåŠ¨é€’å¢
	StateIdle ServerState = iota
	StateConnected
	StateError
	StateRetrying
)

var stateName = map[ServerState]string{
	StateIdle:      "idle",
	StateConnected: "connected",
	StateError:     "error",
	StateRetrying:  "retrying",
}

func (ss ServerState) String() string {
	return stateName[ss]
}

func main() {
	//è¿™é‡Œè™½ç„¶ServerStateæ˜¯intç±»å‹ï¼Œä½†ä¸èƒ½ä¼ intç±»å‹è¿›å»ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œå› ä¸ºå®ƒä»¬çš„ç±»å‹ä¸åŒã€‚
	ns := transition(StateIdle)
	fmt.Println(ns)

	ns2 := transition(ns)
	fmt.Println(ns2)
}

// transition æ¨¡æ‹ŸæœåŠ¡å™¨çš„çŠ¶æ€è½¬æ¢ï¼›å®ƒé‡‡ç”¨ç°æœ‰çŠ¶æ€å¹¶è¿”å›æ–°çŠ¶æ€
func transition(s ServerState) ServerState {
	switch s {
	case StateIdle:
		return StateConnected
	case StateConnected, StateRetrying:

		return StateIdle
	case StateError:
		return StateError
	default:
		panic(fmt.Errorf("unknown state: %s", s))
	}
}

```

##### ç»“æ„ä½“åµŒå…¥

```go
package main

import "fmt"

type base struct {
    num int
}

func (b base) describe() string {
    return fmt.Sprintf("base with num=%v", b.num)
}

type container struct {
  	//Acontainer åµŒå…¥a baseã€‚åµŒå…¥çœ‹èµ·æ¥åƒä¸€ä¸ªæ²¡æœ‰åç§°çš„å­—æ®µ
    base
    str string
}

func main() {
		//å½“ä½¿ç”¨æ–‡å­—åˆ›å»ºç»“æ„æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»æ˜ç¡®åˆå§‹åŒ–åµŒå…¥ï¼›è¿™é‡ŒåµŒå…¥çš„ç±»å‹ç”¨ä½œå­—æ®µåç§°
    co := container{
       base: base{
          num: 1,
       },
       str: "some name",
    }
		//è¿™æ ·å°±å¯ä»¥ç›´æ¥è®¿é—®å­ç»“æ„ä½“çš„å­å­—æ®µ ä¾‹å¦‚co.num
    fmt.Printf("co={num: %v, str: %v}\n", co.num, co.str)

    fmt.Println("also num:", co.base.num)
		//ç”±äºcontaineråµŒå…¥baseï¼Œ çš„æ–¹æ³• baseä¹Ÿæˆä¸º çš„æ–¹æ³•ã€‚è¿™é‡Œæˆ‘ä»¬ ç›´æ¥containeråœ¨ ä¸Šè°ƒç”¨åµŒå…¥çš„æ–¹æ³•
    fmt.Println("describe:", co.describe())

    type describer interface {
       describe() string
    }
		//åµŒå…¥å¸¦æœ‰æ–¹æ³•çš„ç»“æ„å¯ç”¨äºå°†æ¥å£å®ç°èµ‹äºˆå…¶ä»–ç»“æ„ã€‚è¿™é‡Œæˆ‘ä»¬çœ‹åˆ° acontainerç°åœ¨å®ç°äº† describeræ¥å£ï¼Œå› ä¸ºå®ƒåµŒå…¥äº†baseã€‚
    var d describer = co
    fmt.Println("describer:", d.describe())
}
```

##### æ³›å‹

```go
package main

import "fmt"

// SlicesIndex ä½¿ç”¨äº† ç±»å‹çº¦æŸï¼Œå…¶ä¸­ S ~[]E å’Œ E comparable æ˜¯å‡½æ•°çš„ç±»å‹å‚æ•°çº¦æŸ
// S å¿…é¡»æ˜¯ åˆ‡ç‰‡ç±»å‹ï¼Œå¹¶ä¸”è¯¥åˆ‡ç‰‡çš„å…ƒç´ ç±»å‹æ˜¯ E
// ~ è¿ç®—ç¬¦åœ¨è¿™é‡Œçš„ä½œç”¨æ˜¯å…è®¸ç±»å‹åˆ«åï¼Œå³å…è®¸ S ä¸ä»…ä»…æ˜¯ []E è¿™æ ·çš„åŸå§‹åˆ‡ç‰‡ç±»å‹ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªåˆ‡ç‰‡ç±»å‹çš„ç±»å‹åˆ«åï¼Œå³å¦‚æœåé¢ä½¿ç”¨è¿™ä¸ªæ–¹æ³•çš„æ—¶å€™ï¼Œä¼ é€’å‚æ•°æ—¶åˆ‡ç‰‡çš„ç±»å‹ä¸ä»…å¯ä»¥æ˜¯Eï¼Œä¹Ÿå¯ä»¥æ˜¯å…¶ä»–ç±»å‹
func SlicesIndex[S ~[]E, E comparable](s S, v E) int {
    //E comparable é™åˆ¶äº†ä¼ å…¥çš„å…ƒç´ ç±»å‹ E å¿…é¡»æ˜¯å¯ä»¥é€šè¿‡ == å’Œ != è¿ç®—ç¬¦è¿›è¡Œæ¯”è¾ƒçš„ç±»å‹
    for i := range s {
       if v == s[i] {
          return i
       }
    }
    return -1
}

// List List[T any] æ˜¯ä¸€ä¸ªæ³›å‹é“¾è¡¨ç±»å‹ï¼ŒT è¡¨ç¤ºé“¾è¡¨ä¸­èŠ‚ç‚¹çš„å…ƒç´ ç±»å‹ï¼Œany è¡¨ç¤ºå¯ä»¥æ˜¯ä»»ä½•ç±»å‹
type List[T any] struct {
    head, tail *element[T]
}

// element[T any] æ˜¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ç±»å‹
type element[T any] struct {
  //å¸¦çš„*è¯´æ˜æ˜¯åœ°å€
    next *element[T]
    val  T
}
//ä¸ºé“¾è¡¨å®šä¹‰äº†ä¸¤ä¸ªæ–¹æ³•
//æˆ‘ä»¬å¯ä»¥åƒåœ¨å¸¸è§„ç±»å‹ä¸Šä¸€æ ·åœ¨æ³›å‹ç±»å‹ä¸Šå®šä¹‰æ–¹æ³•ï¼Œä½†å¿…é¡»ä¿ç•™ç±»å‹å‚æ•°ã€‚ç±»å‹æ˜¯List[T]ï¼Œè€Œä¸æ˜¯List
func (lst *List[T]) Push(v T) {
    if lst.tail == nil {
       lst.head = &element[T]{val: v}
       lst.tail = lst.head
    } else {
       lst.tail.next = &element[T]{val: v}
       lst.tail = lst.tail.next
    }
}

func (lst *List[T]) AllElements() []T {
    var elems []T
    for e := lst.head; e != nil; e = e.next {
       elems = append(elems, e.val)
    }
    return elems
}

func main() {
    var s = []string{"foo", "bar", "zoo"}

    fmt.Println("index of zoo:", SlicesIndex(s, "zoo"))

    _ = SlicesIndex[[]string, string](s, "zoo")

    lst := List[int]{}
    lst.Push(10)
    lst.Push(13)
    lst.Push(23)
    fmt.Println("list:", lst.AllElements())
}
```

##### rangeè¿­ä»£å™¨

è¿­ä»£å™¨å‡½æ•°å°†å¦ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œ`yield`æŒ‰ç…§æƒ¯ä¾‹è°ƒç”¨è¯¥å‡½æ•°ï¼ˆä½†åç§°å¯ä»¥ä»»æ„ï¼‰ã€‚å®ƒå°†è°ƒç”¨`yield`æˆ‘ä»¬æƒ³è¦è¿­ä»£çš„æ¯ä¸ªå…ƒç´ ï¼Œå¹¶æ³¨æ„`yield`çš„è¿”å›å€¼ä»¥é˜²å¯èƒ½æå‰ç»ˆæ­¢ã€‚

```go
package main

import (
	"fmt"
	"iter"
	"slices"
)

type List[T any] struct {
	head, tail *element[T]
}

type element[T any] struct {
	next *element[T]
	val  T
}

func (lst *List[T]) Push(v T) {
	if lst.tail == nil {
		lst.head = &element[T]{val: v}
		lst.tail = lst.head
	} else {
		lst.tail.next = &element[T]{val: v}
		lst.tail = lst.tail.next
	}
}

func (lst *List[T]) All() iter.Seq[T] {
	return func(yield func(T) bool) {

		for e := lst.head; e != nil; e = e.next {
			if !yield(e.val) {
				return
			}
		}
	}
}
//è¿­ä»£ï¼ˆIterationï¼‰ ä¸ä¸€å®šä¾èµ–äºç‰¹å®šçš„æ•°æ®ç»“æ„ï¼Œç”šè‡³ä¸éœ€è¦æ˜¯æœ‰é™çš„ï¼ˆæ¯”å¦‚æ— é™åºåˆ—ï¼‰
func genFib() iter.Seq[int] {
	return func(yield func(int) bool) {
		a, b := 1, 1

		for {
			if !yield(a) {
				return
			}
			a, b = b, a+b
		}
	}
}

func main() {
	lst := List[int]{}
	lst.Push(10)
	lst.Push(13)
	lst.Push(23)
	//ç”±äºList.Allè¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å¸¸è§„rangeå¾ªç¯ä¸­ä½¿ç”¨å®ƒ
	for e := range lst.All() {
		fmt.Println(e)
	}
	//åƒåˆ‡ç‰‡è¿™æ ·çš„åŒ…æœ‰è®¸å¤šæœ‰ç”¨çš„å‡½æ•°å¯ä»¥ä¸è¿­ä»£å™¨ä¸€èµ·ä½¿ç”¨
	all := slices.Collect(lst.All())
	fmt.Println("all:", all)
	
	for n := range genFib() {

		if n >= 10 {
			break
		}
		fmt.Println(n)
	}
}

```

é“¾è¡¨ä»¥å‰çš„å®šä¹‰æ–¹å¼å¦‚ä¸‹

```go
package main

import "fmt"

type ListNode struct {
	next *ListNode
	val  int
}

func main() {
	head := &ListNode{}
	node := head
	for node != nil {
		if node.next == nil {
			node.next = &ListNode{nil, 1}
			break
		}
		node = node.next
	}
	for head != nil {
		fmt.Println(head.val)
		head = head.next
	}
	
}

```

##### é”™è¯¯

åœ¨ Go ä¸­ï¼Œé€šè¿‡æ˜¾å¼ã€å•ç‹¬çš„è¿”å›å€¼ä¼ è¾¾é”™è¯¯æ˜¯ä¸€ç§æƒ¯ç”¨åšæ³•

```go
package main

import (
	"errors"
	"fmt"
)

func f(arg int) (int, error) {
	if arg == 42 {
		//errors.Newerrorä½¿ç”¨ç»™å®šçš„é”™è¯¯æ¶ˆæ¯æ„é€ ä¸€ä¸ªåŸºæœ¬å€¼
		return -1, errors.New("can't work with 42")
	}

	return arg + 3, nil
}
//æ ‡è®°é”™è¯¯æ˜¯ä¸€ä¸ªé¢„å…ˆå£°æ˜çš„å˜é‡ï¼Œç”¨äºè¡¨ç¤ºç‰¹å®šçš„é”™è¯¯æƒ…å†µ
var ErrOutOfTea = fmt.Errorf("no more tea available")
var ErrPower = fmt.Errorf("can't boil water")

func makeTea(arg int) error {
	if arg == 2 {
		return ErrOutOfTea
	} else if arg == 4 {
		//è¿™é‡Œæ˜¯åŒ…è£…é”™è¯¯ï¼Œå› ä¸ºåœ¨å¹³æ—¶ä½¿ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œå¸Œæœ›ä¸ä»…è¿”å›é”™è¯¯ï¼Œè¿˜å¯ä»¥è¿”å›é”™è¯¯ä¸Šä¸‹æ–‡ä¿¡æ¯
    //å°†ä¸€ä¸ªé”™è¯¯åŒ…è£…åˆ°å¦ä¸€ä¸ªé”™è¯¯ä¸­ï¼Œå¹¶ä¸”ä¿ç•™åŸå§‹é”™è¯¯ä¿¡æ¯ï¼Œè¿™æ ·å¯ä»¥æ„å»ºä¸€ä¸ªé”™è¯¯é“¾
    //è¿™é‡Œçš„å‡½æ•°makeTeaå°±æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œæ ¹æ®ä¼ é€’çš„å‚æ•°æ¥æ¨¡æ‹Ÿå‡ºä¸åŒçš„é”™è¯¯
		return fmt.Errorf("making tea: %w", ErrPower)
	}
	return nil
}

func main() {
	for _, i := range []int{7, 42} {

		if r, e := f(i); e != nil {
			fmt.Println("f failed:", e)
		} else {
			fmt.Println("f worked:", r)
		}
	}

	for i := 1; i <= 5; i++ {
		if err := makeTea(i); err != nil {
			//errors.Isæ£€æŸ¥ç»™å®šé”™è¯¯ï¼ˆæˆ–å…¶é“¾ä¸­çš„ä»»ä½•é”™è¯¯ï¼‰æ˜¯å¦ä¸ç‰¹å®šé”™è¯¯å€¼åŒ¹é…
			if errors.Is(err, ErrOutOfTea) {
				fmt.Println("We should buy new tea!")
			} else if errors.Is(err, ErrPower) {
				fmt.Println("Now it is dark.")
			} else {
				fmt.Printf("unknown error: %s\n", err)
			}
			continue
		}

		fmt.Println("Tea is ready!")
	}
}

```

##### è‡ªå®šä¹‰é”™è¯¯

```go
package main

import (
	"errors"
	"fmt"
)

// ä½¿ç”¨ç»“æ„ä½“è‡ªå®šä¹‰ä¸€ä¸ªé”™è¯¯
type argError struct {
	arg     int
	message string
}

// å®ç°erroræ¥å£
func (e *argError) Error() string {
	return fmt.Sprintf("%d - %s", e.arg, e.message)
}

func f1(arg int) (int, error) {
	if arg == 42 {
		//æ–¹æ³•çš„æ¥æ”¶è€…ä½¿ç”¨çš„æ˜¯æŒ‡é’ˆç±»å‹ï¼Œæ‰€ä»¥è¿™é‡Œè¦ç”¨&
		return -1, &argError{arg, "can't work with it"}
	}
	return arg + 3, nil
}

func main() {

	_, err := f1(42)
	var ae *argError
	//è¿™é‡Œçš„errors.Asä¼šæ£€æŸ¥erræ˜¯å¦æ˜¯aeç±»å‹çš„é”™è¯¯ï¼Œå¦‚æœæ˜¯çš„è¯ï¼Œå°±ä¼šå°†errèµ‹å€¼ç»™ae
	//errors.Asèµ‹å€¼çš„æ—¶å€™ï¼Œè¦æ±‚è¢«èµ‹å€¼çš„å˜é‡å¿…é¡»æ˜¯æŒ‡é’ˆç±»å‹ï¼Œè¿™æ ·æ‰å¯ä»¥è¿›è¡Œä¿®æ”¹
	//æ‰€ä»¥è¿™é‡Œä¼ é€’çš„æ˜¯aeçš„åœ°å€ï¼Œå°½ç®¡aeæœ¬æ¥å°±æ˜¯ä¸€ä¸ªå¼•ç”¨åœ°å€
	if errors.As(err, &ae) {
		fmt.Println(ae.arg)
		fmt.Println(ae.message)
	} else {
		fmt.Println("err doesn't match argError")
	}
}
/*
è¿™é‡Œæœ€åçš„è¾“å‡ºæ˜¯
42
can't work with it
*/
```

##### Goroutines

goroutineæ˜¯ä¸€ä¸ªè½»é‡çº§çš„æ‰§è¡Œçº¿ç¨‹

```go
package main

import (
	"fmt"
	"time"
)

func ff(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
	}
}

func main() {
	//è¿™æ˜¯ä¸€ä¸ªæ™®é€šçš„å‡½æ•°è°ƒç”¨ï¼Œè¿è¡Œåœ¨ main goroutine ä¸­
	//å› æ­¤å®ƒä¼šé¡ºåºæ‰§è¡Œå¹¶å®Œæˆåæ‰ç»§ç»­å‘ä¸‹æ‰§è¡Œ
	ff("direct")

	//main çº¿ç¨‹ä¸ä¼šç­‰å¾…å®ƒå®Œæˆï¼Œç›´æ¥ç»§ç»­æ‰§è¡Œä¸‹ä¸€è¡Œä»£ç ã€‚
	go ff("goroutine")

	//å¯åŠ¨ä¸€ä¸ª goroutine è¿›è¡ŒåŒ¿åå‡½æ•°è°ƒç”¨
	go func(msg string) {
		fmt.Println(msg)
	}("going")

	//è¿™ä¸ª Sleep çš„ç›®çš„æ˜¯ç»™ goroutine è¿è¡Œçš„æ—¶é—´
	//å¦åˆ™ main å¯èƒ½ä¼šç›´æ¥ç»“æŸï¼Œå¯¼è‡´ goroutine æ²¡æœºä¼šè¿è¡Œ
	//å³ä½¿æ˜¯goroutineæ­£åœ¨æ‰§è¡Œï¼Œåªè¦ä¸»çº¿ç¨‹ç»“æŸï¼Œgoroutineä¹Ÿä¼šè¢«ä¸­æ–­
	time.Sleep(time.Second)
	fmt.Println("done")
}

```

ä½†æ˜¯è¿™é‡Œä½¿ç”¨çš„sleepæ–¹æ³•ä¸å¤ªå¥½ï¼Œæœ€å¥½è¿˜æ˜¯ä½¿ç”¨waitgroup

```go
package main

import (
	"fmt"
	"sync"
)

func ff(from string) {
	for i := 0; i < 3; i++ {
		fmt.Println(from, ":", i)
	}
}

func main() {
	//ä½¿ç”¨waitgroupçš„æ–¹å¼
	var wg sync.WaitGroup

	ff("direct")
	//æ·»åŠ ä¸¤ä¸ªè¦ç­‰å¾…çš„goroutine
	wg.Add(2)

	go func() {
		//è¿™é‡Œéœ€è¦åŠ wg.Done()ï¼Œç”¨äºwgçš„è®¡æ•°ï¼Œè¦ä¸¤æ¬¡ä¸»çº¿ç¨‹æ‰ä¼šç»“æŸç­‰å¾…ï¼Œå¦åˆ™å°±ä¼šæ­»é”
		defer wg.Done()
		ff("goroutine")
	}()

	go func(msg string) {
		defer wg.Done()
		fmt.Println(msg)
	}("going")
	//ä¸»çº¿ç¨‹åœ¨è¿™ä¸ªä½ç½®ç­‰å¾…
	wg.Wait()
	fmt.Println("done")
}

```

##### Channels

Channelç”¨äºgoroutineä¹‹é—´çš„æ¶ˆæ¯é€šä¿¡

æ— ç¼“å†²é€šé“ä¼šé˜»å¡å‘é€æ–¹å’Œæ¥æ”¶æ–¹ï¼Œä¼šä¸€ç›´ç­‰å¾…å‘é€æ–¹å’Œæ¥æ”¶æ–¹éƒ½å‡†å¤‡å¥½äº†ï¼Œä¸¤è¾¹æ‰ä¼šè§£é™¤é˜»å¡ï¼Œè¿›è¡Œæ‰§è¡Œä¸‹å»

**ä¸‹é¢æ‰§è¡Œè¿‡ç¨‹åˆ†æ**

- **Step 1**: `go func() { messages <- "ping" }()` å¯åŠ¨ä¸€ä¸ª goroutineï¼Œå¹¶è¯•å›¾å‘é€ `"ping"`ã€‚
- **Step 2**: **ç”±äº `messages` æ˜¯æ— ç¼“å†²é€šé“ï¼Œ`messages <- "ping"` ä¸èƒ½ç«‹å³å®Œæˆ**ï¼Œå®ƒå¿…é¡»ç­‰ `msg := <-messages` æ‰§è¡Œæ—¶ï¼Œæ‰ä¼šçœŸæ­£å‘é€æ•°æ®ã€‚
- **Step 3**: `msg := <-messages` åœ¨ `main` goroutine ä¸­æ‰§è¡Œï¼Œæ­¤æ—¶ `messages <- "ping"` **è§£é™¤é˜»å¡**ï¼Œæ•°æ®ä¼ é€’å‘ç”Ÿï¼Œä¸¤ä¸ª goroutine åŒæ—¶ç»§ç»­æ‰§è¡Œã€‚
- **Step 4**: `"ping"` è¢«æ‰“å°ï¼Œç¨‹åºç»“æŸã€‚

```go
package main

import "fmt"

func main() {

	//è¿™åˆ›å»ºäº†ä¸€ä¸ªæ— ç¼“å†²é€šé“ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œå‘é€å’Œæ¥æ”¶æ“ä½œéƒ½ä¼šé˜»å¡ï¼Œç›´åˆ°å¯¹æ–¹å‡†å¤‡å¥½
	messages := make(chan string)

	//åˆ›å»ºä¸€ä¸ªgoroutineï¼Œå°†æ¶ˆæ¯ä¼ å…¥é€šé“
	//ç”±äº messages æ˜¯æ— ç¼“å†²é€šé“ï¼Œå‘é€æ“ä½œä¼šé˜»å¡ï¼Œç›´åˆ° main çº¿ç¨‹æ¥æ”¶æ•°æ®
	go func() { messages <- "ping" }()
	//å°†æ¶ˆæ¯ä»é€šé“ä¸­å–å‡ºæ¥
	//main çº¿ç¨‹åœ¨è¿™é‡Œé˜»å¡ï¼Œç­‰å¾… messages é€šé“é‡Œæœ‰æ•°æ®
	msg := <-messages
	fmt.Println(msg)
}

```

##### ç¼“å†²é€šé“

ğŸ”¹ **æ— ç¼“å†²é€šé“ = ç”Ÿäº§è€… & æ¶ˆè´¹è€…å¿…é¡»åŒæ—¶å°±ç»ª** 

ğŸ”¹ **å¸¦ç¼“å†²é€šé“ = å…è®¸ç”Ÿäº§è€…å…ˆå­˜å‚¨æ•°æ®ï¼Œæ¶ˆè´¹è€…ç¨åå–å‡º**

å¯¹äºç¼“å†²é€šé“è€Œè¨€ï¼Œå¦‚æœé€šé“ä¸ºç©ºï¼Œé‚£å°±ä¼šé˜»å¡æ¶ˆè´¹è€…ï¼Œå¦‚æœé€šé“æ˜¯æ»¡çš„ï¼Œå°±ä¼šé˜»å¡ç”Ÿäº§è€…

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	messages := make(chan string, 2) // åˆ›å»ºä¸€ä¸ªç¼“å†²åŒºå¤§å°ä¸º 2 çš„é€šé“

	// ç”Ÿäº§è€… goroutine
	go func() {
		messages <- "hello"
		fmt.Println("Sent: hello") // ç«‹å³æ‰§è¡Œï¼Œä¸ä¼šé˜»å¡
		messages <- "world"
		fmt.Println("Sent: world") // ç«‹å³æ‰§è¡Œï¼Œä¸ä¼šé˜»å¡
		// ç”±äºç¼“å†²åŒºå·²æ»¡ï¼Œä¸‹é¢çš„å‘é€ä¼šé˜»å¡ï¼Œç›´åˆ°æœ‰æ¶ˆè´¹è€…æ¥æ”¶æ•°æ®
		messages <- "!"
		fmt.Println("Sent: !") // è¿™è¡Œä»£ç ä¼šç­‰å¾…
	}()

	// è®©ç”Ÿäº§è€…å…ˆæ‰§è¡Œä¸€ä¼šå„¿
	time.Sleep(2 * time.Second)

	// æ¶ˆè´¹è€…å–å‡ºæ•°æ®
	fmt.Println("Received:", <-messages)
	fmt.Println("Received:", <-messages)
	fmt.Println("Received:", <-messages) // è¿™é‡Œæ‰ä¼šè§£é™¤ç¬¬ä¸‰ä¸ªæ¶ˆæ¯çš„é˜»å¡
}

```

æ­£å¸¸æƒ…å†µä¸‹**ç”Ÿäº§è€…** å’Œ **æ¶ˆè´¹è€…** åªèƒ½**ä¸€æ¬¡å‘é€æˆ–æ¥æ”¶ä¸€ä¸ªæ•°æ®**ï¼Œä½†ä¹Ÿå¯ä»¥é€šè¿‡ä¼ åˆ‡ç‰‡ã€æˆ–è€…ä½¿ç”¨range é€šé“çš„æ–¹å¼ä¸€æ¬¡ä¼ é€’æˆ–è€…æ¥æ”¶å¤šä¸ªæ•°æ®

##### é€šé“åŒæ­¥

é€šè¿‡è®©ä¸»çº¿ç¨‹ä½œä¸ºæ¥æ”¶è€…é˜»å¡æ¥æ”¶æ¶ˆæ¯æ¥è¾¾åˆ°çº¿ç¨‹çš„åŒæ­¥

```go
package main

import (
	"fmt"
	"time"
)

func worker(done chan bool) {
	fmt.Println("worker")
	time.Sleep(time.Second)
	fmt.Println("done")

	done <- true

}

func main() {
	done := make(chan bool, 1)
	go worker(done)
	<-done

}

```

##### é€šé“æ–¹å‘

å½“ä½¿ç”¨é€šé“ä½œä¸ºå‡½æ•°å‚æ•°æ—¶ï¼Œå¯ä»¥æŒ‡å®šé€šé“çš„æ–¹å‘ï¼Œæ¥æé«˜ç¨‹åºçš„å®‰å…¨æ€§

```go
package main

import "fmt"

func ping(pings chan<- string, msg string) {
	pings <- msg
}

func pong(pings <-chan string, pongs chan<- string) {
	msg := <-pings
	pongs <- msg
}

func main() {
	pings := make(chan string, 1)
	pongs := make(chan string, 1)
	ping(pings, "passed message")
	pong(pings, pongs)
	fmt.Println(<-pongs)
}

```

##### select

å°†channelå’Œselectç»“åˆèµ·æ¥

`select` è¯­å¥ä½¿å¾—ä¸€ä¸ª goroutine å¯ä»¥ç­‰å¾…å¤šä¸ª **channel** çš„æ“ä½œï¼ˆæ¥æ”¶æˆ–å‘é€ï¼‰ã€‚å®ƒä¼š**é˜»å¡**ç›´åˆ°å…¶ä¸­ä¸€ä¸ª `case` å¯ä»¥æ‰§è¡Œï¼ˆå³æŸä¸ª channel å®Œæˆäº†æ¥æ”¶æˆ–å‘é€ï¼‰ã€‚å¦‚æœæœ‰å¤šä¸ª `case` åŒæ—¶å‡†å¤‡å¥½ï¼Œ`select` ä¼šéšæœºé€‰æ‹©å…¶ä¸­ä¸€ä¸ªæ‰§è¡Œ

```go
package main

import (
    "fmt"
    "time"
)

func main() {

    c1 := make(chan string)
    c2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        c1 <- "one"
    }()
    go func() {
        time.Sleep(2 * time.Second)
        c2 <- "two"
    }()
		//å¦‚æœå•ç‹¬æ¥æ”¶ä¸¤ä¸ªé‚£å°±ä¼š3sï¼Œè€Œä½¿ç”¨selectä¼šå¹¶è¡Œå¤„ç†ä¸¤ä¸ªé€šé“ï¼Œè¿™æ ·åªä¼šç”¨2s
    for i := 0; i < 2; i++ {
        select {
        case msg1 := <-c1:
            fmt.Println("received", msg1)
        case msg2 := <-c2:
            fmt.Println("received", msg2)
        }
    }
}
```

##### è¶…æ—¶

è¿™é‡Œæ˜¯æ¨¡æ‹Ÿä¸€ä¸ªè¶…æ—¶çš„åœºæ™¯ï¼Œå³åœ¨è°ƒç”¨å…¶ä»–åº”ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œè™½ç„¶éœ€è¦è¯¥åº”ç”¨çš„è¿”å›å€¼ï¼Œä½†æ˜¯ä¸»çº¿ç¨‹æœ‰æå…¶ä¸¥æ ¼çš„æ—¶é—´è¦æ±‚ï¼Œæ‰€ä»¥å½“è¶…è¿‡è§„å®šæ—¶é—´åï¼Œä¸»çº¿ç¨‹å°±ä¼šå†³å®šè¿›è¡Œè¶…æ—¶å¤„ç†ï¼Œæ”¾å¼ƒè¿”å›å€¼

è¿™é‡Œä½¿ç”¨åˆ°çš„å°±æ˜¯selectï¼Œ`<-time.After` ç­‰å¾…åœ¨ 1 ç§’çš„è¶…æ—¶åå‘é€å€¼

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	//è¿™é‡Œä½¿ç”¨çš„ç¼“å†²é€šé“ï¼Œè¿™æ ·goroutineåœ¨å°†æ•°æ®æ”¾å…¥é€šé“åï¼Œå°±å¯ä»¥ç»“æŸ
	c1 := make(chan string,1)
	go func() {
		//æ¨¡å‹åº”ç”¨éœ€è¦2sæ‰èƒ½è¿”å›ç»“æœ
		time.Sleep(2 * time.Second)
		c1 <- "result 1"
	}()
	//selectæ˜¯æ¯æ¬¡åªä¼šé€‰æ‹©ä¸€ä¸ªcaseé‡Œé¢çš„æ‰§è¡Œï¼Œç„¶åå°±ä¼šè·³è¿‡
	//æ‰€ä»¥è¿™é‡Œå³ä¾¿resæ²¡æœ‰ä»é€šé“ä¸­æ¥æ”¶å€¼ï¼Œä¹Ÿä¸ä¼šé˜»å¡ï¼Œåœ¨æ‰§è¡Œè¿‡è¶…æ—¶å¤„ç†ä¹‹åï¼Œå°±ä¼šå¾€ä¸‹è¿›è¡Œæ‰§è¡Œ
	select {
	case res := <-c1:
		fmt.Println(res)
    //å¦‚æœè¶…è¿‡1sï¼Œå°±ä¼šæ‰§è¡Œè¿™æ¡è¯­å¥ï¼Œè¿›è¡Œè¶…æ—¶å¤„ç†
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	}

	c2 := make(chan string, 1)
	go func() {
		time.Sleep(2 * time.Second)
		c2 <- "result 2"
	}()
	select {
	case res := <-c2:
		fmt.Println(res)
	case <-time.After(3 * time.Second):
		fmt.Println("timeout 2")
	}
}

/*
timeout 1
result 2
*/
```

##### éé˜»å¡é€šé“æ“ä½œ

`select` è¿˜å¯ä»¥é…åˆ `default` è¯­å¥æ¥å®ç° **éé˜»å¡æ“ä½œ**ã€‚å¦‚æœæ‰€æœ‰çš„ `case` éƒ½ä¸èƒ½ç«‹åˆ»æ‰§è¡Œï¼Œ`select` ä¼šè¿›å…¥ `default`ï¼Œé¿å…é˜»å¡

```go
package main

import "fmt"

func main() {
	messages := make(chan string)
	signals := make(chan bool)

	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	default:
		fmt.Println("no message received")
	}

	msg := "hi"
	select {
	case messages <- msg:
		fmt.Println("sent message", msg)
	default:
		fmt.Println("no message sent")
	}

	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	case sig := <-signals:
		fmt.Println("received signal", sig)
	default:
		fmt.Println("no activity")
	}
}

```

##### å…³é—­é€šé“

å…³é—­é€šé“å¯ä»¥ç”¨äºä¸çŸ¥é“é€šé“å†…å®¹æœ‰å¤šå°‘ï¼Œè¦ä½¿ç”¨forå¾ªç¯ä¸€ç›´æ¥æ”¶çš„æƒ…å†µ

```go
package main

import "fmt"

func main() {
	jobs := make(chan int, 5)
	done := make(chan bool)

	go func() {
    //è¿™é‡Œä½¿ç”¨æ­»å¾ªç¯ï¼Œä¸€ç›´ä»é€šé“ä¸­è·å–å€¼
    //åªæœ‰é€šé“å·²ç»å…³é—­ï¼Œä¸”æ²¡æœ‰å‰©ä½™æ•°æ®æ—¶çš„æ—¶å€™moreå°±ä¼šä¸ºfalse
		for {
      //ä½¿ç”¨çš„æ˜¯æœ‰ç¼“å†²çš„é€šé“ï¼Œæ‰€ä»¥ä½œä¸ºæ¥æ”¶è€…ï¼Œå½“é€šé“æœ‰å†…å®¹å°±ä¼šè¿›è¡Œä¸‹å»ï¼Œæ²¡æœ‰å°±ä¼šé˜»å¡
			j, more := <-jobs
			if more {
				fmt.Println("received job", j)
			} else {
				fmt.Println("received all jobs")
				done <- true
				return
			}
		}
	}()
	//å› ä¸ºä½¿ç”¨çš„æ˜¯ç¼“å†²é€šé“ï¼Œæ‰€ä»¥å¯ä»¥ä¸€æ¬¡æ€§å…¨æ”¾è¿›é€šé“ï¼Œå¾€ä¸‹èµ°ä¸‹å»
	for j := 1; j <= 3; j++ {
		jobs <- j
		fmt.Println("sent job", j)
	}
  //å…³é—­é€šé“
	close(jobs)
	fmt.Println("sent all jobs")
	//ä½¿ç”¨é€šé“é˜»å¡çš„æ–¹å¼ç­‰goroutineç»“æŸ
	<-done
	//åªæœ‰é€šé“å·²ç»å…³é—­ï¼Œä¸”æ²¡æœ‰å‰©ä½™æ•°æ®æ—¶ï¼Œokä¸ºfalse
	_, ok := <-jobs
	fmt.Println("received more jobs:", ok)
}
```

##### rangeé€šé“

```go
package main

import "fmt"

func main() {

	queue := make(chan string, 2)
	queue <- "one"
	queue <- "two"
	close(queue)
	//å…³é—­é€šé“åï¼Œä¹Ÿå¯ä»¥ç»§ç»­éå†ï¼Œä»é€šé“ä¸­å–å€¼
	for elem := range queue {
		fmt.Println(elem)
	}
}

```

##### è®¡æ•°å™¨

æˆ‘ä»¬ç»å¸¸å¸Œæœ›åœ¨æœªæ¥çš„æŸä¸ªæ—¶é—´ç‚¹æ‰§è¡Œ Go ä»£ç ï¼Œæˆ–è€…ä»¥æŸä¸ªé—´éš”é‡å¤æ‰§è¡Œã€‚Go çš„å†…ç½® *è®¡æ—¶å™¨*å’Œ*ä»£ç è¡Œè·*åŠŸèƒ½ä½¿è¿™ä¸¤é¡¹ä»»åŠ¡éƒ½å˜å¾—ç®€å•

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	//åˆ›å»ºäº†ä¸€ä¸ªå®šæ—¶å™¨ timer1ï¼Œå®ƒå°†åœ¨ 2 ç§’åè§¦å‘ï¼Œå¹¶é€šè¿‡ timer1.C å‘é€ä¸€ä¸ªå€¼
	timer1 := time.NewTimer(2 * time.Second)
	//ç”¨äºé˜»å¡å½“å‰ goroutineï¼Œç›´åˆ°å®šæ—¶å™¨çš„ channel C è¢«è§¦å‘ï¼ˆä¹Ÿå°±æ˜¯ 2 ç§’åï¼‰
	<-timer1.C
	fmt.Println("Timer 1 fired")

	timer2 := time.NewTimer(2 * time.Second)
	go func() {
		//ç„¶åå¯åŠ¨ä¸€ä¸ªæ–°çš„ goroutine æ¥ç›‘å¬ timer2.C
		//è¿™é‡Œå¦‚æœå®šæ—¶å™¨æ˜¯è¢«å…³é—­çš„ï¼Œé€šé“å°±ä¼šç«‹åˆ»å…³é—­ï¼Œè¿”å›0å€¼ï¼Œåé¢çš„å°±ä¸æ‰§è¡Œäº†
		fmt.Println("1")
		//è¯­å¥ç«‹å³è¿”å›å¹¶ç»§ç»­æ‰§è¡Œä»£ç ï¼Œdefer è¯­å¥ç¡®å®æ²¡æœ‰æœºä¼šæ‰§è¡Œ
		defer fmt.Println("2")
		<-timer2.C
		fmt.Println("Timer 2 fired")
	}()
	//è°ƒç”¨ä¼šå°è¯•åœæ­¢å®šæ—¶å™¨ã€‚
	//å¦‚æœå®šæ—¶å™¨è¿˜æ²¡æœ‰è§¦å‘ï¼Œå®ƒä¼šæˆåŠŸåœæ­¢ï¼Œè¿”å› trueã€‚
	//å¦‚æœå®šæ—¶å™¨å·²ç»è§¦å‘ï¼Œå®ƒä¼šè¿”å› false
	time.Sleep(time.Second)
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

	time.Sleep(2 * time.Second)
}
/*
Timer 1 fired
1
Timer 2 stopped
*/
```

##### ticker

timerç”¨äºæƒ³æœªæ¥æŸæ®µæ—¶é—´ååšä¸€ä»¶äº‹ï¼Œtickerç”¨äºæƒ³è¦å®šæœŸé‡å¤åšæŸä»¶äº‹

tickerå’Œtimeræœ‰ç±»ä¼¼çš„æœºåˆ¶ï¼Œé€šè¿‡é€šé“æ¥å‘é€æ¶ˆæ¯ï¼Œè¡¨ç¤ºçŠ¶æ€

```go
package main

import (
    "fmt"
    "time"
)

func main() {

    ticker := time.NewTicker(500 * time.Millisecond)
    done := make(chan bool)

    go func() {
       for {
          select {
          case <-done:
             return
          //æ¯éš”500 * time.Millisecondå‘é€ä¸€æ¬¡
          case t := <-ticker.C:
             fmt.Println("Tick at", t)
          }
       }
    }()
		//ä¸»çº¿ç¨‹ä¼šåœ¨è¿™é˜»å¡ä¸€æ®µæ—¶é—´ï¼Œä»¥ä¾¿tickerå¤šå‘é€å‡ æ¬¡
    time.Sleep(1600 * time.Millisecond)
  	//å…³é—­ticker
    ticker.Stop()
    done <- true
    fmt.Println("Ticker stopped")
}
```

##### worker-pools

 ä¸»è¦ç”¨äºå¤„ç†**å¤§é‡å¹¶å‘ä»»åŠ¡**ï¼ŒåŒæ—¶åˆè¦**æ§åˆ¶èµ„æºä½¿ç”¨**ã€‚

å®ƒè§£å†³çš„æ ¸å¿ƒé—®é¢˜æ˜¯ï¼š**æœ‰å¾ˆå¤šä»»åŠ¡è¦å¤„ç†ï¼Œä½†ä¸èƒ½æ— é™åˆ¶åœ°å¼€å¯ goroutine æˆ–çº¿ç¨‹ï¼Œå¦åˆ™ä¼šè€—å°½èµ„æº**ã€‚

æœ¬è´¨ä¸Šç›¸å½“äºjavaä¸­çš„çº¿ç¨‹æ± ï¼Œé€šè¿‡é€šé“æ¥ä¼ é€’ä»»åŠ¡ï¼Œè¿™æ®µä»£ç çš„ä½œç”¨å°±æ˜¯åˆ›å»ºäº†ä¸‰ä¸ªçº¿ç¨‹ï¼Œä¸æ–­çš„ä»jobsä¸­å–ä»»åŠ¡æ‰§è¡Œ

```go
package main

import (
    "fmt"
    "time"
)

func worker1(id int, jobs <-chan int, results chan<- int) {
    for j := range jobs {
       fmt.Println("worker", id, "started job", j)
       time.Sleep(time.Second)
       fmt.Println("worker", id, "finished job", j)
       results <- j * 2
    }
}

func main() {
    const numJobs = 5
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)
    for w := 1; w <= 3; w++ {
      //å¯åŠ¨äº† 3 ä¸ªå¹¶å‘çš„ workerï¼ˆworker1 ~ worker3ï¼‰ï¼Œå®ƒä»¬å…±äº«åŒä¸€ä¸ª jobs é€šé“
       go worker1(w, jobs, results)
    }
    for j := 1; j <= numJobs; j++ {
      //å‘ jobs é€šé“å‘é€ 5 ä¸ªä»»åŠ¡ï¼ˆ1 åˆ° 5ï¼‰
       jobs <- j
    }
  	//å‘é€å®Œä»»åŠ¡åå…³é—­ jobs é€šé“ï¼Œé€šçŸ¥æ‰€æœ‰ worker æ²¡æœ‰ä»»åŠ¡äº†
    close(jobs)
    for a := 1; a <= numJobs; a++ {
      //ä¸»çº¿ç¨‹é€æ¬¡ä»é€šé“ä¸­æ‹¿å–ç»“æœï¼Œä¸»è¦ç”¨äºé˜»å¡ä¸»çº¿ç¨‹
       <-results
    }
}
```

##### WaitGroups

è¦ç­‰å¾…å¤šä¸ª goroutine å®Œæˆï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨WaitGroups

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker2(id int) {
	fmt.Printf("Worker %d starting\n", id)

	time.Sleep(time.Second)
	fmt.Printf("Worker %d done\n", id)
}

func main() {

	var wg sync.WaitGroup

	for i := 1; i <= 5; i++ {
		//å¯åŠ¨å¤šä¸ª goroutine å¹¶å¢åŠ æ¯ä¸ª goroutine çš„ WaitGroup è®¡æ•°å™¨
		wg.Add(1)
		//åˆ›å»ºä¸€ä¸ªé—­åŒ…ï¼Œè¿™ä¸ªçš„ç›®çš„æ˜¯å› ä¸ºwaitgroupéœ€è¦ä½¿ç”¨doneæ‰èƒ½ç®—ç»“æŸä¸€ä¸ª
		//æ‰€ä»¥æ˜¯éœ€è¦defer wg.Done()ï¼Œä¸ºäº†è§£å¶ï¼Œä¸å°†æ— å…³ä»£ç å†™åˆ°worker2ä¸­ï¼Œæ‰€ä»¥å°±å¦åˆ›å»ºäº†ä¸€ä¸ªfunc
		go func() {
			defer wg.Done()
			worker2(i)
		}()
	}

	wg.Wait()

}

```

##### é€Ÿç‡é™åˆ¶

