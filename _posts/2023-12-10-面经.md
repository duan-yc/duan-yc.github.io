---
layout: post
title: "面经"
subtitle: "面经"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
  - java
---

### 面经

[参考](https://javaguide.cn/java/basis/java-basic-questions-01.html#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)

#### java基础面试题总结

###### Java SE vs Java EE

Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序

###### JVM vs JDK vs JRE

JVM是java运行字节码的虚拟机，有针对不同系统的的实现，程序编译成字节码，通过JVM，就可以在不同系统上运行，得到相同的结果

JDK是java开发者工具，提供给开发者使用，能够创建和编译java程序，其包含了JRE，并且包含编译器等

JRE是java运行环境，包含了Java程序运行时候的环境，和必须的库

如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码

![image-20231215195252063](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231215195252063.png)

###### 字节码

在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。

由于**字节码并不针对一种特定的机器**，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行

从字节码到机器码这一段，JVM会加载字节码文件，然后通过解释器逐行解释执行，这种方式比较慢，所以后面引入JIT，会在第一次编译之后，将字节码对应的机器码保存起来，供下次使用，所以速度更快  对热点代码进行保存

![image-20231216154345640](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231216154345640.png)

高级编程语言按照程序的执行方式分为两种：

- 编译型：通过编译器将代码一次性翻译成可被该平台执行的机器码，执行速度比较快，开发效率比较低
- 解释型：通过解释器将代码一句一句的将代码解释（interpret）为机器代码后再执行。开发效率比较快，执行速度比较慢

Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

###### AOT

这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译，AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。

但AOT也存在一些缺点，所以只能说 AOT 更适合当下的**云原生场景**，对微服务架构的支持也比较友好，OT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了

###### Java与c++区别

Java 不提供指针来直接访问内存，程序内存更加安全

Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。

Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。

C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

###### 标识符和关键字

标识符是程序、类、变量、方法等的名字，关键字是Java 语言已经赋予了其特殊的含义，只能用于特定的地方。**关键字是被赋予特殊含义的标识**符，所有的关键字都是小写的，在 IDE 中会以特殊颜色显示

⚠️ 注意：虽然 `true`, `false`, 和 `null` 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。

###### 移位运算符

`<<` :左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。

`>>` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。

`>>>` :无符号右移，忽略符号位，空位都以 0 补齐。

由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。

移位操作符实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作。

当 **int 类型左移/右移位数大于等于 32 位操作**时，会**先求余（%）后再进行左移/右移操作**。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。

###### 基本数据类型

![image-20231216165137530](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231216165137530.png)

Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析

这八个基本类型都有自己的**包装类**，比如说int的包装类是Integer

下面是包装类和基本类型的区别

- **包装类型可用于泛型**，而基本类型不可以
- 相比于包装类型（对象类型）， **基本数据类型占用的空间往往非常小**
- **基本数据类型的局部变量**存放在Java 虚拟机栈中的**局部变量表**中，**成员变量**被存放在 Java 虚拟机的**堆**中，**包装类型**属于对象类型，我们知道几乎所有对象实例都存在于**堆**中。
- 对于**基本数据类型**来说，**`==`** 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型**包装类对象**之间值的比较，全部使用 **`equals()`** 方法

###### 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了**缓存机制**来提升性能

**Byte，Short，Integer，Long** 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，**`Character`** 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 True or False

缓存机制代表了在这个范围内，定义相同的值，两个值的内存地址是一样的，**Float和Double没有实现缓存机制**

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```

###### 自动装箱和拆箱

- **装箱**：将**基本类型**用它们对应的**引用类型**包装起来；
- **拆箱**：将**包装类型**转换为**基本数据类型**；

```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作**

###### 解决浮点数运算精度丢失的问题

`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

```java
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("0.9");
BigDecimal c = new BigDecimal("0.8");

BigDecimal x = a.subtract(b);
BigDecimal y = b.subtract(c);

System.out.println(x); /* 0.1 */
System.out.println(y); /* 0.1 */
System.out.println(Objects.equals(x, y)); /* true */
```

在使用`BigDecimal`的时候

![image-20231219183416527](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219183416527.png)

对于`BigDecimal`方法有自己的数据操作的方法

```java
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("0.9");
System.out.println(a.add(b));// 1.9
System.out.println(a.subtract(b));// 0.1
System.out.println(a.multiply(b));// 0.90
System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常
System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11

```

![image-20231219184907404](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219184907404.png)

工具类

```java
import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * 简化BigDecimal计算的小工具类
 */
public class BigDecimalUtil {

    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;

    private BigDecimalUtil() {
    }

    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.add(b2).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double subtract(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.subtract(b2).doubleValue();
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double multiply(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.multiply(b2).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2) {
        return divide(v1, v2, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();
    }

    /**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b = BigDecimal.valueOf(v);
        BigDecimal one = new BigDecimal("1");
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    }

    /**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static float convertToFloat(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.floatValue();
    }

    /**
     * 提供精确的类型转换(Int)不进行四舍五入
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static int convertsToInt(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.intValue();
    }

    /**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static long convertsToLong(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.longValue();
    }

    /**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */
    public static double returnMax(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.max(b2).doubleValue();
    }

    /**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */
    public static double returnMin(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.min(b2).doubleValue();
    }

    /**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */
    public static int compareTo(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.compareTo(b2);
    }

}

```

###### 成员变量和局部变量

- **成员变量可以被 `public`,`private`,`static` 等修饰符所修饰**，而**局部变量不能**被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰
- 从变量在内存中的存储方式来看，如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而**对象存在于堆内存，局部变量则存在于栈内存。**
- 从变量在内存中的生存时间上看，**成员变量**是对象的一部分，它**随着对象的创建而存在**，而**局部变量**随着**方法的调用而自动生成**，随着方法的调用结束而消亡
- **成员变量如果没有被赋初始值**，则会自动以类型的**默认值**而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值

###### 静态变量

被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量

###### 静态方法为什么不能调用非静态成员

- 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问
- 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

**静态方法和实例方法的不同**

- 在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 
- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制

###### 重载和重写

**重载**是同一个方法，拥有**相同的方法名，但输入数据不同**，这样**编译器**必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。

```java
StringBuilder sb = new StringBuilder();
StringBuilder sb2 = new StringBuilder("HelloWorld");
```

**重写**是**子类继承自父类的相同方法**，**输入数据一样**，但要做出有别于父类的响应时，你就要覆盖父类方法,重写发生在运行期，是**子类对父类的允许访问的方法的实现过程**进行重新编写

1. 方法名、参数列表必须相同，**子类方法返回值类型应比父类方法返回值类型更小或相等**，抛出的**异常范围小于等于父类**，**访问修饰符范围大于等于父类**。
2. 如果父类方法访问修饰符为 **`private/final/static`** 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被**再次声明**。
3. **构造方法无法被重写**

![image-20231217120803615](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231217120803615.png)

⭐️ 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

**遇到方法重载会优先匹配固定参数的方法，因为固定参数的方法匹配度更高**

###### 面向对象的三大特征

**封装**

一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

**继承**

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类

关于继承有几个点需要注意的

- 子类不能直接访问父类的私有方法和私有变量。私有方法和变量只在定义它们的类内部可见，这是封装的一个重要方面，不过可以通过共有方法或者protect方法进行访问
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
- 子类可以用自己的方式实现父类的方法

**多态**

对象可以采用多种形态。在 Java 中，多态主要通过继承（inheritance）和接口（interfaces）以及方法的重写（overriding）和重载（overloading）来实现。多态使得我们可以用统一的方式处理不同类型的对象

**实现方法**

- 方法重写：子类重写父类的方法。当子类对象调用这个方法时，执行的是子类中重写的版本
- 方法重载：同一个类中多个同名方法，但它们的参数列表不同
- 向上转型：子类对象可以被当作父类对象使用。例如，如果有一个父类 `Animal` 和一个子类 `Dog`，那么 `Dog` 对象也可以被当作 `Animal` 对象使用。这使得你可以用 `Animal` 类型的变量来引用一个 `Dog` 对象
- 一个类实现一个接口，它需要提供接口中所有方法的具体实现。一个接口引用可以指向任何实现了该接口的类的对象

```java
// 父类
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

// 子类
class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

// 主程序
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // 创建 Animal 对象
        Animal myDog = new Dog();        // 创建 Dog 对象，但将其视为 Animal

        myAnimal.sound();  // 输出: Animal makes a sound
        myDog.sound();     // 输出: Dog barks，尽管 myDog 被声明为 Animal 类型
    }
}
```

###### 接口和抽象类

共同点：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法

区别：

- 接口里只有抽象方法，抽象类可以有非抽象方法
- 一个类只能继承一个类，但是可以实现多个接口
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值

###### 深拷贝和浅拷贝

- 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

![image-20231218161815217](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218161815217.png)

```java
String a = new String("ab"); // a 为一个引用
String b = new String("ab"); // b为另一个引用,对象的内容一样
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true
```

###### hashCode

`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置

如果两个对象的**`hashCode` 值相等**，那这两个**对象不一定相等**（哈希碰撞）。

如果两个对象的**`hashCode` 值相等并且`equals()`方法也返回 `true`**，我们才认为这两个对象相等。

如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等

###### **String、StringBuffer、StringBuilder 的区别**

**可变性**

`String` 是不可变的

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法

**线程安全性**

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。

`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。

`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

`String` 类型进行改变的时候，都会生成一个新的 `String` 对象

`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。

相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险

**总结**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

###### String类型的不可变性

`String` 类中使用 `final` 关键字修饰字符数组来保存字符串，但这不是其不可变的原因，因为对于final来说，被 `final` 关键字**修饰的类不能被继承**，修饰的**方法**不能被**重写**，修饰的**变量**是**基本数据类型**则值**不能改变**，修饰的变量是**引用类型**则**不能再指向其他对象**

不可变的原因：

1. 保存字符串的数组被 `final` 修饰且为**私有**的，并且`String` 类没**有提供/暴露修改这个字符串的方法**。
2. `String` 类被 `final` 修饰导致其**不能被继承**，进而**避免了子类破坏 `String` 不可变**。

###### 字符串拼接用“+” 还是 StringBuilder

字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 

即先创建StringBuilder对象，然后用append进行拼接，然后toString转回String对象

这种方式会创建多个StringBuilder对象，空间上产生了浪费

如果直接使用 `StringBuilder` 对象进行字符串拼接的话，就不会存在这个问题了。

```java
String[] arr = {"he", "llo", "world"};
StringBuilder s = new StringBuilder();
for (String value : arr) {
    s.append(value);
}
System.out.println(s);

```

**`String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址**

###### String s1 = new String("abc")

上面这句话会创建1-2个对象，依据常量池中是否含有该字符串常量来判断

- 如果常量池含有该字符串常量

  则会创建一个对象，即new的时候会创建一个对象

- 如果常量池不含有该字符串常量

  会创建两个对象，new的时候会创建一个对象，然后会创建一个字符串对象abc，进行赋值

###### intern 方法的作用

`String.intern()` 是一个 native（本地）方法，其作用是**将指定的字符串对象的引用保存在字符串常量池中**，可以简单分为两种情况：

- 如果字符串常量池中**保存了对应的字符串对象的引用**，就**直接返回该引用**。
- 如果字符串常量池中**没有保存了对应的字符串对象的引用**，那就在**常量池中创建一个指向该字符串对象的引用**并返回。

```java
// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = "Java";
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String("Java");
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true
```

![image-20231218184007388](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218184007388.png)

###### 异常处理

![image-20231218184213110](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218184213110.png)

###### 受检测异常和非受检测异常

**Checked Exception** 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 `catch`或者`throws` 关键字处理的话，就没办法通过编译

**Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译

除了`RuntimeException`及其子类以外，**其他的`Exception`类及其子类都属于受检查异常** 。常见的受检查异常有：IO 相关的异常、`ClassNotFoundException`、`SQLException`...。

###### Throwable类常用方法

- `String getMessage()`: 返回异常发生时的简要描述
- `String toString()`: 返回异常发生时的详细信息
- `String getLocalizedMessage()`: 返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同
- `void printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息

###### try-catch-finally

try作用是捕获异常，catch是处理异常，finally是最后都是进入finally

**当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行**。

因此**注意：不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值

并且finally中的代码也不是一定会执行，就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。或者程序所在的线程死亡，关闭 CPU。

###### try-with-resources

面对必须要关闭的资源，我们总是应该优先使用 `try-with-resources` 而不是`try-finally`。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。`try-with-resources`语句让我们更容易编写必须要关闭的资源的代码，若采用`try-finally`则几乎做不到这点。

```java
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
    int b;
    while ((b = bin.read()) != -1) {
        bout.write(b);
    }
}
catch (IOException e) {
    e.printStackTrace();
}
```

###### 泛型

允许在类、接口和方法中使用类型参数。它提供了编译时类型安全检查的优点，这意味着您可以在编译时捕获到不正确的类型使用，而不是在运行时。泛型的引入减少了对强制类型转换的需求，并提供了更加抽象和通用的编程方式。

泛型一般使用有三种方式

- 泛型类

  ```java
  //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
  //在实例化泛型类时，必须指定T的具体类型
  public class Generic<T>{
  
      private T key;
  
      public Generic(T key) {
          this.key = key;
      }
  
      public T getKey(){
          return key;
      }
  }
  ```

- 泛型接口

  ```java
  public interface Generator<T> {
      public T method();
  }
  
  ```

- 泛型方法

  ```java
     public static < E > void printArray( E[] inputArray )
     {
           for ( E element : inputArray ){
              System.out.printf( "%s ", element );
           }
           System.out.println();
      }
  ```

###### 反射

在运行时分析类以及执行类中方法的能力，通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性

其主要使用步骤：

1. **在运行时获取类的信息**： 反射可以用来在运行时获取类的信息，比如类的名称、方法、字段和注解等。这对于理解未知代码或动态生成代码非常有用。
2. **动态创建对象和调用方法**： 使用反射可以动态地创建对象和调用方法，即使在编译时这些类或方法是未知的。
3. **修改字段值**： 即使字段被声明为私有，反射也能够修改它们的值。

```java
public class ReflectionExample {
    private int number;
    private String name;

    public ReflectionExample(int number, String name) {
        this.number = number;
        this.name = name;
    }

    public void printInfo() {
        System.out.println("Number: " + number + ", Name: " + name);
    }

    public static void main(String[] args) throws Exception {
        // 使用反射创建对象
        Class<?> clazz = ReflectionExample.class;
        Constructor<?> constructor = clazz.getConstructor(int.class, String.class);
        Object instance = constructor.newInstance(10, "Test");

        // 调用方法
        Method method = clazz.getMethod("printInfo");
        method.invoke(instance);

        // 访问字段
        Field field = clazz.getDeclaredField("name");
        field.setAccessible(true); // 对于私有字段需要这样做
        field.set(instance, "New Name");
        method.invoke(instance);
    }
}

```

缺点：

- 反射操作通常比直接的 Java 代码执行要慢，因为涉及到动态类型检查和方法调用。
- 反射破坏了封装，可能会导致意外的副作用，尤其是在访问私有字段和方法时。
- 在受限的环境（如 Applet 或服务器应用程序）中，安全策略可能会限制反射的使用。

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以**基于反射分析类**，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。

**获取class对象的四种方式**

![image-20231219171551905](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219171551905.png)

###### 代理模式

**使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作**

代理模式有**静态代理和动态代理**两种实现方式

**静态代理**

**静态代理中，我们对目标对象的每个方法的增强都是手动完成的（\*后面会具体演示代码\*），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改\*）且麻烦(\*需要对每个目标类都单独写一个代理类）**

**静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**

静态代理的步骤：

1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

**动态代理**

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类

使用步骤：

1. 定义一个接口，声明需要代理的方法。
2. 创建一个实现了 `InvocationHandler` 接口的类，并定义在方法调用时想要执行的逻辑。
3. 使用 `Proxy.newProxyInstance` 方法创建代理对象，这个方法需要三个参数：类加载器、一组接口以及 `InvocationHandler` 实例。



###### 注解的分析方式

- **编译期直接扫描**：编译器在**编译 Java 代码的时候扫描对应的注解并处理**，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过**反射**来进行处理的。

###### SPI

![image-20231219154053778](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219154053778.png)

API是接口提供方提供方法实现，用户就可以直接调用接口进行使用

SPI是由**接口调用方确定接口规则**，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。

SPI机制能够大大地提高接口设计的灵活性，但也有一些缺点

- 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。
- 当多个 `ServiceLoader` 同时 `load` 时，会有并发问题。

###### 序列化和反序列化

- **序列化**：将**数据结构或对象转换成二进制字节流的过程**
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

序列化的都是对象（Object）也就是实例化后的类(Class)

**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**

序列化协议在osi七层协议中是表示层，在tcp/ip四层协议中就是应用层

![image-20231219155537932](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219155537932.png)

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

关于 `transient` 还有几点注意：

- `transient` **只能修饰变量，不能修饰类和方法**。
- `transient` 修饰的变量，在**反序列化后变量值将会被置成类型的默认值**。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

[JDK自带的也有序列化方式](https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/)，但一般不使用，其原因是：

- **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
- **性能差**：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
- **存在安全问题**：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。

###### I/O

Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- `InputStream`/`Reader`: 所有的输入流的基类，**前者是字节输入流，后者是字符输入流**。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

![](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219163727170.png)

###### 语法糖

为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读，例如for-each

不过，**JVM 其实并不能识别语法糖**，Java 语法糖要想被正确执行，**需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法**。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM

###### 参数传递

在java中引用传递，传递的是引用类型的地址

```java
public class Person {
    private String name;
   // 省略构造函数、Getter&Setter方法
}

public static void main(String[] args) {
    Person xiaoZhang = new Person("小张");
    Person xiaoLi = new Person("小李");
    swap(xiaoZhang, xiaoLi);
    System.out.println("xiaoZhang:" + xiaoZhang.getName());
    System.out.println("xiaoLi:" + xiaoLi.getName());
}

public static void swap(Person person1, Person person2) {
    Person temp = person1;
    person1 = person2;
    person2 = temp;
    System.out.println("person1:" + person1.getName());
    System.out.println("person2:" + person2.getName());
}


输出：
  person1:小李
  person2:小张
  xiaoZhang:小张
  xiaoLi:小李

```

像上面这种情况，记住传递的是地址，所以swap中进行交换，只是把这些对象指向的地址换了，在原方法中这些对象的地址是没变的

###### Unsafe

主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等

#### 集合面试题

![image-20231219204406441](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219204406441.png)

##### List

###### ArrayList和Array**的区别**

`ArrayList` 内部基于动态数组实现，比 `Array`（静态数组） 使用起来更加灵活：

- `ArrayList`会根据实际存储的元素动态地扩容或缩容，而 `Array` 被创建之后就不能改变它的长度了。
- `ArrayList` 允许你使用泛型来确保类型安全，`Array` 则不可以。
- `ArrayList` 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。`Array` 可以直接存储基本类型数据，也可以存储对象。
- `ArrayList` 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 `add()`、`remove()`等。`Array` 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。

`ArrayList`创建时不需要指定大小，而`Array`创建时必须指定大小。

![image-20231219224346858](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219224346858.png)

###### ArrayList插入和删除元素时间复杂度

对于插入：

- 头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。
- 尾部插入：当 `ArrayList` 的容量**未达到极限**时，往列表末尾插入元素的**时间复杂度是 O(1)**，因为它只需要在数组末尾添加一个元素即可；当**容量已达到极限并且需要扩容时**，则**需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中**，然后再执行 O(1) 的操作添加元素。
- 指定位置插入：**需要将目标位置之后的所有元素都向后移动一个位置**，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。

对于删除：

- 头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。
- 尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。
- 指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。

###### LinkedList 插入和删除元素

头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。

尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。

指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)

###### ArrayList 与 LinkedList 区别

- **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
- **底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）
- **插入和删除是否受元素位置的影响：**
  - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
  - `LinkedList` 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()`、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`,`remove(int index)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。
- **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 **`ArrayList`（实现了 `RandomAccess` 接口） 支持**。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
- **内存空间占用：** **`ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）**

##### Set

###### Comparable 和 Comparator 的区别

`Comparable` 接口和 `Comparator` 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：

- `Comparable` 接口实际上是出自`java.lang`包 它有一个 `compareTo(Object obj)`方法用来排序
- `Comparator`接口实际上是出自 `java.util` 包它有一个`compare(Object obj1, Object obj2)`方法用来排序

###### 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

底层实现不同

- `HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
- `HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。`TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
- 底层数据结构不同又导致这三者的应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。

##### Queue

###### Queue 与 Deque 的区别

**![](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221155138555-20231221160730944-20231221160751391.png)**

###### ArrayDeque 与 LinkedList 的区别

- `ArrayDeque` 是基于可变长的数组和双指针来实现，而 `LinkedList` 则通过链表来实现。
- `ArrayDeque` 不支持存储 `NULL` 数据，但 `LinkedList` 支持。
- `ArrayDeque` 是在 JDK1.6 才被引入的，而`LinkedList` 早在 JDK1.2 时就已经存在。
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好

###### PriorityQueue

其与 `Queue` 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。

- `PriorityQueue` 利用了**二叉堆的数据结构**来实现的，底层使用可变长的数组来存储数据

- `PriorityQueue` 通过**堆元素的上浮和下沉**，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。

- `PriorityQueue` 是**非线程安全**的，且不支持存储 `NULL` 和 `non-comparable` 的对象。

- `PriorityQueue` 默认是**小顶堆**，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

###### BlockingQueue

`BlockingQueue` （阻塞队列）是一个接口，继承自 `Queue`。`BlockingQueue`阻塞的原因是**其支持当队列没有元素时一直阻塞，直到有元素**；还支持如果**队列已满**，一直**等到队列可以放入新元素时再放入**。

BlockingQueue接口有很多实现类，包括ArrayBlockingQueue、LinkedBlockingQueue等

###### ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别

- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。
- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。
- 锁是否分离： `ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。
- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。这意味着，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。

##### Map

###### HashMap 和 Hashtable 的区别

- **线程是否安全：** `HashMap` 是**非线程安全的**，`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证**线程安全的话就使用 `ConcurrentHashMap`** 吧！）；

- **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；

- **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。

- **初始容量大小和每次扩充容量大小的不同：** ① **创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍**。② 创建时如果给定了容量初始值，那么 `Hashtable` 会直接使用你给定的大小，而 **`HashMap` 会将其扩充为 2 的幂次方大小**（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小

  **原因是：**希望哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的，用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ `(n - 1) & hash`”

- **底层数据结构：** JDK1.8 以后的 **`HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树**（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。`Hashtable` 没有这样的机制。

hashmap设置初始容量时的源码，这段代码通过位运算确定最接近并大于等于给定容量 `cap` 的 2 的幂的值

```java
/**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

###### HashMap 和 HashSet 区别

`HashSet` 底层就是基于 `HashMap` 实现的。（`HashSet` 的源码非常非常少，因为除了 `clone()`、`writeObject()`、`readObject()`是 `HashSet` 自己不得不实现之外，其他方法都是直接调用 `HashMap` 中的方法

![image-20231221174219484](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221174219484.png)

######  HashMap 和 TreeMap 区别

`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口，因此**多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力**

###### HashSet 如何检查重复

当你把对象加入`HashSet`时，`HashSet` 会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功

###### HashMap 的底层实现

JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过**扰动函数**处理过后得到 **hash 值**，然后通过 `(n - 1) & hash` （取余）判断当前元素**存放的位置**（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 **hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突**。

**扰动函数**指的就是 HashMap 的 `hash` 方法。使用 `hash` 方法也就是扰动函数是为了防止一些实现比较差的 `hashCode()` 方法 换句话说**使用扰动函数之后可以减少碰撞**。

![image-20231221210113846](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221210113846.png)

JDK1.8 之后在解决哈希冲突时有了较大的变化，当**链表长度大于阈值**（默认为 8）（将链表转换成红黑树**前**会判断，**如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树**）时，将**链表转化为红黑树**，以减少搜索时间

红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

###### HashMap 多线程操作导致死循环问题

JDK1.7 及之前版本的 `HashMap` 在多线程环境下扩容操作可能存在死循环问题，其原因是当一个桶位中有**多个元素需要进行扩容**时，**多个线程同时对链表进行操作**，**头插法**可能会导致链表中的节点**指向错误的位置**，从而形成一个**环形链表**，进而使得查询元素的操作陷入死循环无法结束。

![image-20231222100747245](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222100747245.png)

JDK1.8 版本的 HashMap 采用了**尾插法**而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，**保持了节点原来的相对顺序**，避免了链表中的环形结构。但是还是不建议在多线程下使用 `HashMap`，因为多线程下使用 `HashMap` 还是会存在数据覆盖的问题。并发环境下，推荐使用 **`ConcurrentHashMap`** 。

###### HashMap 为什么线程不安全

**JDK1.7 及之前版本**，在多线程环境下，`HashMap` 扩容时会造成**死循环和数据丢失**的问题。

数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。

**JDK 1.8 后**，在 `HashMap` 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有**数据覆盖**的风险

发生数据丢失的情况：

1. 两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。
2. 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。
3. 随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了

###### HashMap 常见的遍历方式

1. 使用 `entrySet()` 遍历

   ```java
   Map<String, Integer> map = new HashMap<>();
   // ...添加元素到map中
   for (Map.Entry<String, Integer> entry : map.entrySet()) {
       System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
   }
   ```

2. 使用 `keySet()` 遍历

   ```java
   for (String key : map.keySet()) {
       System.out.println("Key = " + key + ", Value = " + map.get(key));
   }
   ```

3. 使用 `values()` 遍历

   ```java
   for (Integer value : map.values()) {
       System.out.println("Value = " + value);
   }
   ```

4. 使用 Java 8 的 `forEach`

   ```java
   map.forEach((key, value) -> System.out.println("Key = " + key + ", Value = " + value));
   ```

5. 使用迭代器

   ```java
   Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();
   while (iterator.hasNext()) {
       Map.Entry<String, Integer> entry = iterator.next();
       System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
   }
   ```

###### ConcurrentHashMap 和 Hashtable 的区别

- 底层数据结构

  ConcurrentHashMap：在JDK1.7之前**分段的数组+链表** ，在JDK1.8后**数组+链表/红黑二叉树**

  HashTable：在JDK1.7之前**数组+链表**，

- **实现线程安全的方式**

  ConcurrentMap：

  **JDK1.7之前**，对整个桶数组进行了**分割分段(`Segment`，分段锁)**，即 **Segment 数组 + HashEntry 数组 + 链表**，每一把锁只**锁容器其中一部分数据**，**多线程访问容器里不同数据段的数据**，就**不会存在锁竞争**，提高并发访问率。 

  ![image-20231222105333437](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222105333437.png)

  **JDK1.8之后** ，**已经摒弃了 `Segment` 的概念**，而是直接用 **`Node` 数组+链表+红黑树的数据结构**来实现，**并发控制使用 `synchronized` 和 CAS 来操作**。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

  Hashtable：

  使用 `synchronized` 来保证线程安全，效率非常低下

###### ConcurrentHashMap 线程安全的具体实现方式/底层具体实现

**JDK1.8 之前**

首先将数据分为一段一段（这个“段”就是 `Segment`）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，参照上图

**`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成**

一个 `ConcurrentHashMap` 里包含一个 `Segment` 数组，`Segment` 的个数一旦**初始化就不能改变**。 **`Segment` 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写**

每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的

**JDK1.8 之后**

`ConcurrentHashMap` **取消了 `Segment` 分段锁**，采用 **`Node + CAS + synchronized`** 来保证并发安全。数据结构跟 `HashMap` 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将**链表（寻址时间复杂度为 O(N)）转换为红黑树**（寻址时间复杂度为 O(log(N))）。

Java 8 中，**锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点**，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升

######  ConcurrentHashMap 为什么 key 和 value 不能为 null

key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，**表示没有对象或没有引用**。**如果你用 null 作为键，那么你就无法区分这个键是否存在于 `ConcurrentHashMap` 中，还是根本没有这个键**。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 `ConcurrentHashMap` 中的，还是因为找不到对应的键而返回的。

但**HashMap**可以存储，可以通过**containsKey来查找**，而ConcurrentHashMap，存在一个线程操作该 `ConcurrentHashMap` 时，**其他的线程将该 `ConcurrentHashMap` 修改的情况**，所以**无法通过 `containsKey(key)`** 来判断否存在这个键值对，也就没办法解决二义性问题了

**线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）**

###### ConcurrentHashMap 能保证复合操作的原子性吗

**复合操作**是指由多个基本操作(如`put`、`get`、`remove`、`containsKey`等)组成的操作，例如先判断某个键是否存在`containsKey(key)`，然后根据结果进行插入或更新`put(key, value)`。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期

`ConcurrentHashMap` 提供了一些**原子性的复合操作**，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。**这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中**

![image-20231222113526863](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222113526863.png)

##### 集合操作的注意事项

###### 集合判空

**判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式**

这是因为 `isEmpty()` 方法的可读性更好，并且时间复杂度为 O(1)，而ConcurrentLinkedQueue`、`ConcurrentHashMap的size( )的时间复杂度就不是O(1)

###### 集合转 Map

**在使用 `java.util.stream.Collectors` 类的 `toMap()` 方法转为 `Map` 集合时，一定要注意当 value 为 null 时会抛 NPE 异常**

```java
class Person {
    private String name;
    private String phoneNumber;
     // getters and setters
}

List<Person> bookList = new ArrayList<>();
bookList.add(new Person("jack","18163138123"));
bookList.add(new Person("martin",null));
// 空指针异常
bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));

```

因为toMap方法会调用`Map` 接口的 `merge()` 方法，`merge()` 方法会先调用 `Objects.requireNonNull()` 方法判断 value 是否为空。

###### 集合遍历

**不要在 foreach 循环里进行元素的 `remove/add` 操作。remove 元素请使用 `Iterator` 方式，如果并发操作，需要对 `Iterator` 对象加锁**

这是因为使用 `foreach` 循环（或 Java 中的增强型 for 循环）遍历集合时，底层用的是**集合的迭代器**实现，而**集合迭代器在遍历过程中要求集合结构保持不变**，所以会抛出`ConcurrentModificationException` 异常

而使用可以使用**迭代器（`Iterator`）的 `remove` 方法**。这种方式允许你在遍历时修改集合，而不会抛出 `ConcurrentModificationException`。

```java
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    if (someCondition(element)) {
        iterator.remove(); // 安全移除元素
    }
}
```

并且如果在**多线程环境中**，**多个线程同时遍历和修改同一个集合**，即使是使用迭代器的 `remove` 方法，也可能会遇到**并发问题**

所以在并发操作时，需要对**迭代器或集合对象加锁**，以保证在**一个线程遍历和修改集合时，其他线程不能进行修改**。这可以通过同步代码块或使用并发集合来实现，可以使用 `synchronized` 关键字来实现加锁

###### 集合去重

**可以利用 `Set` 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 `List` 的 `contains()` 进行遍历去重或者判断包含操作**

下面是Set和List去重的代码

```java
// Set 去重代码示例
public static <T> Set<T> removeDuplicateBySet(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new HashSet<>();
    }
    return new HashSet<>(data);
}

// List 去重代码示例
public static <T> List<T> removeDuplicateByList(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new ArrayList<>();

    }
    List<T> result = new ArrayList<>(data.size());
    for (T current : data) {
        if (!result.contains(current)) {
            result.add(current);
        }
    }
    return result;
}

```

两者的区别在于**`HashSet` 的 `contains()` 方法底部依赖的 `HashMap` 的 `containsKey()` 方法，时间复杂度接近于 O（1）**，而**`ArrayList` 的 `contains()` 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)**

###### 集合转数组

**使用集合转数组的方法，必须使用集合的 `toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。**

例如下面代码，传入new String[0]表示类型

下面的Arrays.asList方法，对list进行反转，同样的s数组也会反转

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};
List<String> list = Arrays.asList(s);
Collections.reverse(list);
//没有指定类型的话会报错
s=list.toArray(new String[0]);

```

最后一行虽然传入了一个长度为 0 的数组，但 Java 会根据列表的大小创建一个新的、合适大小的数组。

###### 数组转集合

使用工具类 `Arrays.asList()` 把数组转换成集合时，**不能使用其修改集合相关的方法**， 它的 `add/remove/clear` 方法会抛出 `UnsupportedOperationException` 异常

这里使用asList将数组转化为集合，只是传入了一个元素，list里面只有一个元素

```java
int[] myArray = {1, 2, 3};
List myList = Arrays.asList(myArray);
System.out.println(myList.size());//1
System.out.println(myList.get(0));//数组地址值
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
int[] array = (int[]) myList.get(0);
System.out.println(array[0]);//1
```

同时，使用集合的方法也会报错

```java
List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
```

所以要将数组转化为ArrayList可以用以下方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());

```

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```

##### 集合源码分析

###### ArrayList源码分析

数组队列，相当于动态数组，其容量能**动态增长**

在**添加大量元素**前，应用程序可以使用**`ensureCapacity`操作**来**增加 `ArrayList` 实例的容量**

```java

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{

  }

```

从这个继承关系可以看出

- `List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。
- `RandomAccess` ：这是一个标志接口，表明实现这个接口的 `List` 集合是支持 **快速随机访问** 的。在 `ArrayList` 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。
- `Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。
- `Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。

**ArrayList和vector的区别在于：**

- ArrayList是List的主要实现类，vector是以前的实现类
- ArrayList线程不安全，vector线程安全

**ArrayList扩容机制**

1. **初始容量**： 当创建 `ArrayList` 时，你可以指定一个初始容量。如果没有指定，`ArrayList` 将使用默认容量大小（在 Java 8 中，默认为 10）。
2. **添加元素**： 当向 `ArrayList` 添加元素且内部数组无法容纳更多元素时，`ArrayList` 需要扩容。
3. **新容量计算**： 新容量的计算公式取决于 `ArrayList` 的版本。在大多数实现中，新容量是旧容量的 1.5 倍。例如，如果当前容量为 10，扩容后将变为 15。这个增长率是一个折中的选择，旨在平衡内存使用和性能。
4. **创建新数组并复制元素**： `ArrayList` 会创建一个新的、更大的数组。然后，它将旧数组中的所有元素复制到新数组中。
5. **废弃旧数组**： 一旦旧数组中的元素被复制到新数组中，旧数组就会被废弃，以便垃圾收集器回收。

###### LinkedList源码分析

#### 并发

###### 线程和进程概念

**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程

在 Java 中，当我们**启动 main 函数**时其实就是启动了一个 **JVM 的进程**，而 **main 函数所在的线程**就是这个进程中的一个线程，也称**主线程**

**线程**是一个**比进程更小的执行单位**。一个进程在其执行的过程中可以**产生多个线程**。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为**轻量级进程**。

**一个 Java 程序的运行是 main 线程和多个其他线程同时运行**

###### 线程和进程的关系、区别及优缺点

一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器**、**虚拟机栈** 和 **本地方法栈**

 **线程是进程划分成的更小的运行单位**。线程和进程最大的不同在于基本上**各进程是独立的**，而**各线程则不一定**，因为**同一进程中的线程极有可能会相互影响**。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

###### 程序计数器为什么是私有的

程序计数器的作用：

1. 字节码解释器通过程序计数器来依次读取指令，从而实现代码的流程控制，如顺序执行，选择等
2. 在多线程的情况下，通过程序计数器来记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了

如果执行的是 **native 方法**，那么程序计数器记录的是 **undefined 地址**，**只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址**

`native` 关键字在 Java 中用于标识一个方法，表明该方法是用**非 Java 语言（如 C 或 C++）编写的**，并且在运行时由本地方法接口（JNI, Java Native Interface）调用。这些方法通常用于**执行不能直接用 Java 实现的操作**，如与操作系统交互、调用系统级别的库函数等。

**程序计数器私有**主要是为了**线程切换后能恢复到正确的执行位置**

###### 虚拟机栈和本地方法栈为什么是私有的

**虚拟机栈**：**每个java方法**在**执行前**会**创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息**。从**方法调用直至执行完成**的过程，就对应着**一个栈帧在 Java 虚拟机栈中入栈和出栈**的过程。

本地方法栈：和虚拟机栈的作用类似，从名字可以看出**本地方法栈是为虚拟机使用到的Native方法**服务

所以为了保证**线程中的局部变量不被其他线程访问到**，将其设置为私有的

###### 堆和方法区

堆和方法区是所有线程**共享的资源**，其中**堆是进程中最大的一块内存**，主要用于**存放新创建的对象**（几乎所有对象都在这里分配内存），**方法区主要用于存放已被加载的类信息，常量，静态变量，编译后的代码等数据**。

###### Java 线程和操作系统的线程有啥区别

**JDK1.2之前**：Java线程是基于**绿色线程**实现的，这是一种**用户级线程**（用户线程），和原生线程比起来在使用时有一些限制（比如绿色线程**不能直接使用操作系统提供的功能**如异步 I/O、只能在一个内核线程上运行，无法利用多核）

JDK1.2之后：Java 线程改为基于原生线程实现，**现在的 Java 线程的本质其实就是操作系统的线程**

###### 用户线程与内核线程

- **用户线程**：由**用户空间程序管理和调度的线程**，运行在**用户空间**（专门给应用程序使用）
- **内核线程**：由**操作系统内核管理和调度的线程**，运行在**内核空间**（只有内核程序可以访问）

即**用户线程创建和切换成本低**，但**不可以利用多核**。**内核态线程**，创建和切换成本**高**，可以**利用多核**

**线程模型是用户线程和内核线程**之间的**关联方式**，共有下面三种方式：

1. 一对一（一个用户线程对应一个内核线程）
2. 多对一（多个用户线程映射到一个内核线程）
3. 多对多（多个用户线程映射到多个内核线程）

**Java 线程**采用的是**一对一的线程模型**，也就是**一个 Java 线程对应一个系统内核线程**。

###### 并发和并行

**并发**：两个及以上的作业在同一时间段内工作

**并行**：两个及以上的作用在同一时刻工作

###### 同步和异步

**同步**：发布一个调用之后，在没有得到结果之前，该调用就不可以返回，需要一直等待

**异步**：调用发布之后，不用等待结果，直接返回

###### 为什么使用多线程

从总体而言：

- **线程的轻量级**：从计算机底层而言线程可以比作轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的花销
- **多线程并发编程正是开发高并发系统的基础**，利用多线程机制可以大大提高整体的并发能力和性能

从计算机底层而言：

**单核时代**：在**单核时代利用多线程主要是为了提高单线程利用CPU和IO的效率**，比如说当一个线程在进行io操作时阻塞的时候，就可以使用其他的线程，从而提高CPU的利用率

**多核时代**：在多核时代利用多线程主要是为了提高多线程利用**多核CPU**的能力，

从**资源分配和调度**的角度，**进程**是操作系统的基本单位，从**执行和任务处理**的角度，**线程**是 CPU 调度和执行的基本单位

**多线程可能带来的问题：内存泄漏、死锁、线程不安全**

###### 线程安全和不安全

线程安全和不安全是在**多线程环境**下对于**同一份数据的访问**是否能够**保证其正确性和一致性**的描述

- 线程安全：对于同一份数据，不管有多少线程同时访问，都能保证数据的一致性和准确性
- 线程不安全：对于同一份数据，多个线程同时访问，可能会导致数据混乱、错误丢失等

###### 单核CPU运行多线程效率一定高吗

取决于**线程的类型**和**任务的性质**，一般来说，有两种类型的线程：**CPU 密集型和 IO 密集型**。

**CPU 密集型**的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。

**IO 密集型**的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。

所以如果是**CPU 密集型的线程**在单核上运行的话，多个线程不断切换，**增加了系统的开销，降低了效率**。如果线程是 **IO 密集型**的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，**提高了效率**

###### 线程的生命周期和状态

- NEW：初始状态，线程被创建出来但是还没有被调用

- RUNNABLE：运行状态，线程被调用start()等待运行状态

- BLOCKED：阻塞状态，需要等待锁的释放

  当线程进入 **`synchronized`** 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态

- WAITING：等待状态，表示该进程需要等待其他进程做一些特定的动作

  进入等待状态的线程需要**依靠其他线程的通知**才能够返回到运行状态。

- TIME_WAITING：超时等待状态，可以**在指定的时间后自行返回**而不是像 WAITING 那样一直等待

  比如通过 **`sleep（long millis）`**方法或 **`wait（long millis）`**方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。

- TERMINATED：终止状态，表示该线程已经运行完毕

  `run()`方法之后将会进入到该状态

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换

线程创建之后它将处于 **NEW（新建）** 状态，调用 **`start()`** 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。

在**操作系统**层面，线程有 **READY 和 RUNNING** 状态，但在 **JVM** 层面，只能看到 **RUNNABLE** 状态，所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态

在JVM中**没有区分READY和RUNNING状态**的**原因**是：现在的时分多任务操作系统架构采用的是抢占式轮转调度，这种方式时间分片通常很小，每个线程一次只在CPU上执行很短的时间，就被换下去继续去排队了，所以区分两个状态没太大意义

###### 什么是线程上下文切换

线程在执行过程中会有自己的运行条件和状态，遇到下面情况会从运行状态退出

- 主动让出 CPU，比如调用了 **`sleep()`, `wait()`** 等
- **时间片用完**，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死
- 调用了**阻塞类型**的系统中断，比如**请求 IO，线程被阻塞**
- 被终止或结束运行

这其中**前三种都会发生线程切换**，线程切换意味着需要**保存当前线程的上下文**，**留待线程下次占用 CPU 的时候恢复现场**。并加载下一个将要占用 CPU 的线程上下文

###### 线程死锁

**多个线程同时被阻塞**，它们中的**一个或者全部都在等待其中某个资源被释放**。由于**线程被无限期地阻塞，因此程序不可能正常终止**。

下面是一个死锁的代码：

线程 A 通过 **`synchronized (resource1)` 获得 `resource1` 的监视器锁**，然后通过**`Thread.sleep(1000)**`让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2** 的监视器锁。**线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源**，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。

```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}

```

产生死锁的四个必要条件：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个线程因**请求资源而阻塞时，对已获得的资源保持不放**。
3. **不剥夺条件**:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**:若干线程之间形成一种头尾相接的循环等待资源关系

因此**预防死锁**就是**破坏上面的必要条件**

1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

**避免死锁**

借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态

**安全状态** 指的是**系统能够按照某种线程推进顺序**（P1、P2、P3……Pn）来为**每个线程分配所需资源**，直到**满足每个线程对资源的最大需求**，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。

###### sleep方法和wait方法

**共同点**：两者都可以**暂停线程的执行**

**不同点**：

- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁**

  即sleep的时候，其他线程仍无法调用该线程锁的对象

- `wait()` 通常被用于**线程间交互/通信**，`sleep()`通常被用于**暂停执行**

  因为wait释放了锁

- `wait()` 方法被调用后，线程**不会自动苏醒**，需要别的线程调用同一个对象上的 **`notify()`或者 `notifyAll()` 方法**。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。

  wait操作后被唤醒状态进入**就绪状态**后，仍然需要等待**获取对象的锁**才能继续执行

- **`sleep()` 是 `Thread` 类的静态本地方法**，**`wait()` 则是 `Object` 类的本地方法**

###### 为什么 wait() 方法不定义在 Thread 中

**`wait()`** 是让**获得对象锁的线程实现**等待，会**自动释放当前线程占有的对象锁**。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。

因此同样的**为什么 `sleep()` 方法定义在 `Thread` 中**是因为：`sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁

###### 可以直接调用 Thread 类的 run 方法吗

直接run意味着没有start方法，**start方法会启动一个线程并让其进入就绪状态**，如果没有这个步骤直接run的话，就只能当成一个 main 线程下的**普通方法去执行**，并不会在某个线程中执行它，所以这并**不是多线程工作**

###### volatile 关键字

`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到**主存**中进行读取

即声明该变量在**主存**中，在 C 语言里也有，它最原始的意义就是**禁用 CPU 缓存**

**volatile关键字**可以用于**确保被修饰的变量对所有线程的可见性**，即当一个线程修改了该变量的值后，其他线程能够立即看到最新的值。但volatile不能保证**多个线程同时对该变量进行读取和写入的操作是原子性的**，所以当多个线程同时操作的时候，那么就有可能出现**数据不一致的情况**

![image-20231225234414847](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231225234414847.png)

**synchronized**关键字既可以**保证数据的可见性，也可以保证数据的原子性**。当某个线程进入synchronized代码块时，它会锁定该对象或类，并且在执行完代码块后会释放锁，这样其他线程才能获取锁并执行相应的代码。在synchronized代码块中对**共享变量的读取和写入操作都是原子的**，即一个线程正在**执行synchronized代码块**时，**其他线程无法同时访问该代码块中的共享变量**，从而保证了数据的一致性和原子性。

并且**`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。**将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，会通过插入特定的 **内存屏障** 的方式来**禁止指令重排序**

**双重校验锁实现对象单例**

当第一次调用getInstance()方法时，由于instance为null，两个线程可能同时进入第一个if语句块。在synchronized关键字的作用下，只有一个线程能够进入同步块，另一个线程会被阻塞。

在进入同步块后，再次检查instance是否为null。这是因为当两个线程都通过了第一次检查时，如果没有第二次检查，就会创建两个实例。所以，在第二次检查前，只有一个线程能够创建实例。

```java
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {
        // 私有化构造函数防止外部实例化
    }

    public static Singleton getInstance() {
        if (instance == null) {  // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {  // 第二次检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```

###### 乐观锁和悲观锁

**悲观锁：**每次假设最坏的情况，认为资源每次被访问的时候都会出现问题，所以每次获取资源的时候都会上锁，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**

**`synchronized`**和**`ReentrantLock`**等独占锁就是悲观锁思想的实现

**高并发的场景**下，激烈的锁竞争会造成**线程阻塞**，大量阻塞线程会导致系统的上下文切换，**增加系统的性能开销**。并且，悲观锁还可能会存在**死锁问题**，影响代码的正常运行

**乐观锁：**总是假设**最好的情况**，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在**提交修改**的时候去**验证对应的资源是否被其它线程修改了**

乐观锁的一种实现方式 **CAS** 实现

高并发的场景下，乐观锁相比悲观锁来说，**不存在锁竞争造成线程阻塞，也不会有死锁的问题**，在性能上往往会更胜一筹

理论上来说：

- 悲观锁通常多用于**写比较多的情况**（多写场景，竞争激烈），这样**可以避免频繁失败和重试影响性能**，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如`LongAdder`），也是可以考虑使用乐观锁的，要视实际情况而定。
- 乐观锁通常多用于**写比较少的情况**（多读场景，竞争较少），这样**可以避免频繁加锁影响性能**。不过，**乐观锁主要针对的对象是单个共享变量**（参考`java.util.concurrent.atomic`包下面的原子变量类）

###### 实现乐观锁

乐观锁一般会使用版本号机制或 CAS 算法实现

**版本号机制**

在数据表中加上一个数据版本号 **`version`** 字段，表示**数据被修改的次数**。**当数据被修改时，`version` 值会加一**。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，在提交更新时，若刚才读取到的 **version 值为当前数据库中的 `version` 值相等时**才更新，否则重试更新操作，直到更新成功。

**CAS 算法**

全称是 **Compare And Swap（比较与交换）**，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新

CAS 涉及到三个操作数：

- **V**：要更新的变量值(Var)
- **E**：预期值(Expected)
- **N**：拟写入的新值(New)

当且仅当 **V 的值等于 E** 时，CAS 通过原子方式用**新值 N 来更新 V 的值**。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新

Java 语言并没有直接实现 CAS，**CAS 相关的实现是通过 C++ 内联汇编的形式实现的**

###### 乐观锁存在的问题

**ABA问题**

如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，但可能在这段时间它的值可能被改为其他值，然后又改回 A

ABA 问题的解决思路是在变量前面追加上**版本号或者时间戳**

**循环时间长开销大**

CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销

**只能保证一个共享变量的原子操作**

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效

######  synchronized 关键字

`synchronized` 是 Java 中的一个关键字，主要解决的是**多个线程之间访问资源的同步性**，可以保证被它修饰的**方法或者代码块**在**任意时刻**只能有**一个线程执行**

在Java早期，**synchronized**属于**重量级锁**，效率低下。这是因为**监视器锁（monitor）依赖于底层的操作系统**的 `Mutex Lock` 来实现的，Java 的线程是**映射到操作系统的原生线程之上的**。**如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成**，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换**需要相对比较长的时间，时间成本相对较高**

在Java6之后，**`synchronized`** 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 `synchronized` 锁的效率提升了很多

###### 如何使用 synchronized

synchronized主要修饰下面三种情况

1. 修饰实例方法
2. 修饰静态方法
3. 修饰代码块

**修饰实例方法**

**给当前对象实例加锁**，进入同步代码前要获得 **当前对象实例的锁**

```java
synchronized void method() {
    //业务代码
}
```

**修饰静态方法**

给当前**类加锁**，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**

因为**静态成员**不属于任何一个实例对象，归**整个类所有**，**不依赖于类的特定实例**，被**类的所有实例共享**

```java
synchronized static void method() {
    //业务代码
}
```

**静态 `synchronized` 方法和非静态 `synchronized` 方法之间的调用互斥**么？**不互斥**！如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**

**修饰代码块**

- `synchronized(object)` 表示进入同步代码库前要获得 **给定对象的锁**。
- `synchronized(类.class)` 表示进入同步代码前要获得 **给定 Class 的锁**

```java
synchronized(this) {
    //业务代码
}
```

**总结：**

- `synchronized` 关键字加到 `static` **静态方法**和 **`synchronized(class)`** 代码块上都是是给 **Class 类上锁**；
- `synchronized` 关键字加到实例方法上是给**对象实例上锁**；
- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。

###### 构造方法可以用 synchronized 修饰么

**构造方法不能使用 synchronized 关键字修饰**，因为构造方法本就线程安全，也不需要加锁

###### synchronized 底层原理

**synchronized 同步语句块的情况**

```java
public class SynchronizedDemo {
    public void method() {
        synchronized (this) {
            System.out.println("synchronized 代码块");
        }
    }
}
```

`synchronized` 同步语句块的实现**使用的是 `monitorenter` 和 `monitorexit` 指令**，其中 **`monitorenter` 指令指向同步代码块的开始位置**，**`monitorexit` 指令则指明同步代码块的结束位置。**

当**执行 `monitorenter` 指令时**，**线程**试图获取锁也就是获取 **对象监视器 `monitor`** 的持有权，在执行`monitorenter`时，**会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1**

对象锁的的拥有者线程才可以执行 `monitorexit` 指令来释放锁。**在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁**。

**synchronized 修饰方法的的情况**

```java
public class SynchronizedDemo2 {
    public synchronized void method() {
        System.out.println("synchronized 方法");
    }
}

```

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 **`ACC_SYNCHRONIZED`** 标识，该标识**指明了该方法是一个同步方法**。**JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用**

如果是**实例方法**，JVM 会尝试**获取实例对象的锁**。如果是**静态方法**，JVM 会尝试**获取当前 class 的锁**

**不过两者的本质都是对对象监视器 monitor 的获取**

###### JDK1.6 之后的 synchronized 底层做的优化

JDK1.6 对锁的实现引入了大量的优化，如**偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销**。

- 自旋锁：在获取锁失败时，线程不会立即阻塞，而是**进行一定次数的自旋尝试**，期望在短时间内其他线程会释放锁。这样可以减少线程切换的开销，提高性能。
- 适应性自旋锁：根据当前**线程在临界区的等待时间和其他线程的情况动态调整自旋的次数**，以平衡性能和资源的利用。
- 锁消除：通过逃逸分析，**JVM 可以判断某些锁是不可能被其他线程访问到的**，从而可以安全地消除这些锁，减少不必要的同步操作。
- 锁粗化：**当连续的对同一对象进行加锁和解锁操作时，JVM 可以将这些操作合并成一次更大范围的锁，从而减少锁操作的次数**。

锁主要存在四种状态，依次是：**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态**，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

1. 无锁状态（Unlocked）：在**无竞争的情况**下，对象的锁处于无锁状态。当一个线程尝试获取对象的锁时，如果对象处于无锁状态，可以直接将对象标记为自己所持有的锁，并继续执行，无需进行额外的操作。
2. 偏向锁状态（Biased Locking）：偏向锁是JDK 1.6 引入的一项优化技术，旨在解决只有**一个线程访问同步块的场景**。**当一个线程第一次进入同步块时，对象的标记被该线程所偏向，并记录下该线程的ID**。之后，该线程再次进入同步块时，无需进行任何同步操作，因为对象已经偏向于该线程。
3. 轻量级锁状态（Lightweight Locking）：当**多个线程竞争同一个锁**时，偏向锁会升级为轻量级锁。轻量级锁使用**CAS操作**来避免使用互斥量，尝试在用户态下使用自旋锁来避免线程的切换，从而减少对操作系统的调用。
4. 重量级锁状态（Heavyweight Locking）：如果轻量级锁无法解决竞争问题，锁就会膨胀为重量级锁，此时涉及到操作系统的互斥量，线程会被阻塞，陷入内核态，这会引起较大的性能开销。

###### synchronized 和 volatile 有什么区别

- `volatile` 关键字是线程同步的**轻量级实现**，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 **`volatile` 关键字只能用于变量**而 `synchronized` 关键字可以修饰**方法以及代码块** 。
- `volatile` 关键字**能保证数据的可见性，但不能保证数据的原子性**。`synchronized` 关键字两者都能保证。
- `volatile`关键字主要用于**解决变量在多个线程之间的可见性**，而 `synchronized` 关键字解决的是**多个线程之间访问资源的同步性**。

###### ReentrantLock

`ReentrantLock` 实现了 **`Lock` 接口**，是一个**可重入且独占式**的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，**增加了轮询、超时、中断、公平锁和非公平锁等高级功能**。

`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承 **AQS**（`AbstractQueuedSynchronizer`），**添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的**。

**`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync`** 两个子类。

`ReentrantLock` **默认使用非公平锁**，也可以通过**构造器**来显式的指定**使用公平锁**

```java
// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}

```

###### 公平锁和非公平锁有什么区别

- **公平锁** : 锁被释放之后，**先申请的线程先得到锁**。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
- **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，**是随机或者按照其他优先级排序的**。性能更好，但可能会导致某些线程永远无法获取到锁。

###### synchronized 和 ReentrantLock 有什么区别

- **两者都是可重入锁**

  **可重入锁** 也叫**递归锁**，指的是**线程可以再次获取自己的内部锁**。比如**一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的**，如果是**不可重入锁的话，就会造成死锁**，因为一直在等待获取这个资源才释放

JDK 提供的所有现成的 `Lock` 实现类，包括 `synchronized` 关键字锁都是可重入的

- **synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API**

  **`synchronized`** 是**依赖于 JVM 实现**的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 `synchronized` 关键字进行了很多优化，但是这些优化都是**在虚拟机层面实现的，并没有直接暴露**给我们。

  `ReentrantLock` 是 **JDK 层面实现**的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过**查看它的源代码，来看它是如何实现的**

- **ReentrantLock 比 synchronized 增加了一些高级功能**
  - **等待可中断**：正在等待的线程可以选择放弃等待，改为处理其他事情
  - **可实现公平锁**
  - **可实现选择性通知**：`synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法

###### 可中断锁和不可中断锁有什么区别

- **可中断锁**：获取锁的过程中可以被中断，**不需要一直等到获取锁之后 才能进行其他逻辑处理**。`ReentrantLock` 就属于是可中断锁。
- **不可中断锁**：一旦线程**申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理**。 `synchronized` 就属于是不可中断锁。

###### ReentrantReadWriteLock

`ReentrantReadWriteLock` 实现了 `ReadWriteLock` ，是一个**可重入的读写锁**，既可以保证多个线程同时读的效率，同时又可以保证有**写入操作时的线程安全**

`ReentrantReadWriteLock` 其实是两把锁，**一把是 `WriteLock` (写锁)，一把是 `ReadLock`（读锁）** 

读锁是共享锁，写锁是独占锁。**读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有**

`ReentrantReadWriteLock` 也支持公平锁和非公平锁，**默认使用非公平锁**，可以通过构造器来显示的指定

因此：由于 `ReentrantReadWriteLock` 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，**在读多写少的情况下**，使用 `ReentrantReadWriteLock` 能够明显提升系统性能

###### 线程持有读锁还能获取写锁吗

- 在**线程持有读锁的情况下**，该线程**不能取得写锁**
- 在**线程持有写锁的情况下**，该线程**可以继续获取读锁**

###### StampedLock

`StampedLock` 是 JDK 1.8 引入的**性能更好的读写锁**，**不可重入且不支持条件变量** `Conditon`

`StampedLock` 并**不是直接实现 `Lock`或 `ReadWriteLock`接口**，而是基于 **CLH 锁** 独立实现的（AQS 也是基于这玩意）

- **写锁**：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 `ReentrantReadWriteLock` 的写锁，不过这里的写锁是不可重入的。
- **读锁** （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 `ReentrantReadWriteLock` 的读锁，不过这里的读锁是不可重入的
- **乐观读**：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。

性能更好的原因：`StampedLock` 的乐观**读允许**一个写线程**获取写锁**，所以不会导致所有写线程阻塞，也就是**当读多写少的时候**，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。

######  ThreadLocal

我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？**

JDK 中自带的`ThreadLocal`类正是为了解决这样的问题，**`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据**

如果你创建了一个`ThreadLocal`变量，那么**访问这个变量的每个线程都会有这个变量的本地副本**，这也是`ThreadLocal`变量名的由来。他们可以使用 **`get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值**，从而避免了线程安全问题

样例：

```java
import java.text.SimpleDateFormat;
import java.util.Random;

public class ThreadLocalExample implements Runnable{

     // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本
    private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));

    public static void main(String[] args) throws InterruptedException {
        ThreadLocalExample obj = new ThreadLocalExample();
        for(int i=0 ; i<10; i++){
            Thread t = new Thread(obj, ""+i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        }
    }

    @Override
    public void run() {
        System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern());
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //formatter pattern is changed here by thread, but it won't reflect to other threads
        formatter.set(new SimpleDateFormat());

        System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern());
    }

}

```

这段代码展示了如何在多线程环境下使用 `ThreadLocal` 来实现线程安全的 `SimpleDateFormat` 对象

1. 在 `ThreadLocalExample` 类中，我们定义了一个静态变量 `formatter`，它的类型是 `ThreadLocal<SimpleDateFormat>`。这意味着每个线程都可以拥有自己独立的 `SimpleDateFormat` 对象，而不需要担心线程安全性。
2. 在 `main` 方法中，我们创建了一个 `ThreadLocalExample` 对象，并启动了 10 个线程。每个线程都会输出当前线程的名称以及默认的 `SimpleDateFormat` 格式。
3. 在 `run` 方法中，每个线程首先输出当前线程名称和默认的日期格式。然后线程会随机休眠一段时间，模拟不同线程的执行速度不同。
4. 接着，每个线程会尝试修改 `SimpleDateFormat` 对象的格式。虽然每个线程都调用了 `formatter.set(new SimpleDateFormat())` 来更改日期格式，但由于使用了 `ThreadLocal`，所以这个更改只会作用于当前线程的 `SimpleDateFormat` 对象，不会影响其他线程的对象。

通过这段代码，我们可以清楚地看到 `ThreadLocal` 的作用：**它能够为每个线程提供独立的、线程安全的对象副本，从而避免了多线程环境下的竞争和同步问题。这在需要使用非线程安全对象的情况下非常有用，比如 `SimpleDateFormat`**

**ThreadLocal 原理**

```java
public class Thread implements Runnable {
    //......
    //与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;

    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    //......
}
```

从上面`Thread`类 源代码可以看出`Thread` 类中有一个 **`threadLocals`** 和 一个 **`inheritableThreadLocals`** 变量，这两个变量ThreadLocalMap类型变量，可以理解为定制的HashMap，**默认情况下为null**，当前线程调用 `ThreadLocal` 类的 **`set`或`get`方法时才创建它们**

`ThreadLocal`类的`set()`方法

```java
public void set(T value) {
    //获取当前请求的线程
    Thread t = Thread.currentThread();
    //取出 Thread 类内部的 threadLocals 变量(哈希表结构)
    ThreadLocalMap map = getMap(t);
    if (map != null)
        // 将需要存储的值放入到这个哈希表中
        map.set(this, value);
    else
        createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

**最终的变量是放在了当前线程的 `ThreadLocalMap` 中，并不是存在 `ThreadLocal` 上，`ThreadLocal` 可以理解为只是`ThreadLocalMap`的封装，传递了变量值。**`ThrealLocal` 类中可以通过`Thread.currentThread()`获取到当前线程对象后，直接通过`getMap(Thread t)`可以访问到该线程的`ThreadLocalMap`对象。

**每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对。**

即每个线程有个一个hashmap，这个hashmap存储了很多键值对，键是`ThreadLocal`，值是设置的值

比如我们在同一个线程中声明了两个 `ThreadLocal` 对象的话， `Thread`内部都是使用**仅有的那个`ThreadLocalMap` 存放数据的**，**`ThreadLocalMap`的 key 就是 `ThreadLocal`对象，value 就是 `ThreadLocal` 对象调用`set`方法设置的值**。

**ThreadLocal 内存泄露问题是怎么导致的**

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用，而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，**key 会被清理掉，而 value 不会被清理掉**。

这样一来，**`ThreadLocalMap` 中就会出现 key 为 null 的 Entry**。假如我们不做任何措施的话，**value 永远无法被 GC 回收，这个时候就可能会产生内存泄露**。`ThreadLocalMap` 实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，**会清理掉 key 为 null 的记录**。使用完 `ThreadLocal`方法后最好手动调用`remove()`方法

弱引用：如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。**在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

######  线程池

线程池就是**管理一系列线程的资源池**。当有任务要处理时，**直接从线程池中获取线程来处理**，处理完之后**线程并不会立即被销毁，而是等待下一个任务**

池化技术的思想主要是为了**减少每次获取资源的消耗，提高对资源的利用率**。

线程池使用的好处

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

- **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。

- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

**创建线程池**

**方式一：通过`ThreadPoolExecutor`构造函数来创建**

**方式二：通过 `Executor` 框架的工具类 `Executors` 来创建**

并且可以创建多种类型的 `ThreadPoolExecutor`：

- **`FixedThreadPool`**：该方法**返回一个固定线程数量的线程池。该线程池中的线程数量始终不变**。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。

- **`SingleThreadExecutor`：** 该方法**返回一个只有一个线程的线程池**。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。

- **`CachedThreadPool`：** 该方法**返回一个可根据实际情况调整线程数量的线程池**。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。

- **`ScheduledThreadPool`**：该方法**返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池**。

《阿里巴巴 Java 开发手册》中强制**线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor` 构造函数的方式**，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

**`Executors` 返回线程池对象的弊端如下（即使用默认方式创建线程池的坏处）**：

- **`FixedThreadPool` 和 `SingleThreadExecutor`**：使用的是无界的 `LinkedBlockingQueue`，任务队列最大长度为 `Integer.MAX_VALUE`,可能堆积大量的请求，从而导致 OOM。

- **`CachedThreadPool`**：使用的是同步队列 `SynchronousQueue`, 允许创建的线程数量为 `Integer.MAX_VALUE` ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。

- **`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor`** : 使用的无界的延迟阻塞队列`DelayedWorkQueue`，任务队列最大长度为 `Integer.MAX_VALUE`,可能堆积大量的请求，从而导致 OOM。

**线程池常见参数有哪些**

```java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }

```

其中最重要的三个参数是：

- **`corePoolSize` :** 任务队列**未达到队列容量**时，**最大可以同时运行的线程数量**。

- **`maximumPoolSize` :** 任务队列中存放的任务**达到队列容量**的时候，当前可以同时运行的线程数量变为**最大线程数**。

- **`workQueue`:** 新任务来的时候会先**判断当前运行的线程数量是否达到核心线程数**，如果达到的话，新任务就会被存放在队列中。

![image-20231226200254398](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226200254398.png)

**当使用线程池执行新任务时**，通常会经历以下流程：

1. 如果线程池**当前的工作线程数小于核心线程数**（通过 `corePoolSize` 参数配置），则会**创建一个新的工作线程来执行任务**。这是因为核心线程会一直保持存活状态，即使没有任务需要执行。

2. 如果线程池**当前的工作线程数已经达到核心线程数**，但**任务队列（通过 `BlockingQueue` 实现）还有空间**可以接受新的任务，那么新任务会**被添加到队列中等待执行**。任务队列的大小可以通过 `workQueue` 参数进行配置。

3. 如果线程池**当前的工作线程数已经达到核心线程数，并且任务队列已经满了**，但**线程池的最大线程数（通过 `maximumPoolSize` 参数配置）还未达到**，那么会**创建一个新的非核心线程来执行任务**。

4. 如果线程池的**最大线程数已经达到，无法再创建新的线程，并且任务队列也已满，则根据所选择的拒绝策略**（通过 `RejectedExecutionHandler` 实现）来处理新任务的提交。常见的拒绝策略有：抛出异常、丢弃任务、丢弃队列中最旧的任务或者在调用者线程中直接执行。

5. 一旦有空闲的工作线程，它将**从任务队列中获取下一个任务进行执行**。这是通过使用任务队列的出队操作来实现的。

6. 当线程执行完任务后，如果线程池中的线程数多于核心线程数，且在指定的时间内没有新的任务到达（通过 `keepAliveTime` 参数配置），那么这些多余的非核心线程将被终止并移出线程池，以减少资源消耗。

![image-20231226203516444](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226203516444.png)

这个流程可以保证线程池高效地处理新任务，并根据负载情况动态地调整工作线程的数量。同时，任务队列的存在可以缓解瞬时的任务突发，避免线程过度增长或因线程频繁创建销毁而引起的性能问题。

**线程池的饱和策略**

如果当前同时运行的**线程数量达到最大线程数量**并且**队列也已经被放满了任务时**

**即当来的任务数量>maximumPoolSize+workQueue时，就会采用饱和策略**

`ThreadPoolTaskExecutor` 定义一些策略

- **`ThreadPoolExecutor.AbortPolicy`：** 抛出 `RejectedExecutionException`来**拒绝新任务的处理**。

- **`ThreadPoolExecutor.CallerRunsPolicy`：** 调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。

- **`ThreadPoolExecutor.DiscardPolicy`：** **不处理新任务，直接丢弃掉**。

- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。

**线程池常用的阻塞队列**

新任务来的时候会先判断**当前运行的线程数量是否达到核心线程数**，**如果达到的话，新任务就会被存放在队列中**

**不同的线程池**会选用**不同的阻塞队列**

- 容量为 `Integer.MAX_VALUE` 的 `LinkedBlockingQueue`（无界队列）：`FixedThreadPool` 和 `SingleThreadExector` 。`FixedThreadPool`最多只能创建核心线程数的线程（核心线程数和最大线程数相等），`SingleThreadExector`只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。

- `SynchronousQueue`（同步队列）：`CachedThreadPool` 。`SynchronousQueue` 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。

- `DelayedWorkQueue`（延迟阻塞队列）：`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor` 。`DelayedWorkQueue` 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。`DelayedWorkQueue` 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程

**线程池命名**

**1、利用 guava 的 `ThreadFactoryBuilder`**

```java
ThreadFactory threadFactory = new ThreadFactoryBuilder()
                        .setNameFormat(threadNamePrefix + "-%d")
                        .setDaemon(true).build();
ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);
```

**2、自己实现 `ThreadFactory`**

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;
/**
 * 线程工厂，它设置线程名称，有利于我们定位问题。
 */
public final class NamingThreadFactory implements ThreadFactory {

    private final AtomicInteger threadNum = new AtomicInteger();
    private final ThreadFactory delegate;
    private final String name;

    /**
     * 创建一个带名字的线程池生产工厂
     */
    public NamingThreadFactory(ThreadFactory delegate, String name) {
        this.delegate = delegate;
        this.name = name; // TODO consider uniquifying this
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = delegate.newThread(r);
        t.setName(name + " [#" + threadNum.incrementAndGet() + "]");
        return t;
    }

}
```

**如何设定线程池的大小**

线程池设置的过大，增加了上下文切换的成本，过小又容易导致大量任务堵塞，所以需要合适的大小

1. 有一个简单并且适用面比较广的公式：

   **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以**将线程数设置为 N（CPU 核心数）+1**。比 CPU 核心数**多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响**。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。

   **I/O 密集型任务(2N)：** 这种任务应用起来，**系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用**。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

   ![image-20231226210537437](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226210537437.png)

   **如何判断是 CPU 密集任务还是 IO 密集任务**

   CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。**但凡涉及到网络读取，文件读取这类都是 IO 密集型**，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。

2. **动态修改参数值**       [参考](https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505103&idx=1&sn=a041dbec689cec4f1bbc99220baa7219&source=41#wechat_redirect)

   那在什么时候修改呢，美团考虑的是在运行的时候修改，具体操作如下：

   在运行期，线程池使用方调用setcorePoolSize方法设置**corePoolSize之后**，线程池会**直接覆盖原来的corePoolSize值**，并且**基于当前值和原始值的比较结果采取不同的处理策略。**

   - 对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收
   - 对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务

   流程图如下：

   ![image-20231226212306295](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226212306295.png)

   再设置**maximumPoolSize**，按照下面逻辑

   1. 首先是参数合法性校验。
   2. 然后用传递进来的值，覆盖原来的值。
   3. 判断工作线程是否是大于最大线程数，如果大于，则对空闲线程发起中断请求。

   ![image-20231226213028692](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226213028692.png)

   最后就是**workQueue**的设置，**从工作队列的源码可以看出其capcity这个变量被设置为了final，所以是不能修改的，所以考虑自己创建一个工作队列，直接将LinkedBlockingQueue的源码复制一份，然后把capcity的fnal去掉即可**

**如何设计一个能够根据任务的优先级来执行的线程池**

假如我们需要实现**一个优先级任务线程池**的话，那可以考虑使用 **`PriorityBlockingQueue`** （优先级阻塞队列）作为任务队列（`ThreadPoolExecutor` 的构造函数有一个 `workQueue` 参数可以传入任务队列）。

不过要想让 `PriorityBlockingQueue` 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：

- 提交到线程池的任务实现 `Comparable` 接口，并重写 `compareTo` 方法来指定任务之间的优先级比较规则。

- 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)。

不过也存在一些问题

- `PriorityBlockingQueue` 是**无界的，可能堆积大量的请求，从而导致 OOM**。

- 可能会导致**饥饿问题**，即低优先级的任务长时间得不到执行。

- 由于**需要对队列中的元素进行排序操作以及保证线程安全**（并发控制采用的是可重入锁 `ReentrantLock`），因此会**降低性能**。

一些相关的面试题

线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？

![image-20231226213652375](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226213652375.png)

核心线程数会被回收吗？需要什么设置？

![image-20231226213738798](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226213738798.png)

###### Future

是异步思想的典型运用

当我们执行某一耗时的任务时，可以**将这个耗时任务交给一个子线程去异步执行**，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们**再通过 `Future` 类获取到耗时任务的执行结果**。这样一来，程序的执行效率就明显提高了

![image-20231226215722200](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226215722200-20231226215841329.png)

######  Callable 和 Future 有什么关系

Callable：

- `Callable` 是一个具有泛型参数的接口，它类似于 `Runnable`，但是可以返回结果并抛出异常。
- `Callable` 接口定义了一个名为 `call` 的方法，**该方法可以在不同的线程中执行任务，并且可以返回一个结果**，或者在任务执行过程中抛出异常。

`Callable` 和 `Future` 之间的关系在于，**当我们使用线程池执行任务时，可以将任务封装为 `Callable` 对象，然后通过线程池提交执行，并且会返回一个 `Future` 对象来表示任务的执行情况**。

###### CompletableFuture 类有什么用

`Future` 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 `get()` 方法为阻塞调用，CompletableFuture就是用于解决其缺陷的，接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线。

######  AQS

