---
layout: post
title: "面经"
subtitle: "面经"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
  - java
---

### 面经

[参考](https://javaguide.cn/java/basis/java-basic-questions-01.html#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)

#### java基础面试题总结

###### Java SE vs Java EE

Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序

###### JVM vs JDK vs JRE

JVM是java运行字节码的虚拟机，有针对不同系统的的实现，程序编译成字节码，通过JVM，就可以在不同系统上运行，得到相同的结果

JDK是java开发者工具，提供给开发者使用，能够创建和编译java程序，其包含了JRE，并且包含编译器等

JRE是java运行环境，包含了Java程序运行时候的环境，和必须的库

如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码

![image-20231215195252063](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231215195252063.png)

###### 字节码

在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。

由于**字节码并不针对一种特定的机器**，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行

从字节码到机器码这一段，JVM会加载字节码文件，然后通过解释器逐行解释执行，这种方式比较慢，所以后面引入JIT，会在第一次编译之后，将字节码对应的机器码保存起来，供下次使用，所以速度更快  对热点代码进行保存

![image-20231216154345640](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231216154345640.png)

高级编程语言按照程序的执行方式分为两种：

- 编译型：通过编译器将代码一次性翻译成可被该平台执行的机器码，执行速度比较快，开发效率比较低
- 解释型：通过解释器将代码一句一句的将代码解释（interpret）为机器代码后再执行。开发效率比较快，执行速度比较慢

Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

###### AOT

这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译，AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。

但AOT也存在一些缺点，所以只能说 AOT 更适合当下的**云原生场景**，对微服务架构的支持也比较友好，OT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了

###### Java与c++区别

Java 不提供指针来直接访问内存，程序内存更加安全

Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。

Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。

C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

###### 标识符和关键字

标识符是程序、类、变量、方法等的名字，关键字是Java 语言已经赋予了其特殊的含义，只能用于特定的地方。**关键字是被赋予特殊含义的标识**符，所有的关键字都是小写的，在 IDE 中会以特殊颜色显示

⚠️ 注意：虽然 `true`, `false`, 和 `null` 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。

###### 移位运算符

`<<` :左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。

`>>` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。

`>>>` :无符号右移，忽略符号位，空位都以 0 补齐。

由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。

移位操作符实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作。

当 **int 类型左移/右移位数大于等于 32 位操作**时，会**先求余（%）后再进行左移/右移操作**。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。

###### 基本数据类型

![image-20231216165137530](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231216165137530.png)

Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析

这八个基本类型都有自己的**包装类**，比如说int的包装类是Integer

下面是包装类和基本类型的区别

- **包装类型可用于泛型**，而基本类型不可以
- 相比于包装类型（对象类型）， **基本数据类型占用的空间往往非常小**
- **基本数据类型的局部变量**存放在Java 虚拟机栈中的**局部变量表**中，**成员变量**被存放在 Java 虚拟机的**堆**中，**包装类型**属于对象类型，我们知道几乎所有对象实例都存在于**堆**中。
- 对于**基本数据类型**来说，**`==`** 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型**包装类对象**之间值的比较，全部使用 **`equals()`** 方法

###### 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了**缓存机制**来提升性能

**Byte，Short，Integer，Long** 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，**`Character`** 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 True or False

缓存机制代表了在这个范围内，定义相同的值，两个值的内存地址是一样的，**Float和Double没有实现缓存机制**

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```

###### 自动装箱和拆箱

- **装箱**：将**基本类型**用它们对应的**引用类型**包装起来；
- **拆箱**：将**包装类型**转换为**基本数据类型**；

```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作**

###### 解决浮点数运算精度丢失的问题

`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

```java
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("0.9");
BigDecimal c = new BigDecimal("0.8");

BigDecimal x = a.subtract(b);
BigDecimal y = b.subtract(c);

System.out.println(x); /* 0.1 */
System.out.println(y); /* 0.1 */
System.out.println(Objects.equals(x, y)); /* true */
```

在使用`BigDecimal`的时候

![image-20231219183416527](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219183416527.png)

对于`BigDecimal`方法有自己的数据操作的方法

```java
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("0.9");
System.out.println(a.add(b));// 1.9
System.out.println(a.subtract(b));// 0.1
System.out.println(a.multiply(b));// 0.90
System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常
System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11

```

![image-20231219184907404](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219184907404.png)

工具类

```java
import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * 简化BigDecimal计算的小工具类
 */
public class BigDecimalUtil {

    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;

    private BigDecimalUtil() {
    }

    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.add(b2).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double subtract(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.subtract(b2).doubleValue();
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double multiply(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.multiply(b2).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2) {
        return divide(v1, v2, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();
    }

    /**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b = BigDecimal.valueOf(v);
        BigDecimal one = new BigDecimal("1");
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    }

    /**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static float convertToFloat(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.floatValue();
    }

    /**
     * 提供精确的类型转换(Int)不进行四舍五入
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static int convertsToInt(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.intValue();
    }

    /**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static long convertsToLong(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.longValue();
    }

    /**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */
    public static double returnMax(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.max(b2).doubleValue();
    }

    /**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */
    public static double returnMin(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.min(b2).doubleValue();
    }

    /**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */
    public static int compareTo(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.compareTo(b2);
    }

}

```

###### 成员变量和局部变量

- **成员变量可以被 `public`,`private`,`static` 等修饰符所修饰**，而**局部变量不能**被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰
- 从变量在内存中的存储方式来看，如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而**对象存在于堆内存，局部变量则存在于栈内存。**
- 从变量在内存中的生存时间上看，**成员变量**是对象的一部分，它**随着对象的创建而存在**，而**局部变量**随着**方法的调用而自动生成**，随着方法的调用结束而消亡
- **成员变量如果没有被赋初始值**，则会自动以类型的**默认值**而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值

###### 静态变量

被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量

###### 静态方法为什么不能调用非静态成员

- 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问
- 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

**静态方法和实例方法的不同**

- 在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 
- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制

###### 重载和重写

**重载**是同一个方法，拥有**相同的方法名，但输入数据不同**，这样**编译器**必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。

```java
StringBuilder sb = new StringBuilder();
StringBuilder sb2 = new StringBuilder("HelloWorld");
```

**重写**是**子类继承自父类的相同方法**，**输入数据一样**，但要做出有别于父类的响应时，你就要覆盖父类方法,重写发生在运行期，是**子类对父类的允许访问的方法的实现过程**进行重新编写

1. 方法名、参数列表必须相同，**子类方法返回值类型应比父类方法返回值类型更小或相等**，抛出的**异常范围小于等于父类**，**访问修饰符范围大于等于父类**。
2. 如果父类方法访问修饰符为 **`private/final/static`** 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被**再次声明**。
3. **构造方法无法被重写**

![image-20231217120803615](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231217120803615.png)

⭐️ 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

**遇到方法重载会优先匹配固定参数的方法，因为固定参数的方法匹配度更高**

###### 面向对象的三大特征

**封装**

一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

**继承**

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类

关于继承有几个点需要注意的

- 子类不能直接访问父类的私有方法和私有变量。私有方法和变量只在定义它们的类内部可见，这是封装的一个重要方面，不过可以通过共有方法或者protect方法进行访问
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
- 子类可以用自己的方式实现父类的方法

**多态**

对象可以采用多种形态。在 Java 中，多态主要通过继承（inheritance）和接口（interfaces）以及方法的重写（overriding）和重载（overloading）来实现。多态使得我们可以用统一的方式处理不同类型的对象

**实现方法**

- 方法重写：子类重写父类的方法。当子类对象调用这个方法时，执行的是子类中重写的版本
- 方法重载：同一个类中多个同名方法，但它们的参数列表不同
- 向上转型：子类对象可以被当作父类对象使用。例如，如果有一个父类 `Animal` 和一个子类 `Dog`，那么 `Dog` 对象也可以被当作 `Animal` 对象使用。这使得你可以用 `Animal` 类型的变量来引用一个 `Dog` 对象
- 一个类实现一个接口，它需要提供接口中所有方法的具体实现。一个接口引用可以指向任何实现了该接口的类的对象

```java
// 父类
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

// 子类
class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

// 主程序
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // 创建 Animal 对象
        Animal myDog = new Dog();        // 创建 Dog 对象，但将其视为 Animal

        myAnimal.sound();  // 输出: Animal makes a sound
        myDog.sound();     // 输出: Dog barks，尽管 myDog 被声明为 Animal 类型
    }
}
```

###### 接口和抽象类

共同点：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法

区别：

- 接口里只有抽象方法，抽象类可以有非抽象方法
- 一个类只能继承一个类，但是可以实现多个接口
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值

###### 深拷贝和浅拷贝

- 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

![image-20231218161815217](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218161815217.png)

```java
String a = new String("ab"); // a 为一个引用
String b = new String("ab"); // b为另一个引用,对象的内容一样
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true
```

###### hashCode

`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置

如果两个对象的**`hashCode` 值相等**，那这两个**对象不一定相等**（哈希碰撞）。

如果两个对象的**`hashCode` 值相等并且`equals()`方法也返回 `true`**，我们才认为这两个对象相等。

如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等

###### **String、StringBuffer、StringBuilder 的区别**

**可变性**

`String` 是不可变的

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法

**线程安全性**

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。

`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。

`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

`String` 类型进行改变的时候，都会生成一个新的 `String` 对象

`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。

相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险

**总结**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

###### String类型的不可变性

`String` 类中使用 `final` 关键字修饰字符数组来保存字符串，但这不是其不可变的原因，因为对于final来说，被 `final` 关键字**修饰的类不能被继承**，修饰的**方法**不能被**重写**，修饰的**变量**是**基本数据类型**则值**不能改变**，修饰的变量是**引用类型**则**不能再指向其他对象**

不可变的原因：

1. 保存字符串的数组被 `final` 修饰且为**私有**的，并且`String` 类没**有提供/暴露修改这个字符串的方法**。
2. `String` 类被 `final` 修饰导致其**不能被继承**，进而**避免了子类破坏 `String` 不可变**。

###### 字符串拼接用“+” 还是 StringBuilder

字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 

即先创建StringBuilder对象，然后用append进行拼接，然后toString转回String对象

这种方式会创建多个StringBuilder对象，空间上产生了浪费

如果直接使用 `StringBuilder` 对象进行字符串拼接的话，就不会存在这个问题了。

```java
String[] arr = {"he", "llo", "world"};
StringBuilder s = new StringBuilder();
for (String value : arr) {
    s.append(value);
}
System.out.println(s);

```

**`String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址**

###### String s1 = new String("abc")

上面这句话会创建1-2个对象，依据常量池中是否含有该字符串常量来判断

- 如果常量池含有该字符串常量

  则会创建一个对象，即new的时候会创建一个对象

- 如果常量池不含有该字符串常量

  会创建两个对象，new的时候会创建一个对象，然后会创建一个字符串对象abc，进行赋值

###### intern 方法的作用

`String.intern()` 是一个 native（本地）方法，其作用是**将指定的字符串对象的引用保存在字符串常量池中**，可以简单分为两种情况：

- 如果字符串常量池中**保存了对应的字符串对象的引用**，就**直接返回该引用**。
- 如果字符串常量池中**没有保存了对应的字符串对象的引用**，那就在**常量池中创建一个指向该字符串对象的引用**并返回。

```java
// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = "Java";
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String("Java");
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true
```

![image-20231218184007388](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218184007388.png)

###### 异常处理

![image-20231218184213110](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218184213110.png)

###### 受检测异常和非受检测异常

**Checked Exception** 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 `catch`或者`throws` 关键字处理的话，就没办法通过编译

**Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译

除了`RuntimeException`及其子类以外，**其他的`Exception`类及其子类都属于受检查异常** 。常见的受检查异常有：IO 相关的异常、`ClassNotFoundException`、`SQLException`...。

###### Throwable类常用方法

- `String getMessage()`: 返回异常发生时的简要描述
- `String toString()`: 返回异常发生时的详细信息
- `String getLocalizedMessage()`: 返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同
- `void printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息

###### try-catch-finally

try作用是捕获异常，catch是处理异常，finally是最后都是进入finally

**当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行**。

因此**注意：不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值

并且finally中的代码也不是一定会执行，就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。或者程序所在的线程死亡，关闭 CPU。

###### try-with-resources

面对必须要关闭的资源，我们总是应该优先使用 `try-with-resources` 而不是`try-finally`。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。`try-with-resources`语句让我们更容易编写必须要关闭的资源的代码，若采用`try-finally`则几乎做不到这点。

```java
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
    int b;
    while ((b = bin.read()) != -1) {
        bout.write(b);
    }
}
catch (IOException e) {
    e.printStackTrace();
}
```

###### 泛型

允许在类、接口和方法中使用类型参数。它提供了编译时类型安全检查的优点，这意味着您可以在编译时捕获到不正确的类型使用，而不是在运行时。泛型的引入减少了对强制类型转换的需求，并提供了更加抽象和通用的编程方式。

泛型一般使用有三种方式

- 泛型类

  ```java
  //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
  //在实例化泛型类时，必须指定T的具体类型
  public class Generic<T>{
  
      private T key;
  
      public Generic(T key) {
          this.key = key;
      }
  
      public T getKey(){
          return key;
      }
  }
  ```

- 泛型接口

  ```java
  public interface Generator<T> {
      public T method();
  }
  
  ```

- 泛型方法

  ```java
     public static < E > void printArray( E[] inputArray )
     {
           for ( E element : inputArray ){
              System.out.printf( "%s ", element );
           }
           System.out.println();
      }
  ```

###### 反射

在运行时分析类以及执行类中方法的能力，通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性

其主要使用步骤：

1. **在运行时获取类的信息**： 反射可以用来在运行时获取类的信息，比如类的名称、方法、字段和注解等。这对于理解未知代码或动态生成代码非常有用。
2. **动态创建对象和调用方法**： 使用反射可以动态地创建对象和调用方法，即使在编译时这些类或方法是未知的。
3. **修改字段值**： 即使字段被声明为私有，反射也能够修改它们的值。

```java
public class ReflectionExample {
    private int number;
    private String name;

    public ReflectionExample(int number, String name) {
        this.number = number;
        this.name = name;
    }

    public void printInfo() {
        System.out.println("Number: " + number + ", Name: " + name);
    }

    public static void main(String[] args) throws Exception {
        // 使用反射创建对象
        Class<?> clazz = ReflectionExample.class;
        Constructor<?> constructor = clazz.getConstructor(int.class, String.class);
        Object instance = constructor.newInstance(10, "Test");

        // 调用方法
        Method method = clazz.getMethod("printInfo");
        method.invoke(instance);

        // 访问字段
        Field field = clazz.getDeclaredField("name");
        field.setAccessible(true); // 对于私有字段需要这样做
        field.set(instance, "New Name");
        method.invoke(instance);
    }
}

```

缺点：

- 反射操作通常比直接的 Java 代码执行要慢，因为涉及到动态类型检查和方法调用。
- 反射破坏了封装，可能会导致意外的副作用，尤其是在访问私有字段和方法时。
- 在受限的环境（如 Applet 或服务器应用程序）中，安全策略可能会限制反射的使用。

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以**基于反射分析类**，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。

**获取class对象的四种方式**

![image-20231219171551905](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219171551905.png)

###### 代理模式

**使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作**

代理模式有**静态代理和动态代理**两种实现方式

**静态代理**

**静态代理中，我们对目标对象的每个方法的增强都是手动完成的（\*后面会具体演示代码\*），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改\*）且麻烦(\*需要对每个目标类都单独写一个代理类）**

**静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**

静态代理的步骤：

1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

**动态代理**

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类

使用步骤：

1. 定义一个接口，声明需要代理的方法。
2. 创建一个实现了 `InvocationHandler` 接口的类，并定义在方法调用时想要执行的逻辑。
3. 使用 `Proxy.newProxyInstance` 方法创建代理对象，这个方法需要三个参数：类加载器、一组接口以及 `InvocationHandler` 实例。



###### 注解的分析方式

- **编译期直接扫描**：编译器在**编译 Java 代码的时候扫描对应的注解并处理**，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过**反射**来进行处理的。

###### SPI

![image-20231219154053778](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219154053778.png)

API是接口提供方提供方法实现，用户就可以直接调用接口进行使用

SPI是由**接口调用方确定接口规则**，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。

SPI机制能够大大地提高接口设计的灵活性，但也有一些缺点

- 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。
- 当多个 `ServiceLoader` 同时 `load` 时，会有并发问题。

###### 序列化和反序列化

- **序列化**：将**数据结构或对象转换成二进制字节流的过程**
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

序列化的都是对象（Object）也就是实例化后的类(Class)

**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**

序列化协议在osi七层协议中是表示层，在tcp/ip四层协议中就是应用层

![image-20231219155537932](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219155537932.png)

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

关于 `transient` 还有几点注意：

- `transient` **只能修饰变量，不能修饰类和方法**。
- `transient` 修饰的变量，在**反序列化后变量值将会被置成类型的默认值**。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

[JDK自带的也有序列化方式](https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/)，但一般不使用，其原因是：

- **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
- **性能差**：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
- **存在安全问题**：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。

###### I/O

Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- `InputStream`/`Reader`: 所有的输入流的基类，**前者是字节输入流，后者是字符输入流**。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

![](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219163727170.png)

###### 语法糖

为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读，例如for-each

不过，**JVM 其实并不能识别语法糖**，Java 语法糖要想被正确执行，**需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法**。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM

###### 参数传递

在java中引用传递，传递的是引用类型的地址

```java
public class Person {
    private String name;
   // 省略构造函数、Getter&Setter方法
}

public static void main(String[] args) {
    Person xiaoZhang = new Person("小张");
    Person xiaoLi = new Person("小李");
    swap(xiaoZhang, xiaoLi);
    System.out.println("xiaoZhang:" + xiaoZhang.getName());
    System.out.println("xiaoLi:" + xiaoLi.getName());
}

public static void swap(Person person1, Person person2) {
    Person temp = person1;
    person1 = person2;
    person2 = temp;
    System.out.println("person1:" + person1.getName());
    System.out.println("person2:" + person2.getName());
}


输出：
  person1:小李
  person2:小张
  xiaoZhang:小张
  xiaoLi:小李

```

像上面这种情况，记住传递的是地址，所以swap中进行交换，只是把这些对象指向的地址换了，在原方法中这些对象的地址是没变的

###### Unsafe

主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等

#### 集合面试题

![image-20231219204406441](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219204406441.png)

##### List

###### ArrayList和Array**的区别**

`ArrayList` 内部基于动态数组实现，比 `Array`（静态数组） 使用起来更加灵活：

- `ArrayList`会根据实际存储的元素动态地扩容或缩容，而 `Array` 被创建之后就不能改变它的长度了。
- `ArrayList` 允许你使用泛型来确保类型安全，`Array` 则不可以。
- `ArrayList` 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。`Array` 可以直接存储基本类型数据，也可以存储对象。
- `ArrayList` 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 `add()`、`remove()`等。`Array` 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。

`ArrayList`创建时不需要指定大小，而`Array`创建时必须指定大小。

![image-20231219224346858](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219224346858.png)

###### ArrayList插入和删除元素时间复杂度

对于插入：

- 头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。
- 尾部插入：当 `ArrayList` 的容量**未达到极限**时，往列表末尾插入元素的**时间复杂度是 O(1)**，因为它只需要在数组末尾添加一个元素即可；当**容量已达到极限并且需要扩容时**，则**需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中**，然后再执行 O(1) 的操作添加元素。
- 指定位置插入：**需要将目标位置之后的所有元素都向后移动一个位置**，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。

对于删除：

- 头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。
- 尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。
- 指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。

###### LinkedList 插入和删除元素

头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。

尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。

指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)

###### ArrayList 与 LinkedList 区别

- **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
- **底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）
- **插入和删除是否受元素位置的影响：**
  - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
  - `LinkedList` 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()`、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`,`remove(int index)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。
- **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 **`ArrayList`（实现了 `RandomAccess` 接口） 支持**。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
- **内存空间占用：** **`ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）**

##### Set

###### Comparable 和 Comparator 的区别

`Comparable` 接口和 `Comparator` 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：

- `Comparable` 接口实际上是出自`java.lang`包 它有一个 `compareTo(Object obj)`方法用来排序
- `Comparator`接口实际上是出自 `java.util` 包它有一个`compare(Object obj1, Object obj2)`方法用来排序

###### 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

底层实现不同

- `HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
- `HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。`TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
- 底层数据结构不同又导致这三者的应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。

##### Queue

###### Queue 与 Deque 的区别

**![](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221155138555-20231221160730944-20231221160751391.png)**

###### ArrayDeque 与 LinkedList 的区别

- `ArrayDeque` 是基于可变长的数组和双指针来实现，而 `LinkedList` 则通过链表来实现。
- `ArrayDeque` 不支持存储 `NULL` 数据，但 `LinkedList` 支持。
- `ArrayDeque` 是在 JDK1.6 才被引入的，而`LinkedList` 早在 JDK1.2 时就已经存在。
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好

###### PriorityQueue

其与 `Queue` 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。

- `PriorityQueue` 利用了**二叉堆的数据结构**来实现的，底层使用可变长的数组来存储数据

- `PriorityQueue` 通过**堆元素的上浮和下沉**，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。

- `PriorityQueue` 是**非线程安全**的，且不支持存储 `NULL` 和 `non-comparable` 的对象。

- `PriorityQueue` 默认是**小顶堆**，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

###### BlockingQueue

`BlockingQueue` （阻塞队列）是一个接口，继承自 `Queue`。`BlockingQueue`阻塞的原因是**其支持当队列没有元素时一直阻塞，直到有元素**；还支持如果**队列已满**，一直**等到队列可以放入新元素时再放入**。

BlockingQueue接口有很多实现类，包括ArrayBlockingQueue、LinkedBlockingQueue等

###### ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别

- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。
- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。
- 锁是否分离： `ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。
- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。这意味着，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。

##### Map

###### HashMap 和 Hashtable 的区别

- **线程是否安全：** `HashMap` 是**非线程安全的**，`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证**线程安全的话就使用 `ConcurrentHashMap`** 吧！）；

- **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；

- **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。

- **初始容量大小和每次扩充容量大小的不同：** ① **创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍**。② 创建时如果给定了容量初始值，那么 `Hashtable` 会直接使用你给定的大小，而 **`HashMap` 会将其扩充为 2 的幂次方大小**（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小

  **原因是：**希望哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的，用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ `(n - 1) & hash`”

- **底层数据结构：** JDK1.8 以后的 **`HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树**（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。`Hashtable` 没有这样的机制。

hashmap设置初始容量时的源码，这段代码通过位运算确定最接近并大于等于给定容量 `cap` 的 2 的幂的值

```java
/**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

###### HashMap 和 HashSet 区别

`HashSet` 底层就是基于 `HashMap` 实现的。（`HashSet` 的源码非常非常少，因为除了 `clone()`、`writeObject()`、`readObject()`是 `HashSet` 自己不得不实现之外，其他方法都是直接调用 `HashMap` 中的方法

![image-20231221174219484](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221174219484.png)

######  HashMap 和 TreeMap 区别

`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口，因此**多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力**

###### HashSet 如何检查重复

当你把对象加入`HashSet`时，`HashSet` 会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功

###### HashMap 的底层实现

JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过**扰动函数**处理过后得到 **hash 值**，然后通过 `(n - 1) & hash` （取余）判断当前元素**存放的位置**（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 **hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突**。

**扰动函数**指的就是 HashMap 的 `hash` 方法。使用 `hash` 方法也就是扰动函数是为了防止一些实现比较差的 `hashCode()` 方法 换句话说**使用扰动函数之后可以减少碰撞**。

![image-20231221210113846](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221210113846.png)

JDK1.8 之后在解决哈希冲突时有了较大的变化，当**链表长度大于阈值**（默认为 8）（将链表转换成红黑树**前**会判断，**如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树**）时，将**链表转化为红黑树**，以减少搜索时间

红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

###### HashMap 多线程操作导致死循环问题

JDK1.7 及之前版本的 `HashMap` 在多线程环境下扩容操作可能存在死循环问题，其原因是当一个桶位中有**多个元素需要进行扩容**时，**多个线程同时对链表进行操作**，**头插法**可能会导致链表中的节点**指向错误的位置**，从而形成一个**环形链表**，进而使得查询元素的操作陷入死循环无法结束。

![image-20231222100747245](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222100747245.png)

JDK1.8 版本的 HashMap 采用了**尾插法**而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，**保持了节点原来的相对顺序**，避免了链表中的环形结构。但是还是不建议在多线程下使用 `HashMap`，因为多线程下使用 `HashMap` 还是会存在数据覆盖的问题。并发环境下，推荐使用 **`ConcurrentHashMap`** 。

###### HashMap 为什么线程不安全

**JDK1.7 及之前版本**，在多线程环境下，`HashMap` 扩容时会造成**死循环和数据丢失**的问题。

数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。

**JDK 1.8 后**，在 `HashMap` 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有**数据覆盖**的风险

发生数据丢失的情况：

1. 两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。
2. 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。
3. 随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了

###### HashMap 常见的遍历方式

1. 使用 `entrySet()` 遍历

   ```java
   Map<String, Integer> map = new HashMap<>();
   // ...添加元素到map中
   for (Map.Entry<String, Integer> entry : map.entrySet()) {
       System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
   }
   ```

2. 使用 `keySet()` 遍历

   ```java
   for (String key : map.keySet()) {
       System.out.println("Key = " + key + ", Value = " + map.get(key));
   }
   ```

3. 使用 `values()` 遍历

   ```java
   for (Integer value : map.values()) {
       System.out.println("Value = " + value);
   }
   ```

4. 使用 Java 8 的 `forEach`

   ```java
   map.forEach((key, value) -> System.out.println("Key = " + key + ", Value = " + value));
   ```

5. 使用迭代器

   ```java
   Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();
   while (iterator.hasNext()) {
       Map.Entry<String, Integer> entry = iterator.next();
       System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
   }
   ```

###### ConcurrentHashMap 和 Hashtable 的区别

- 底层数据结构

  ConcurrentHashMap：在JDK1.7之前**分段的数组+链表** ，在JDK1.8后**数组+链表/红黑二叉树**

  HashTable：在JDK1.7之前**数组+链表**，

- **实现线程安全的方式**

  ConcurrentMap：

  **JDK1.7之前**，对整个桶数组进行了**分割分段(`Segment`，分段锁)**，即 **Segment 数组 + HashEntry 数组 + 链表**，每一把锁只**锁容器其中一部分数据**，**多线程访问容器里不同数据段的数据**，就**不会存在锁竞争**，提高并发访问率。 

  ![image-20231222105333437](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222105333437.png)

  **JDK1.8之后** ，**已经摒弃了 `Segment` 的概念**，而是直接用 **`Node` 数组+链表+红黑树的数据结构**来实现，**并发控制使用 `synchronized` 和 CAS 来操作**。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

  Hashtable：

  使用 `synchronized` 来保证线程安全，效率非常低下

###### ConcurrentHashMap 线程安全的具体实现方式/底层具体实现

**JDK1.8 之前**

首先将数据分为一段一段（这个“段”就是 `Segment`）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，参照上图

**`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成**

一个 `ConcurrentHashMap` 里包含一个 `Segment` 数组，`Segment` 的个数一旦**初始化就不能改变**。 **`Segment` 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写**

每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的

**JDK1.8 之后**

`ConcurrentHashMap` **取消了 `Segment` 分段锁**，采用 **`Node + CAS + synchronized`** 来保证并发安全。数据结构跟 `HashMap` 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将**链表（寻址时间复杂度为 O(N)）转换为红黑树**（寻址时间复杂度为 O(log(N))）。

Java 8 中，**锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点**，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升

######  ConcurrentHashMap 为什么 key 和 value 不能为 null

key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，**表示没有对象或没有引用**。**如果你用 null 作为键，那么你就无法区分这个键是否存在于 `ConcurrentHashMap` 中，还是根本没有这个键**。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 `ConcurrentHashMap` 中的，还是因为找不到对应的键而返回的。

但**HashMap**可以存储，可以通过**containsKey来查找**，而ConcurrentHashMap，存在一个线程操作该 `ConcurrentHashMap` 时，**其他的线程将该 `ConcurrentHashMap` 修改的情况**，所以**无法通过 `containsKey(key)`** 来判断否存在这个键值对，也就没办法解决二义性问题了

**线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）**

###### ConcurrentHashMap 能保证复合操作的原子性吗

**复合操作**是指由多个基本操作(如`put`、`get`、`remove`、`containsKey`等)组成的操作，例如先判断某个键是否存在`containsKey(key)`，然后根据结果进行插入或更新`put(key, value)`。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期

`ConcurrentHashMap` 提供了一些**原子性的复合操作**，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。**这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中**

![image-20231222113526863](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222113526863.png)

##### 集合操作的注意事项

###### 集合判空

**判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式**

这是因为 `isEmpty()` 方法的可读性更好，并且时间复杂度为 O(1)，而ConcurrentLinkedQueue`、`ConcurrentHashMap的size( )的时间复杂度就不是O(1)

###### 集合转 Map

**在使用 `java.util.stream.Collectors` 类的 `toMap()` 方法转为 `Map` 集合时，一定要注意当 value 为 null 时会抛 NPE 异常**

```java
class Person {
    private String name;
    private String phoneNumber;
     // getters and setters
}

List<Person> bookList = new ArrayList<>();
bookList.add(new Person("jack","18163138123"));
bookList.add(new Person("martin",null));
// 空指针异常
bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));

```

因为toMap方法会调用`Map` 接口的 `merge()` 方法，`merge()` 方法会先调用 `Objects.requireNonNull()` 方法判断 value 是否为空。

###### 集合遍历

**不要在 foreach 循环里进行元素的 `remove/add` 操作。remove 元素请使用 `Iterator` 方式，如果并发操作，需要对 `Iterator` 对象加锁**

这是因为使用 `foreach` 循环（或 Java 中的增强型 for 循环）遍历集合时，底层用的是**集合的迭代器**实现，而**集合迭代器在遍历过程中要求集合结构保持不变**，所以会抛出`ConcurrentModificationException` 异常

而使用可以使用**迭代器（`Iterator`）的 `remove` 方法**。这种方式允许你在遍历时修改集合，而不会抛出 `ConcurrentModificationException`。

```java
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    if (someCondition(element)) {
        iterator.remove(); // 安全移除元素
    }
}
```

并且如果在**多线程环境中**，**多个线程同时遍历和修改同一个集合**，即使是使用迭代器的 `remove` 方法，也可能会遇到**并发问题**

所以在并发操作时，需要对**迭代器或集合对象加锁**，以保证在**一个线程遍历和修改集合时，其他线程不能进行修改**。这可以通过同步代码块或使用并发集合来实现，可以使用 `synchronized` 关键字来实现加锁

###### 集合去重

**可以利用 `Set` 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 `List` 的 `contains()` 进行遍历去重或者判断包含操作**

下面是Set和List去重的代码

```java
// Set 去重代码示例
public static <T> Set<T> removeDuplicateBySet(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new HashSet<>();
    }
    return new HashSet<>(data);
}

// List 去重代码示例
public static <T> List<T> removeDuplicateByList(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new ArrayList<>();

    }
    List<T> result = new ArrayList<>(data.size());
    for (T current : data) {
        if (!result.contains(current)) {
            result.add(current);
        }
    }
    return result;
}

```

两者的区别在于**`HashSet` 的 `contains()` 方法底部依赖的 `HashMap` 的 `containsKey()` 方法，时间复杂度接近于 O（1）**，而**`ArrayList` 的 `contains()` 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)**

###### 集合转数组

**使用集合转数组的方法，必须使用集合的 `toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。**

例如下面代码，传入new String[0]表示类型

下面的Arrays.asList方法，对list进行反转，同样的s数组也会反转

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};
List<String> list = Arrays.asList(s);
Collections.reverse(list);
//没有指定类型的话会报错
s=list.toArray(new String[0]);

```

最后一行虽然传入了一个长度为 0 的数组，但 Java 会根据列表的大小创建一个新的、合适大小的数组。

###### 数组转集合

使用工具类 `Arrays.asList()` 把数组转换成集合时，**不能使用其修改集合相关的方法**， 它的 `add/remove/clear` 方法会抛出 `UnsupportedOperationException` 异常

这里使用asList将数组转化为集合，只是传入了一个元素，list里面只有一个元素

```java
int[] myArray = {1, 2, 3};
List myList = Arrays.asList(myArray);
System.out.println(myList.size());//1
System.out.println(myList.get(0));//数组地址值
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
int[] array = (int[]) myList.get(0);
System.out.println(array[0]);//1
```

同时，使用集合的方法也会报错

```java
List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
```

所以要将数组转化为ArrayList可以用以下方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());

```

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```

##### 集合源码分析

###### ArrayList源码分析

数组队列，相当于动态数组，其容量能**动态增长**

在**添加大量元素**前，应用程序可以使用**`ensureCapacity`操作**来**增加 `ArrayList` 实例的容量**

```java

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{

  }

```

从这个继承关系可以看出

- `List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。
- `RandomAccess` ：这是一个标志接口，表明实现这个接口的 `List` 集合是支持 **快速随机访问** 的。在 `ArrayList` 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。
- `Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。
- `Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。

**ArrayList和vector的区别在于：**

- ArrayList是List的主要实现类，vector是以前的实现类
- ArrayList线程不安全，vector线程安全

**ArrayList扩容机制**

1. **初始容量**： 当创建 `ArrayList` 时，你可以指定一个初始容量。如果没有指定，`ArrayList` 将使用默认容量大小（在 Java 8 中，默认为 10）。
2. **添加元素**： 当向 `ArrayList` 添加元素且内部数组无法容纳更多元素时，`ArrayList` 需要扩容。
3. **新容量计算**： 新容量的计算公式取决于 `ArrayList` 的版本。在大多数实现中，新容量是旧容量的 1.5 倍。例如，如果当前容量为 10，扩容后将变为 15。这个增长率是一个折中的选择，旨在平衡内存使用和性能。
4. **创建新数组并复制元素**： `ArrayList` 会创建一个新的、更大的数组。然后，它将旧数组中的所有元素复制到新数组中。
5. **废弃旧数组**： 一旦旧数组中的元素被复制到新数组中，旧数组就会被废弃，以便垃圾收集器回收。

###### LinkedList源码分析

#### 并发

###### 线程和进程概念

**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程

在 Java 中，当我们**启动 main 函数**时其实就是启动了一个 **JVM 的进程**，而 **main 函数所在的线程**就是这个进程中的一个线程，也称**主线程**

**线程**是一个**比进程更小的执行单位**。一个进程在其执行的过程中可以**产生多个线程**。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为**轻量级进程**。

**一个 Java 程序的运行是 main 线程和多个其他线程同时运行**

###### 线程和进程的关系、区别及优缺点

一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器**、**虚拟机栈** 和 **本地方法栈**

 **线程是进程划分成的更小的运行单位**。线程和进程最大的不同在于基本上**各进程是独立的**，而**各线程则不一定**，因为**同一进程中的线程极有可能会相互影响**。线程执行开销小，但不利于资源的管理和保护；而进程正相反。

###### 程序计数器为什么是私有的

程序计数器的作用：

1. 字节码解释器通过程序计数器来依次读取指令，从而实现代码的流程控制，如顺序执行，选择等
2. 在多线程的情况下，通过程序计数器来记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪了

如果执行的是 **native 方法**，那么程序计数器记录的是 **undefined 地址**，**只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址**

`native` 关键字在 Java 中用于标识一个方法，表明该方法是用**非 Java 语言（如 C 或 C++）编写的**，并且在运行时由本地方法接口（JNI, Java Native Interface）调用。这些方法通常用于**执行不能直接用 Java 实现的操作**，如与操作系统交互、调用系统级别的库函数等。

**程序计数器私有**主要是为了**线程切换后能恢复到正确的执行位置**

###### 虚拟机栈和本地方法栈为什么是私有的

**虚拟机栈**：**每个java方法**在**执行前**会**创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息**。从**方法调用直至执行完成**的过程，就对应着**一个栈帧在 Java 虚拟机栈中入栈和出栈**的过程。

本地方法栈：和虚拟机栈的作用类似，从名字可以看出**本地方法栈是为虚拟机使用到的Native方法**服务

所以为了保证**线程中的局部变量不被其他线程访问到**，将其设置为私有的

###### 堆和方法区

堆和方法区是所有线程**共享的资源**，其中**堆是进程中最大的一块内存**，主要用于**存放新创建的对象**（几乎所有对象都在这里分配内存），**方法区主要用于存放已被加载的类信息，常量，静态变量，编译后的代码等数据**。

###### Java 线程和操作系统的线程有啥区别

**JDK1.2之前**：Java线程是基于**绿色线程**实现的，这是一种**用户级线程**（用户线程），和原生线程比起来在使用时有一些限制（比如绿色线程**不能直接使用操作系统提供的功能**如异步 I/O、只能在一个内核线程上运行，无法利用多核）

JDK1.2之后：Java 线程改为基于原生线程实现，**现在的 Java 线程的本质其实就是操作系统的线程**

###### 用户线程与内核线程

- **用户线程**：由**用户空间程序管理和调度的线程**，运行在**用户空间**（专门给应用程序使用）
- **内核线程**：由**操作系统内核管理和调度的线程**，运行在**内核空间**（只有内核程序可以访问）

即**用户线程创建和切换成本低**，但**不可以利用多核**。**内核态线程**，创建和切换成本**高**，可以**利用多核**

**线程模型是用户线程和内核线程**之间的**关联方式**，共有下面三种方式：

1. 一对一（一个用户线程对应一个内核线程）
2. 多对一（多个用户线程映射到一个内核线程）
3. 多对多（多个用户线程映射到多个内核线程）

**Java 线程**采用的是**一对一的线程模型**，也就是**一个 Java 线程对应一个系统内核线程**。

###### 并发和并行

**并发**：两个及以上的作业在同一时间段内工作

**并行**：两个及以上的作用在同一时刻工作

###### 同步和异步

**同步**：发布一个调用之后，在没有得到结果之前，该调用就不可以返回，需要一直等待

**异步**：调用发布之后，不用等待结果，直接返回

###### 为什么使用多线程

从总体而言：

- **线程的轻量级**：从计算机底层而言线程可以比作轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的花销
- **多线程并发编程正是开发高并发系统的基础**，利用多线程机制可以大大提高整体的并发能力和性能

从计算机底层而言：

**单核时代**：在**单核时代利用多线程主要是为了提高单线程利用CPU和IO的效率**，比如说当一个线程在进行io操作时阻塞的时候，就可以使用其他的线程，从而提高CPU的利用率

**多核时代**：在多核时代利用多线程主要是为了提高多线程利用**多核CPU**的能力，

从**资源分配和调度**的角度，**进程**是操作系统的基本单位，从**执行和任务处理**的角度，**线程**是 CPU 调度和执行的基本单位

**多线程可能带来的问题：内存泄漏、死锁、线程不安全**

###### 线程安全和不安全

线程安全和不安全是在**多线程环境**下对于**同一份数据的访问**是否能够**保证其正确性和一致性**的描述

- 线程安全：对于同一份数据，不管有多少线程同时访问，都能保证数据的一致性和准确性
- 线程不安全：对于同一份数据，多个线程同时访问，可能会导致数据混乱、错误丢失等

###### 单核CPU运行多线程效率一定高吗

取决于**线程的类型**和**任务的性质**，一般来说，有两种类型的线程：**CPU 密集型和 IO 密集型**。

**CPU 密集型**的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。

**IO 密集型**的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。

所以如果是**CPU 密集型的线程**在单核上运行的话，多个线程不断切换，**增加了系统的开销，降低了效率**。如果线程是 **IO 密集型**的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，**提高了效率**

###### 线程的生命周期和状态

- NEW：初始状态，线程被创建出来但是还没有被调用

- RUNNABLE：运行状态，线程被调用start()等待运行状态

- BLOCKED：阻塞状态，需要等待锁的释放

  当线程进入 **`synchronized`** 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态

- WAITING：等待状态，表示该进程需要等待其他进程做一些特定的动作

  进入等待状态的线程需要**依靠其他线程的通知**才能够返回到运行状态。

- TIME_WAITING：超时等待状态，可以**在指定的时间后自行返回**而不是像 WAITING 那样一直等待

  比如通过 **`sleep（long millis）`**方法或 **`wait（long millis）`**方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。

- TERMINATED：终止状态，表示该线程已经运行完毕

  `run()`方法之后将会进入到该状态

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换

线程创建之后它将处于 **NEW（新建）** 状态，调用 **`start()`** 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **RUNNING（运行）** 状态。

在**操作系统**层面，线程有 **READY 和 RUNNING** 状态，但在 **JVM** 层面，只能看到 **RUNNABLE** 状态，所以 Java 系统一般将这两个状态统称为 **RUNNABLE（运行中）** 状态

在JVM中**没有区分READY和RUNNING状态**的**原因**是：现在的时分多任务操作系统架构采用的是抢占式轮转调度，这种方式时间分片通常很小，每个线程一次只在CPU上执行很短的时间，就被换下去继续去排队了，所以区分两个状态没太大意义

###### 什么是线程上下文切换

线程在执行过程中会有自己的运行条件和状态，遇到下面情况会从运行状态退出

- 主动让出 CPU，比如调用了 **`sleep()`, `wait()`** 等
- **时间片用完**，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死
- 调用了**阻塞类型**的系统中断，比如**请求 IO，线程被阻塞**
- 被终止或结束运行

这其中**前三种都会发生线程切换**，线程切换意味着需要**保存当前线程的上下文**，**留待线程下次占用 CPU 的时候恢复现场**。并加载下一个将要占用 CPU 的线程上下文

###### 线程死锁

**多个线程同时被阻塞**，它们中的**一个或者全部都在等待其中某个资源被释放**。由于**线程被无限期地阻塞，因此程序不可能正常终止**。

下面是一个死锁的代码：

线程 A 通过 **`synchronized (resource1)` 获得 `resource1` 的监视器锁**，然后通过**`Thread.sleep(1000)**`让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2** 的监视器锁。**线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源**，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。

```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                System.out.println(Thread.currentThread() + "get resource1");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource2");
                synchronized (resource2) {
                    System.out.println(Thread.currentThread() + "get resource2");
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                System.out.println(Thread.currentThread() + "get resource2");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread() + "waiting get resource1");
                synchronized (resource1) {
                    System.out.println(Thread.currentThread() + "get resource1");
                }
            }
        }, "线程 2").start();
    }
}

```

产生死锁的四个必要条件：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个线程因**请求资源而阻塞时，对已获得的资源保持不放**。
3. **不剥夺条件**:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**:若干线程之间形成一种头尾相接的循环等待资源关系

因此**预防死锁**就是**破坏上面的必要条件**

1. **破坏请求与保持条件**：一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

**避免死锁**

借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态

**安全状态** 指的是**系统能够按照某种线程推进顺序**（P1、P2、P3……Pn）来为**每个线程分配所需资源**，直到**满足每个线程对资源的最大需求**，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。

###### sleep方法和wait方法

**共同点**：两者都可以**暂停线程的执行**

**不同点**：

- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁**

  即sleep的时候，其他线程仍无法调用该线程锁的对象

- `wait()` 通常被用于**线程间交互/通信**，`sleep()`通常被用于**暂停执行**

  因为wait释放了锁

- `wait()` 方法被调用后，线程**不会自动苏醒**，需要别的线程调用同一个对象上的 **`notify()`或者 `notifyAll()` 方法**。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。

  wait操作后被唤醒状态进入**就绪状态**后，仍然需要等待**获取对象的锁**才能继续执行

- **`sleep()` 是 `Thread` 类的静态本地方法**，**`wait()` 则是 `Object` 类的本地方法**

###### 为什么 wait() 方法不定义在 Thread 中

**`wait()`** 是让**获得对象锁的线程实现**等待，会**自动释放当前线程占有的对象锁**。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。

因此同样的**为什么 `sleep()` 方法定义在 `Thread` 中**是因为：`sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁

###### 可以直接调用 Thread 类的 run 方法吗

直接run意味着没有start方法，**start方法会启动一个线程并让其进入就绪状态**，如果没有这个步骤直接run的话，就只能当成一个 main 线程下的**普通方法去执行**，并不会在某个线程中执行它，所以这并**不是多线程工作**

###### volatile 关键字

`volatile` 关键字可以保证变量的可见性，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到**主存**中进行读取

即声明该变量在**主存**中，在 C 语言里也有，它最原始的意义就是**禁用 CPU 缓存**

**volatile关键字**可以用于**确保被修饰的变量对所有线程的可见性**，即当一个线程修改了该变量的值后，其他线程能够立即看到最新的值。但volatile不能保证**多个线程同时对该变量进行读取和写入的操作是原子性的**，所以当多个线程同时操作的时候，那么就有可能出现**数据不一致的情况**

![image-20231225234414847](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231225234414847.png)

**synchronized**关键字既可以**保证数据的可见性，也可以保证数据的原子性**。当某个线程进入synchronized代码块时，它会锁定该对象或类，并且在执行完代码块后会释放锁，这样其他线程才能获取锁并执行相应的代码。在synchronized代码块中对**共享变量的读取和写入操作都是原子的**，即一个线程正在**执行synchronized代码块**时，**其他线程无法同时访问该代码块中的共享变量**，从而保证了数据的一致性和原子性。

并且**`volatile` 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。**将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，会通过插入特定的 **内存屏障** 的方式来**禁止指令重排序**

**双重校验锁实现对象单例**

当第一次调用getInstance()方法时，由于instance为null，两个线程可能同时进入第一个if语句块。在synchronized关键字的作用下，只有一个线程能够进入同步块，另一个线程会被阻塞。

在进入同步块后，再次检查instance是否为null。这是因为当两个线程都通过了第一次检查时，如果没有第二次检查，就会创建两个实例。所以，在第二次检查前，只有一个线程能够创建实例。

```java
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {
        // 私有化构造函数防止外部实例化
    }

    public static Singleton getInstance() {
        if (instance == null) {  // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {  // 第二次检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```

###### 乐观锁和悲观锁

**悲观锁：**每次假设最坏的情况，认为资源每次被访问的时候都会出现问题，所以每次获取资源的时候都会上锁，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**

**`synchronized`**和**`ReentrantLock`**等独占锁就是悲观锁思想的实现

**高并发的场景**下，激烈的锁竞争会造成**线程阻塞**，大量阻塞线程会导致系统的上下文切换，**增加系统的性能开销**。并且，悲观锁还可能会存在**死锁问题**，影响代码的正常运行

**乐观锁：**总是假设**最好的情况**，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在**提交修改**的时候去**验证对应的资源是否被其它线程修改了**

乐观锁的一种实现方式 **CAS** 实现

高并发的场景下，乐观锁相比悲观锁来说，**不存在锁竞争造成线程阻塞，也不会有死锁的问题**，在性能上往往会更胜一筹

理论上来说：

- 悲观锁通常多用于**写比较多的情况**（多写场景，竞争激烈），这样**可以避免频繁失败和重试影响性能**，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如`LongAdder`），也是可以考虑使用乐观锁的，要视实际情况而定。
- 乐观锁通常多用于**写比较少的情况**（多读场景，竞争较少），这样**可以避免频繁加锁影响性能**。不过，**乐观锁主要针对的对象是单个共享变量**（参考`java.util.concurrent.atomic`包下面的原子变量类）

###### 实现乐观锁

乐观锁一般会使用版本号机制或 CAS 算法实现

**版本号机制**

在数据表中加上一个数据版本号 **`version`** 字段，表示**数据被修改的次数**。**当数据被修改时，`version` 值会加一**。当线程 A 要更新数据值时，在读取数据的同时也会读取 `version` 值，在提交更新时，若刚才读取到的 **version 值为当前数据库中的 `version` 值相等时**才更新，否则重试更新操作，直到更新成功。

**CAS 算法**

全称是 **Compare And Swap（比较与交换）**，用一个预期值和要更新的变量值进行比较，两值相等才会进行更新

CAS 涉及到三个操作数：

- **V**：要更新的变量值(Var)
- **E**：预期值(Expected)
- **N**：拟写入的新值(New)

当且仅当 **V 的值等于 E** 时，CAS 通过原子方式用**新值 N 来更新 V 的值**。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新

Java 语言并没有直接实现 CAS，**CAS 相关的实现是通过 C++ 内联汇编的形式实现的**

###### 乐观锁存在的问题

**ABA问题**

如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，但可能在这段时间它的值可能被改为其他值，然后又改回 A

ABA 问题的解决思路是在变量前面追加上**版本号或者时间戳**

**循环时间长开销大**

CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销

**只能保证一个共享变量的原子操作**

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效

######  synchronized 关键字

`synchronized` 是 Java 中的一个关键字，主要解决的是**多个线程之间访问资源的同步性**，可以保证被它修饰的**方法或者代码块**在**任意时刻**只能有**一个线程执行**

在Java早期，**synchronized**属于**重量级锁**，效率低下。这是因为**监视器锁（monitor）依赖于底层的操作系统**的 `Mutex Lock` 来实现的，Java 的线程是**映射到操作系统的原生线程之上的**。**如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成**，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换**需要相对比较长的时间，时间成本相对较高**

在Java6之后，**`synchronized`** 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 `synchronized` 锁的效率提升了很多

###### 如何使用 synchronized

synchronized主要修饰下面三种情况

1. 修饰实例方法
2. 修饰静态方法
3. 修饰代码块

**修饰实例方法**

**给当前对象实例加锁**，进入同步代码前要获得 **当前对象实例的锁**

```java
synchronized void method() {
    //业务代码
}
```

**修饰静态方法**

给当前**类加锁**，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**

因为**静态成员**不属于任何一个实例对象，归**整个类所有**，**不依赖于类的特定实例**，被**类的所有实例共享**

```java
synchronized static void method() {
    //业务代码
}
```

**静态 `synchronized` 方法和非静态 `synchronized` 方法之间的调用互斥**么？**不互斥**！如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**

**修饰代码块**

- `synchronized(object)` 表示进入同步代码库前要获得 **给定对象的锁**。
- `synchronized(类.class)` 表示进入同步代码前要获得 **给定 Class 的锁**

```java
synchronized(this) {
    //业务代码
}
```

**总结：**

- `synchronized` 关键字加到 `static` **静态方法**和 **`synchronized(class)`** 代码块上都是是给 **Class 类上锁**；
- `synchronized` 关键字加到实例方法上是给**对象实例上锁**；
- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。

###### 构造方法可以用 synchronized 修饰么

**构造方法不能使用 synchronized 关键字修饰**，因为构造方法本就线程安全，也不需要加锁

###### synchronized 底层原理

**synchronized 同步语句块的情况**

```java
public class SynchronizedDemo {
    public void method() {
        synchronized (this) {
            System.out.println("synchronized 代码块");
        }
    }
}
```

`synchronized` 同步语句块的实现**使用的是 `monitorenter` 和 `monitorexit` 指令**，其中 **`monitorenter` 指令指向同步代码块的开始位置**，**`monitorexit` 指令则指明同步代码块的结束位置。**

当**执行 `monitorenter` 指令时**，**线程**试图获取锁也就是获取 **对象监视器 `monitor`** 的持有权，在执行`monitorenter`时，**会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1**

对象锁的的拥有者线程才可以执行 `monitorexit` 指令来释放锁。**在执行 `monitorexit` 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁**。

**synchronized 修饰方法的的情况**

```java
public class SynchronizedDemo2 {
    public synchronized void method() {
        System.out.println("synchronized 方法");
    }
}

```

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 **`ACC_SYNCHRONIZED`** 标识，该标识**指明了该方法是一个同步方法**。**JVM 通过该 `ACC_SYNCHRONIZED` 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用**

如果是**实例方法**，JVM 会尝试**获取实例对象的锁**。如果是**静态方法**，JVM 会尝试**获取当前 class 的锁**

**不过两者的本质都是对对象监视器 monitor 的获取**

###### JDK1.6 之后的 synchronized 底层做的优化

JDK1.6 对锁的实现引入了大量的优化，如**偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销**。

- 自旋锁：在获取锁失败时，线程不会立即阻塞，而是**进行一定次数的自旋尝试**，期望在短时间内其他线程会释放锁。这样可以减少线程切换的开销，提高性能。
- 适应性自旋锁：根据当前**线程在临界区的等待时间和其他线程的情况动态调整自旋的次数**，以平衡性能和资源的利用。
- 锁消除：通过逃逸分析，**JVM 可以判断某些锁是不可能被其他线程访问到的**，从而可以安全地消除这些锁，减少不必要的同步操作。
- 锁粗化：**当连续的对同一对象进行加锁和解锁操作时，JVM 可以将这些操作合并成一次更大范围的锁，从而减少锁操作的次数**。

锁主要存在四种状态，依次是：**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态**，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

1. 无锁状态（Unlocked）：在**无竞争的情况**下，对象的锁处于无锁状态。当一个线程尝试获取对象的锁时，如果对象处于无锁状态，可以直接将对象标记为自己所持有的锁，并继续执行，无需进行额外的操作。
2. 偏向锁状态（Biased Locking）：偏向锁是JDK 1.6 引入的一项优化技术，旨在解决只有**一个线程访问同步块的场景**。**当一个线程第一次进入同步块时，对象的标记被该线程所偏向，并记录下该线程的ID**。之后，该线程再次进入同步块时，无需进行任何同步操作，因为对象已经偏向于该线程。
3. 轻量级锁状态（Lightweight Locking）：当**多个线程竞争同一个锁**时，偏向锁会升级为轻量级锁。轻量级锁使用**CAS操作**来避免使用互斥量，尝试在用户态下使用自旋锁来避免线程的切换，从而减少对操作系统的调用。
4. 重量级锁状态（Heavyweight Locking）：如果轻量级锁无法解决竞争问题，锁就会膨胀为重量级锁，此时涉及到操作系统的互斥量，线程会被阻塞，陷入内核态，这会引起较大的性能开销。

###### synchronized 和 volatile 有什么区别

- `volatile` 关键字是线程同步的**轻量级实现**，所以 `volatile`性能肯定比`synchronized`关键字要好 。但是 **`volatile` 关键字只能用于变量**而 `synchronized` 关键字可以修饰**方法以及代码块** 。
- `volatile` 关键字**能保证数据的可见性，但不能保证数据的原子性**。`synchronized` 关键字两者都能保证。
- `volatile`关键字主要用于**解决变量在多个线程之间的可见性**，而 `synchronized` 关键字解决的是**多个线程之间访问资源的同步性**。

###### ReentrantLock

`ReentrantLock` 实现了 **`Lock` 接口**，是一个**可重入且独占式**的锁，和 `synchronized` 关键字类似。不过，`ReentrantLock` 更灵活、更强大，**增加了轮询、超时、中断、公平锁和非公平锁等高级功能**。

`ReentrantLock` 里面有一个内部类 `Sync`，`Sync` 继承 **AQS**（`AbstractQueuedSynchronizer`），**添加锁和释放锁的大部分操作实际上都是在 `Sync` 中实现的**。

**`Sync` 有公平锁 `FairSync` 和非公平锁 `NonfairSync`** 两个子类。

`ReentrantLock` **默认使用非公平锁**，也可以通过**构造器**来显式的指定**使用公平锁**

```java
// 传入一个 boolean 值，true 时为公平锁，false 时为非公平锁
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}

```

###### 公平锁和非公平锁有什么区别

- **公平锁** : 锁被释放之后，**先申请的线程先得到锁**。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。
- **非公平锁**：锁被释放之后，后申请的线程可能会先获取到锁，**是随机或者按照其他优先级排序的**。性能更好，但可能会导致某些线程永远无法获取到锁。

###### synchronized 和 ReentrantLock 有什么区别

- **两者都是可重入锁**

  **可重入锁** 也叫**递归锁**，指的是**线程可以再次获取自己的内部锁**。比如**一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的**，如果是**不可重入锁的话，就会造成死锁**，因为一直在等待获取这个资源才释放

JDK 提供的所有现成的 `Lock` 实现类，包括 `synchronized` 关键字锁都是可重入的

- **synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API**

  **`synchronized`** 是**依赖于 JVM 实现**的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 `synchronized` 关键字进行了很多优化，但是这些优化都是**在虚拟机层面实现的，并没有直接暴露**给我们。

  `ReentrantLock` 是 **JDK 层面实现**的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过**查看它的源代码，来看它是如何实现的**

- **ReentrantLock 比 synchronized 增加了一些高级功能**
  - **等待可中断**：正在等待的线程可以选择放弃等待，改为处理其他事情
  - **可实现公平锁**
  - **可实现选择性通知**：`synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法

###### 可中断锁和不可中断锁有什么区别

- **可中断锁**：获取锁的过程中可以被中断，**不需要一直等到获取锁之后 才能进行其他逻辑处理**。`ReentrantLock` 就属于是可中断锁。
- **不可中断锁**：一旦线程**申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理**。 `synchronized` 就属于是不可中断锁。

###### ReentrantReadWriteLock

`ReentrantReadWriteLock` 实现了 `ReadWriteLock` ，是一个**可重入的读写锁**，既可以保证多个线程同时读的效率，同时又可以保证有**写入操作时的线程安全**

`ReentrantReadWriteLock` 其实是两把锁，**一把是 `WriteLock` (写锁)，一把是 `ReadLock`（读锁）** 

读锁是共享锁，写锁是独占锁。**读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有**

`ReentrantReadWriteLock` 也支持公平锁和非公平锁，**默认使用非公平锁**，可以通过构造器来显示的指定

因此：由于 `ReentrantReadWriteLock` 既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。因此，**在读多写少的情况下**，使用 `ReentrantReadWriteLock` 能够明显提升系统性能

###### 线程持有读锁还能获取写锁吗

- 在**线程持有读锁的情况下**，该线程**不能取得写锁**
- 在**线程持有写锁的情况下**，该线程**可以继续获取读锁**

##### StampedLock

`StampedLock` 是 JDK 1.8 引入的**性能更好的读写锁**，**不可重入且不支持条件变量** `Conditon`

`StampedLock` 并**不是直接实现 `Lock`或 `ReadWriteLock`接口**，而是基于 **CLH 锁** 独立实现的（AQS 也是基于这玩意）

- **写锁**：独占锁，一把锁只能被一个线程获得。当一个线程获取写锁后，其他请求读锁和写锁的线程必须等待。类似于 `ReentrantReadWriteLock` 的写锁，不过这里的写锁是不可重入的。
- **读锁** （悲观读）：共享锁，没有线程获取写锁的情况下，多个线程可以同时持有读锁。如果己经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。类似于 `ReentrantReadWriteLock` 的读锁，不过这里的读锁是不可重入的
- **乐观读**：允许多个线程获取乐观读以及读锁。同时允许一个写线程获取写锁。

性能更好的原因：`StampedLock` 的乐观**读允许**一个写线程**获取写锁**，所以不会导致所有写线程阻塞，也就是**当读多写少的时候**，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高。

#####  ThreadLocal

我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？**

JDK 中自带的`ThreadLocal`类正是为了解决这样的问题，**`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据**

如果你创建了一个`ThreadLocal`变量，那么**访问这个变量的每个线程都会有这个变量的本地副本**，这也是`ThreadLocal`变量名的由来。他们可以使用 **`get()` 和 `set()` 方法来获取默认值或将其值更改为当前线程所存的副本的值**，从而避免了线程安全问题

样例：

```java
import java.text.SimpleDateFormat;
import java.util.Random;

public class ThreadLocalExample implements Runnable{

     // SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本
    private static final ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyyMMdd HHmm"));

    public static void main(String[] args) throws InterruptedException {
        ThreadLocalExample obj = new ThreadLocalExample();
        for(int i=0 ; i<10; i++){
            Thread t = new Thread(obj, ""+i);
            Thread.sleep(new Random().nextInt(1000));
            t.start();
        }
    }

    @Override
    public void run() {
        System.out.println("Thread Name= "+Thread.currentThread().getName()+" default Formatter = "+formatter.get().toPattern());
        try {
            Thread.sleep(new Random().nextInt(1000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //formatter pattern is changed here by thread, but it won't reflect to other threads
        formatter.set(new SimpleDateFormat());

        System.out.println("Thread Name= "+Thread.currentThread().getName()+" formatter = "+formatter.get().toPattern());
    }

}

```

这段代码展示了如何在多线程环境下使用 `ThreadLocal` 来实现线程安全的 `SimpleDateFormat` 对象

1. 在 `ThreadLocalExample` 类中，我们定义了一个静态变量 `formatter`，它的类型是 `ThreadLocal<SimpleDateFormat>`。这意味着每个线程都可以拥有自己独立的 `SimpleDateFormat` 对象，而不需要担心线程安全性。
2. 在 `main` 方法中，我们创建了一个 `ThreadLocalExample` 对象，并启动了 10 个线程。每个线程都会输出当前线程的名称以及默认的 `SimpleDateFormat` 格式。
3. 在 `run` 方法中，每个线程首先输出当前线程名称和默认的日期格式。然后线程会随机休眠一段时间，模拟不同线程的执行速度不同。
4. 接着，每个线程会尝试修改 `SimpleDateFormat` 对象的格式。虽然每个线程都调用了 `formatter.set(new SimpleDateFormat())` 来更改日期格式，但由于使用了 `ThreadLocal`，所以这个更改只会作用于当前线程的 `SimpleDateFormat` 对象，不会影响其他线程的对象。

通过这段代码，我们可以清楚地看到 `ThreadLocal` 的作用：**它能够为每个线程提供独立的、线程安全的对象副本，从而避免了多线程环境下的竞争和同步问题。这在需要使用非线程安全对象的情况下非常有用，比如 `SimpleDateFormat`**

**ThreadLocal 原理**

```java
public class Thread implements Runnable {
    //......
    //与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;

    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    //......
}
```

从上面`Thread`类 源代码可以看出`Thread` 类中有一个 **`threadLocals`** 和 一个 **`inheritableThreadLocals`** 变量，这两个变量ThreadLocalMap类型变量，可以理解为定制的HashMap，**默认情况下为null**，当前线程调用 `ThreadLocal` 类的 **`set`或`get`方法时才创建它们**

`ThreadLocal`类的`set()`方法

```java
public void set(T value) {
    //获取当前请求的线程
    Thread t = Thread.currentThread();
    //取出 Thread 类内部的 threadLocals 变量(哈希表结构)
    ThreadLocalMap map = getMap(t);
    if (map != null)
        // 将需要存储的值放入到这个哈希表中
        map.set(this, value);
    else
        createMap(t, value);
}
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

**最终的变量是放在了当前线程的 `ThreadLocalMap` 中，并不是存在 `ThreadLocal` 上，`ThreadLocal` 可以理解为只是`ThreadLocalMap`的封装，传递了变量值。**`ThrealLocal` 类中可以通过`Thread.currentThread()`获取到当前线程对象后，直接通过`getMap(Thread t)`可以访问到该线程的`ThreadLocalMap`对象。

**每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对。**

即每个线程有个一个hashmap，这个hashmap存储了很多键值对，键是`ThreadLocal`，值是设置的值

比如我们在同一个线程中声明了两个 `ThreadLocal` 对象的话， `Thread`内部都是使用**仅有的那个`ThreadLocalMap` 存放数据的**，**`ThreadLocalMap`的 key 就是 `ThreadLocal`对象，value 就是 `ThreadLocal` 对象调用`set`方法设置的值**。

**ThreadLocal 内存泄露问题是怎么导致的**

`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用，而 value 是强引用。所以，如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，**key 会被清理掉，而 value 不会被清理掉**。

这样一来，**`ThreadLocalMap` 中就会出现 key 为 null 的 Entry**。假如我们不做任何措施的话，**value 永远无法被 GC 回收，这个时候就可能会产生内存泄露**。`ThreadLocalMap` 实现中已经考虑了这种情况，在调用 `set()`、`get()`、`remove()` 方法的时候，**会清理掉 key 为 null 的记录**。使用完 `ThreadLocal`方法后最好手动调用`remove()`方法

弱引用：如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。**在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存**。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

`Java`的**四种引用类型**

**强引用**：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候

**软引用**：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收

**弱引用**：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收

**虚引用**：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知

#####  线程池

线程池就是**管理一系列线程的资源池**。当有任务要处理时，**直接从线程池中获取线程来处理**，处理完之后**线程并不会立即被销毁，而是等待下一个任务**

池化技术的思想主要是为了**减少每次获取资源的消耗，提高对资源的利用率**。

线程池使用的好处

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

- **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。

- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

**创建线程池**

**方式一：通过`ThreadPoolExecutor`构造函数来创建**

**方式二：通过 `Executor` 框架的工具类 `Executors` 来创建**

并且可以创建多种类型的 `ThreadPoolExecutor`：

- **`FixedThreadPool`**：该方法**返回一个固定线程数量的线程池。该线程池中的线程数量始终不变**。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。

- **`SingleThreadExecutor`：** 该方法**返回一个只有一个线程的线程池**。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。

- **`CachedThreadPool`：** 该方法**返回一个可根据实际情况调整线程数量的线程池**。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。

- **`ScheduledThreadPool`**：该方法**返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池**。

《阿里巴巴 Java 开发手册》中强制**线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor` 构造函数的方式**，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险

**`Executors` 返回线程池对象的弊端如下（即使用默认方式创建线程池的坏处）**：

- **`FixedThreadPool` 和 `SingleThreadExecutor`**：使用的是无界的 `LinkedBlockingQueue`，任务队列最大长度为 `Integer.MAX_VALUE`,可能堆积大量的请求，从而导致 OOM。

- **`CachedThreadPool`**：使用的是同步队列 `SynchronousQueue`, 允许创建的线程数量为 `Integer.MAX_VALUE` ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。

- **`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor`** : 使用的无界的延迟阻塞队列`DelayedWorkQueue`，任务队列最大长度为 `Integer.MAX_VALUE`,可能堆积大量的请求，从而导致 OOM。

**Executor 框架介绍**

通过 `Executor` 来启动线程比使用 `Thread` 的 `start` 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题

**this 逃逸**是指在**构造函数返回之前其他线程就持有该对象的引用**，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。

`Executor` 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，`Executor` 框架让并发编程变得更加简单

1. **Executor 接口**
   - 这是最基本的接口，定义了一个方法`execute(Runnable command)`，用于提交执行任务。
   - 它提供了一种将任务提交和任务如何运行（如在哪个线程或线程池中）分离开来的方式。
2. **Executors 类**
   - 提供了工厂方法来创建不同类型的线程池，如`newFixedThreadPool`、`newCachedThreadPool`、`newSingleThreadExecutor`等。
   - 这些工厂方法提供了线程池的常见配置，简化了线程池的创建过程。
3. **ExecutorService 接口**
   - 扩展了`Executor`，添加了一些用于生命周期管理（如关闭线程池）和任务提交（返回`Future`以获取结果和状态）的方法。
   - 常用方法包括`submit`、`invokeAll`、`invokeAny`、`shutdown`和`shutdownNow`。
4. **ScheduledExecutorService 接口**
   - 扩展了`ExecutorService`，增加了对任务的定时执行和周期性执行的支持。
   - 允许使用`schedule`、`scheduleAtFixedRate`和`scheduleWithFixedDelay`等方法安排任务执行。
5. **ThreadPoolExecutor 和 ScheduledThreadPoolExecutor**
   - 这两个类是`ExecutorService`和`ScheduledExecutorService`的具体实现。
   - 提供了丰富的配置选项，如核心线程数、最大线程数、存活时间、工作队列等，使得线程池的行为可以高度定制。



**线程池常见参数有哪些**

```java
    /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }

```

其中最重要的三个参数是：

- **`corePoolSize` :** 任务队列**未达到队列容量**时，**最大可以同时运行的线程数量**。

- **`maximumPoolSize` :** 任务队列中存放的任务**达到队列容量**的时候，当前可以同时运行的线程数量变为**最大线程数**。

- **`workQueue`:** 新任务来的时候会先**判断当前运行的线程数量是否达到核心线程数**，如果达到的话，新任务就会被存放在队列中。

![image-20231226200254398](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226200254398.png)

**当使用线程池执行新任务时**，通常会经历以下流程：

1. 如果线程池**当前的工作线程数小于核心线程数**（通过 `corePoolSize` 参数配置），则会**创建一个新的工作线程来执行任务**。这是因为核心线程会一直保持存活状态，即使没有任务需要执行。

2. 如果线程池**当前的工作线程数已经达到核心线程数**，但**任务队列（通过 `BlockingQueue` 实现）还有空间**可以接受新的任务，那么新任务会**被添加到队列中等待执行**。任务队列的大小可以通过 `workQueue` 参数进行配置。

3. 如果线程池**当前的工作线程数已经达到核心线程数，并且任务队列已经满了**，但**线程池的最大线程数（通过 `maximumPoolSize` 参数配置）还未达到**，那么会**创建一个新的非核心线程来执行任务**。

4. 如果线程池的**最大线程数已经达到，无法再创建新的线程，并且任务队列也已满，则根据所选择的拒绝策略**（通过 `RejectedExecutionHandler` 实现）来处理新任务的提交。常见的拒绝策略有：抛出异常、丢弃任务、丢弃队列中最旧的任务或者在调用者线程中直接执行。

5. 一旦有空闲的工作线程，它将**从任务队列中获取下一个任务进行执行**。这是通过使用任务队列的出队操作来实现的。

6. 当线程执行完任务后，如果线程池中的线程数多于核心线程数，且在指定的时间内没有新的任务到达（通过 `keepAliveTime` 参数配置），那么这些多余的非核心线程将被终止并移出线程池，以减少资源消耗。

![image-20231226203516444](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226203516444.png)

这个流程可以保证线程池高效地处理新任务，并根据负载情况动态地调整工作线程的数量。同时，任务队列的存在可以缓解瞬时的任务突发，避免线程过度增长或因线程频繁创建销毁而引起的性能问题。

**线程池的饱和策略**

如果当前同时运行的**线程数量达到最大线程数量**并且**队列也已经被放满了任务时**

**即当来的任务数量>maximumPoolSize+workQueue时，就会采用饱和策略**

`ThreadPoolTaskExecutor` 定义一些策略

- **`ThreadPoolExecutor.AbortPolicy`：** 抛出 `RejectedExecutionException`来**拒绝新任务的处理**。

- **`ThreadPoolExecutor.CallerRunsPolicy`：** 调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。

- **`ThreadPoolExecutor.DiscardPolicy`：** **不处理新任务，直接丢弃掉**。

- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。

**线程池常用的阻塞队列**

新任务来的时候会先判断**当前运行的线程数量是否达到核心线程数**，**如果达到的话，新任务就会被存放在队列中**

**不同的线程池**会选用**不同的阻塞队列**

- 容量为 `Integer.MAX_VALUE` 的 `LinkedBlockingQueue`（无界队列）：`FixedThreadPool` 和 `SingleThreadExector` 。`FixedThreadPool`最多只能创建核心线程数的线程（核心线程数和最大线程数相等），`SingleThreadExector`只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。

- `SynchronousQueue`（同步队列）：`CachedThreadPool` 。`SynchronousQueue` 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。

- `DelayedWorkQueue`（延迟阻塞队列）：`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor` 。`DelayedWorkQueue` 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。`DelayedWorkQueue` 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程

**ThreadPoolExecutor 示例代码**

首先创建一个 `Runnable` 接口的实现类，用于定义任务

```java
import java.util.Date;

/**
 * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。
 * @author shuang.kou
 */
public class MyRunnable implements Runnable {

    private String command;

    public MyRunnable(String s) {
        this.command = s;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " Start. Time = " + new Date());
        processCommand();
        System.out.println(Thread.currentThread().getName() + " End. Time = " + new Date());
    }

    private void processCommand() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String toString() {
        return this.command;
    }
}

```

`ThreadPoolExecutor` 构造函数自定义参数的方式来创建线程池。

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExecutorDemo {

    private static final int CORE_POOL_SIZE = 5;
    private static final int MAX_POOL_SIZE = 10;
    private static final int QUEUE_CAPACITY = 100;
    private static final Long KEEP_ALIVE_TIME = 1L;
    public static void main(String[] args) {

        //使用阿里巴巴推荐的创建线程池的方式
        //通过ThreadPoolExecutor构造函数自定义参数创建
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                CORE_POOL_SIZE,
                MAX_POOL_SIZE,
                KEEP_ALIVE_TIME,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(QUEUE_CAPACITY),
                new ThreadPoolExecutor.CallerRunsPolicy());

        for (int i = 0; i < 10; i++) {
            //创建WorkerThread对象（WorkerThread类实现了Runnable 接口）
            Runnable worker = new MyRunnable("" + i);
            //执行Runnable
            executor.execute(worker);
        }
        //终止线程池
        executor.shutdown();
        while (!executor.isTerminated()) {
        }
        System.out.println("Finished all threads");
    }
}

```

为了搞懂线程池的原理，我们需要首先分析一下 `execute`方法。 在示例代码中，我们使用 `executor.execute(worker)`来提交一个任务到线程池中去，下面是execute方法源码

```java
   // 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)
   private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

    private static int workerCountOf(int c) {
        return c & CAPACITY;
    }
    //任务队列
    private final BlockingQueue<Runnable> workQueue;

    public void execute(Runnable command) {
        // 如果任务为null，则抛出异常。
        if (command == null)
            throw new NullPointerException();
        // ctl 中保存的线程池当前的一些状态信息
        int c = ctl.get();

        //  下面会涉及到 3 步 操作
        // 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize
        // 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里，表明创建新的线程失败。
        // 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            // 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。
            if (!isRunning(recheck) && remove(command))
                reject(command);
                // 如果当前工作线程数量为0，新创建一个线程并执行。
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        //3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。
        // 传入 false 代表增加线程时判断当前线程数是否少于 maxPoolSize
        //如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。
        else if (!addWorker(command, false))
            reject(command);
    }
```

源码的大致思路是：

1. 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。
2. 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。
3. 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。
4. 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，饱和策略会调用`RejectedExecutionHandler.rejectedExecution()`方法

**runnable和callable的区别**

![image-20231228120658925](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231228120658925.png)

需要从任务中获取结果或者需要处理任务执行过程中抛出的异常，使用`Callable`会更合适

**excute和submit的区别**

在Java的`Executor`框架中，`execute()`和`submit()`是两个用于**启动任务的关键方法**，它们有一些重要的区别：

- **execute(Runnable command)**，定义于`Executor`接口，参数是一个实现了`Runnable`接口的对象，无返回值

- **submit(Callable<T> task) 或 submit(Runnable task)**，定义于`ExecutorService`接口，这是`Executor`接口的子接口，可以接受`Callable`或`Runnable`对象，返回一个`Future<T>`对象，用于获取任务的结果和状态

**shutdown()和shutdownNow()区别**

- **`shutdown（）`** :关闭线程池，线程池的状态变为 `SHUTDOWN`。线程池不再接受新任务了，但是队列里的任务得执行完毕。
- **`shutdownNow（）`** :关闭线程池，线程池的状态变为 `STOP`。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。

**isTerminated()和isShutdown()的区别**

- **`isShutDown`** 当调用 `shutdown()` 方法后返回为 true。
- **`isTerminated`** 当调用 `shutdown()` 方法后，**并且所有提交的任务完成**后返回为 true

**线程池命名**

**1、利用 guava 的 `ThreadFactoryBuilder`**

```java
ThreadFactory threadFactory = new ThreadFactoryBuilder()
                        .setNameFormat(threadNamePrefix + "-%d")
                        .setDaemon(true).build();
ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory);
```

**2、自己实现 `ThreadFactory`**

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;
/**
 * 线程工厂，它设置线程名称，有利于我们定位问题。
 */
public final class NamingThreadFactory implements ThreadFactory {

    private final AtomicInteger threadNum = new AtomicInteger();
    private final ThreadFactory delegate;
    private final String name;

    /**
     * 创建一个带名字的线程池生产工厂
     */
    public NamingThreadFactory(ThreadFactory delegate, String name) {
        this.delegate = delegate;
        this.name = name; // TODO consider uniquifying this
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = delegate.newThread(r);
        t.setName(name + " [#" + threadNum.incrementAndGet() + "]");
        return t;
    }

}
```

**如何设定线程池的大小**

线程池设置的过大，增加了上下文切换的成本，过小又容易导致大量任务堵塞，所以需要合适的大小

1. 有一个简单并且适用面比较广的公式：

   **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以**将线程数设置为 N（CPU 核心数）+1**。比 CPU 核心数**多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响**。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。

   **I/O 密集型任务(2N)：** 这种任务应用起来，**系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用**。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

   ![image-20231226210537437](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226210537437.png)

   **如何判断是 CPU 密集任务还是 IO 密集任务**

   CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。**但凡涉及到网络读取，文件读取这类都是 IO 密集型**，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。

2. **动态修改参数值**       [参考](https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&mid=2247505103&idx=1&sn=a041dbec689cec4f1bbc99220baa7219&source=41#wechat_redirect)

   那在什么时候修改呢，美团考虑的是在运行的时候修改，具体操作如下：

   在运行期，线程池使用方调用setcorePoolSize方法设置**corePoolSize之后**，线程池会**直接覆盖原来的corePoolSize值**，并且**基于当前值和原始值的比较结果采取不同的处理策略。**

   - 对于当前值小于当前工作线程数的情况，说明有多余的worker线程，此时会向当前idle的worker线程发起中断请求以实现回收，多余的worker在下次idel的时候也会被回收
   - 对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的worker线程来执行队列任务

   流程图如下：

   ![image-20231226212306295](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226212306295.png)

   再设置**maximumPoolSize**，按照下面逻辑

   1. 首先是参数合法性校验。
   2. 然后用传递进来的值，覆盖原来的值。
   3. 判断工作线程是否是大于最大线程数，如果大于，则对空闲线程发起中断请求。

   ![image-20231226213028692](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226213028692.png)

   最后就是**workQueue**的设置，**从工作队列的源码可以看出其capcity这个变量被设置为了final，所以是不能修改的，所以考虑自己创建一个工作队列，直接将LinkedBlockingQueue的源码复制一份，然后把capcity的fnal去掉即可**

**如何设计一个能够根据任务的优先级来执行的线程池**

假如我们需要实现**一个优先级任务线程池**的话，那可以考虑使用 **`PriorityBlockingQueue`** （优先级阻塞队列）作为任务队列（`ThreadPoolExecutor` 的构造函数有一个 `workQueue` 参数可以传入任务队列）。

不过要想让 `PriorityBlockingQueue` 实现对任务的排序，传入其中的任务必须是具备排序能力的，方式有两种：

- 提交到线程池的任务实现 `Comparable` 接口，并重写 `compareTo` 方法来指定任务之间的优先级比较规则。

- 创建 `PriorityBlockingQueue` 时传入一个 `Comparator` 对象来指定任务之间的排序规则(推荐)。

不过也存在一些问题

- `PriorityBlockingQueue` 是**无界的，可能堆积大量的请求，从而导致 OOM**。

- 可能会导致**饥饿问题**，即低优先级的任务长时间得不到执行。

- 由于**需要对队列中的元素进行排序操作以及保证线程安全**（并发控制采用的是可重入锁 `ReentrantLock`），因此会**降低性能**。

一些相关的面试题

线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？

![image-20231226213652375](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226213652375.png)

核心线程数会被回收吗？需要什么设置？

![image-20231226213738798](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226213738798.png)

##### Future

是异步思想的典型运用

当我们执行某一耗时的任务时，可以**将这个耗时任务交给一个子线程去异步执行**，同时我们可以干点其他事情，不用傻傻等待耗时任务执行完成。等我们的事情干完后，我们**再通过 `Future` 类获取到耗时任务的执行结果**。这样一来，程序的执行效率就明显提高了

![image-20231226215722200](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231226215722200-20231226215841329.png)

######  Callable 和 Future 有什么关系

Callable：

- `Callable` 是一个具有泛型参数的接口，它类似于 `Runnable`，但是可以返回结果并抛出异常。
- `Callable` 接口定义了一个名为 `call` 的方法，**该方法可以在不同的线程中执行任务，并且可以返回一个结果**，或者在任务执行过程中抛出异常。

`Callable` 和 `Future` 之间的关系在于，**当我们使用线程池执行任务时，可以将任务封装为 `Callable` 对象，然后通过线程池提交执行，并且会返回一个 `Future` 对象来表示任务的执行情况**。

#####  [CompletableFuture类](https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html)

将多个任务进行编排，来执行任务，得到好的效果

Future是异步思想的经典运用，遇到耗时任务是分配一个子线程去做，最后用Future来获取结果即可，Future` 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 `get()` 方法为阻塞调用。

```java
public class CompletableFuture<T> implements Future<T>, CompletionStage<T> {
}
```

`CompletionStage` 接口描述了一个异步计算的阶段。很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，形成异步计算的流水线

###### CompletableFuture 常见操作

常见的创建 `CompletableFuture` 对象的方法如下:

1. 通过 new 关键字。

   获取异步计算的结果也非常简单，直接调用 **`get()` 方法**即可。调用 `get()` 方法的线程会阻塞直到 `CompletableFuture` 完成运算

2. 基于 `CompletableFuture` 自带的静态工厂方法：`runAsync()`、`supplyAsync()` 

   需要异步操作且不关心返回结果的时候可以使用 `runAsync()` 方法,异步操作且关心返回结果的时候,可以使用 `supplyAsync()` 方法

**处理异步结果**

- `thenApply()`
- `thenAccept()`
- `thenRun()`
- `whenComplete()`

**如果你不需要从回调函数中获取返回结果，可以使用 `thenAccept()` 或者 `thenRun()`。这两个方法的区别在于 `thenRun()` 不能访问异步计算的结果**

**异常处理**

可以通过 `handle()` 方法来处理任务执行过程中可能出现的抛出异常的情况

```java
CompletableFuture<String> future
        = CompletableFuture.supplyAsync(() -> {
    if (true) {
        throw new RuntimeException("Computation error!");
    }
    return "hello!";
}).handle((res, ex) -> {
    // res 代表返回的结果
    // ex 的类型为 Throwable ，代表抛出的异常
    return res != null ? res : "world!";
});
assertEquals("world!", future.get());

```

**组合CompletableFuture**

你可以使用 `thenCompose()` 按顺序链接两个 `CompletableFuture` 对象，实现异步的任务链。它的作用是将前一个任务的返回结果作为下一个任务的输入参数，从而形成一个依赖关系

```java
CompletableFuture<String> future
        = CompletableFuture.supplyAsync(() -> "hello!")
        .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + "world!"));
assertEquals("hello!world!", future.get());

```

**那 `thenCompose()` 和 `thenCombine()` 有什么区别呢？**

- `thenCompose()` 可以链接两个 `CompletableFuture` 对象，并将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。
- `thenCombine()` 会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序

**并行运行多个 CompletableFuture**

你可以通过 `CompletableFuture` 的 `allOf()`这个静态方法来并行运行多个 `CompletableFuture` 

比说我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。像这种情况我们就可以使用并行运行多个 `CompletableFuture` 来处理

```java
CompletableFuture<Void> task1 =
  CompletableFuture.supplyAsync(()->{
    //自定义业务操作
  });
......
CompletableFuture<Void> task6 =
  CompletableFuture.supplyAsync(()->{
    //自定义业务操作
  });
......
 CompletableFuture<Void> headerFuture=CompletableFuture.allOf(task1,.....,task6);

  try {
    //调用 join() 可以让程序等future1 和 future2 都运行完了之后再继续执行。
    headerFuture.join();
  } catch (Exception ex) {
    ......
  }
System.out.println("all done. ");

```

一般建议配置自定义线程池使用

```java
private ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 10,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>());

CompletableFuture.runAsync(() -> {
 		//...
}, executor);

```



#####  AQS

AQS 的全称为 `AbstractQueuedSynchronizer` ，翻译过来的意思就是抽象队列同步器

AQS 就是一个**抽象类**，主要用来**构建锁和同步器**

AQS 核心思想是，如果被请求的**共享资源空闲**，则将当前请求资源的线程设置为**有效的工作线程**，并且**将共享资源设置为锁定状态**。如果被请求的**共享资源被占用**，那么就需要**一套线程阻塞等待以及被唤醒时锁分配的机制**，这个机制 AQS 是用 **CLH 队列锁** 实现的，即将暂时获取不到锁的线程加入到队列中。

**CLH队列锁**：虚拟的双向队列（虚拟的双向队列即**不存在队列实例，仅存在结点之间的关联关系**）

![image-20231228154357620](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231228154357620.png)

AQS 是将**每条请求共享资源的线程**封装成一个 CLH 锁队列的**一个结点**（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）

![image-20231227174527500](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231227174527500.png)

AQS利用一个int变量**state**来表示资源的状态，通过内置的 **线程等待队列** 来完成获取资源线程的排队工作

**state用volatile修饰，保证其可见性**

```java
// 共享变量，使用volatile修饰保证线程可见性
private volatile int state;
```

state通过下面几个方法进行操作，并且，这几个方法都是 `final` 修饰的，在子类中无法被重写

```java
//返回同步状态的当前值
protected final int getState() {
     return state;
}
 // 设置同步状态的值
protected final void setState(int newState) {
     state = newState;
}
//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）
protected final boolean compareAndSetState(int expect, int update) {
      return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```

以 `ReentrantLock` 为例，`state` 初始值为 0，表示未锁定状态。**A 线程 `lock()` 时，会调用 `tryAcquire()` 独占该锁并将 `state+1`** 。此后，其他线程再 `tryAcquire()` 时就会失败，**直到 A 线程 `unlock()` 到 `state=`0（即释放锁）为止**，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（`state` 会累加），这就是可重入的概念。但要注意，**获取多少次就要释放多少次，这样才能保证 state 是能回到零态的**

AQS支持自定义实现同步器，**AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：**

```java
//独占方式。尝试获取资源，成功则返回true，失败则返回false。
protected boolean tryAcquire(int)
//独占方式。尝试释放资源，成功则返回true，失败则返回false。
protected boolean tryRelease(int)
//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
protected int tryAcquireShared(int)
//共享方式。尝试释放资源，成功则返回true，失败则返回false。
protected boolean tryReleaseShared(int)
//该线程是否正在独占资源。只有用到condition才需要去实现它。
protected boolean isHeldExclusively()

```

**常见的同步工具**

###### **Semaphore(信号量)**

**`synchronized` 和 `ReentrantLock` 都是一次只允许一个线程访问某个资源**，而`Semaphore`(信号量)可以用来**控制同时访问特定资源的线程数量**

**Semaphore 有什么用**

`Semaphore`(信号量)可以用来**控制同时访问特定资源的线程数量**。

```java
// 初始共享资源数量
final Semaphore semaphore = new Semaphore(5);
// 获取1个许可
semaphore.acquire();
// 释放1个许可
semaphore.release();

```

`Semaphore` 有两种模式：。

- **公平模式：** 调用 `acquire()` 方法的顺序就是获取许可证的顺序，遵循 FIFO；
- **非公平模式：** 抢占式的。

**这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式**

**Semaphore 的原理是什么**

`Semaphore` 是共享锁的一种实现，它默认构造 **AQS 的 `state` 值为 `permits`**，你可以将 `permits` 的值理解为许可证的数量，只有拿到许可证的线程才能执行。

获取资源

调用`semaphore.acquire()` ，线程尝试获取许可证，**如果 `state >= 0` 的话，则表示可以获取成功**。如果获取成功的话，**使用 CAS 操作去修改 `state` 的值 `state=state-1`**。**如果 `state<0` 的话，则表示许可证数量不足**。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。

释放资源

调用`semaphore.release();` ，线程尝试释放许可证，**并使用 CAS 操作去修改 `state` 的值 `state=state+1`**。释放许可证成功之后，同时会**唤醒同步队列中的一个线程**。**被唤醒的线程会重新尝试去修改 `state` 的值 `state=state-1`** ，如果 `state>=0` 则获取令牌成功，否则重新进入阻塞队列，挂起线程。

下面就是信号量的运用semaphore.acquire()，获取一个许可。如果信号量的许可数不足（即已有20个线程在运行），这个调用会阻塞，直到某个线程释放一个许可。`test(threadnum)`调用模拟一个耗时操作。完成操作后，调用`semaphore.release()`释放许可，允许其他等待的线程进入。

- 代码中的信号量初始有20个许可，这意味着最多有20个线程可以同时进入`test(threadnum)`方法进行处理。
- 这个机制确保了即使有550个任务被提交到拥有300个线程的线程池中，也只有20个任务会同时执行。

```java
public class SemaphoreExample {
  // 请求的数量
  private static final int threadCount = 550;

  public static void main(String[] args) throws InterruptedException {
    // 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）
    ExecutorService threadPool = Executors.newFixedThreadPool(300);
    // 初始许可证数量
    final Semaphore semaphore = new Semaphore(20);

    for (int i = 0; i < threadCount; i++) {
      final int threadnum = i;
      threadPool.execute(() -> {// Lambda 表达式的运用
        try {
          semaphore.acquire();// 获取一个许可，所以可运行线程数量为20/1=20
          test(threadnum);
          semaphore.release();// 释放一个许可
        } catch (InterruptedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
        }

      });
    }
    threadPool.shutdown();
    System.out.println("finish");
  }

  public static void test(int threadnum) throws InterruptedException {
    Thread.sleep(1000);// 模拟请求的耗时操作
    System.out.println("threadnum:" + threadnum);
    Thread.sleep(1000);// 模拟请求的耗时操作
  }
}

```

###### **CountDownLatch 有什么用**

`CountDownLatch` 允许 `count` 个线程阻塞在一个地方，直至所有线程的任务都执行完毕，就是所有线程任务都完成了，才都唤醒执行后面的任务

CountDownLatch 内部维护了一个**计数器**，该计数器初始化为一个正整数，**表示需要等待的线程数目**。**每当一个线程完成自己的任务后，计数器就会减一，直到计数器的值减至零，所有等待的线程将被唤醒**

其原理也是默认构造 AQS 的 `state` 值为 `count`，使用了`tryReleaseShared`方法以 CAS 的操作来减少 `state`,直至 `state` 为 0 。

**运用场景**

允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。

比如说要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理

为此我们定义了一个线程池和 count 为 6 的`CountDownLatch`对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用`CountDownLatch`对象的 `await()`方法，直到所有文件读取完之后，才会接着执行后面的逻辑。

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class FileProcessorWithThreadPool {
    public static void main(String[] args) throws InterruptedException {
        int numberOfFiles = 6; // 处理的文件数量
        CountDownLatch latch = new CountDownLatch(numberOfFiles);

        // 线程池配置
        int corePoolSize = 5; // 核心线程数
        int maximumPoolSize = 10; // 最大线程数
        long keepAliveTime = 5000; // 空闲线程的存活时间（毫秒）
        int queueCapacity = 100; // 工作队列的容量

        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            corePoolSize,
            maximumPoolSize,
            keepAliveTime,
            TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue<>(queueCapacity),
            new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
        );

        for (int i = 0; i < numberOfFiles; i++) {
            int fileIndex = i;
            executor.submit(() -> {
                try {
                    // 在这里处理文件读取和相关逻辑
                    System.out.println("Processing file " + fileIndex);
                    // 模拟文件处理时间
                    Thread.sleep(1000); // 假设每个文件处理需要1秒
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    // 处理完毕后，减少latch计数
                    latch.countDown();
                }
            });
        }

        // 等待直到所有文件都被处理
        latch.await();
        System.out.println("All files have been processed. Continue with the remaining logic.");

        // 关闭线程池
        executor.shutdown();
    }
}
```

###### **CyclicBarrier 有什么用**

`CyclicBarrier` 和 `CountDownLatch` 非常类似，它也可以实现线程间的技术等待，但是它的功能比 `CountDownLatch` 更加复杂和强大。主要应用场景和 `CountDownLatch` 类似。

> `CountDownLatch` 的实现是基于 AQS 的，而 `CycliBarrier` 是基于 `ReentrantLock`(`ReentrantLock` 也属于 AQS 同步器)和 `Condition` 的。

`CyclicBarrier` 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。

**特点**

1. **可重用**：与`CountDownLatch`不同，`CyclicBarrier`是可重用的。一旦所有等待线程都到达屏障点，它就可以重置并再次使用。
2. **屏障操作**：你可以提供一个屏障操作，这是一个在所有线程到达屏障后执行的Runnable任务。这可以用于更新共享状态或合并结果。
3. **灵活性**：线程可以随时告知`CyclicBarrier`它们已经到达了屏障点。这意味着线程不需要同时启动，它们可以在准备好后到达屏障点。
4. **异常处理**：如果一个线程在到达屏障前被中断或超时，`CyclicBarrier`会进入损坏状态，这将导致所有等待的线程接收到`BrokenBarrierException`。这允许线程处理异常情况并且可以选择重新尝试或做其他处理。

**基本原理**

1. **初始化屏障点**：当创建一个 `CyclicBarrier` 实例时，你需要指定一个整数 `N`，它表示需要到达屏障点的线程数量。你还可以（可选地）提供一个 `Runnable` 任务，当所有线程都到达屏障时，这个任务会被执行。
2. **等待屏障**：线程通过调用 `CyclicBarrier` 的 `await()` 方法来告知它们已经到达屏障点。调用 `await()` 方法的线程将会被阻塞，直到所有线程都达到了屏障。
3. **屏障操作执行**：当最后一个线程到达屏障点时，如果提供了屏障操作（Runnable任务），它将首先被执行。这通常用于在所有线程继续之前执行一些集体的更新操作。
4. **释放等待的线程**：屏障操作完成后，所有等待在 `CyclicBarrier` 上的线程都将被释放，可以继续它们各自的执行。
5. **重用**：一旦所有线程都被释放，`CyclicBarrier` 就被重置，可以再次使用。这意味着它可以在多阶段的计算过程中反复使用。

##### JMM

JMM(Java 内存模型)主要**定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性**

**CPU缓存模型**

**CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。**

可以把 **内存看作外存的高速缓存**，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度

**CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题**

**CPU Cache 的工作方式：** 先**复制一份数据到 CPU Cache 中**，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再**将运算得到的数据写回 Main Memory 中**。但是，这样存在 **内存缓存不一致性的问题** ！比如我执行一个 i++ 操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 i++ 运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。

为此**CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 [MESI 协议open in new window](https://zh.wikipedia.org/wiki/MESI协议)）或者其他手段来解决。**

我们的程序运行在操作系统之上，操作系统屏蔽了底层硬件的操作细节，将各种硬件资源虚拟化。于是，**操作系统也就同样需要解决内存缓存不一致性问题**，因此操作系统通过 **内存模型（Memory Model）** 定义一系列规范来解决这个问题。无论是 Windows 系统，还是 Linux 系统，它们都有特定的内存模型

**指令重排序**

为了提升执行速度/性能，系统在执行代码的时候并不一定是按照你写的代码的顺序依次执行

一般有下面两种情况：

- **编译器优化重排**：编译器（包括 JVM、JIT 编译器等）在不改变单线程程序语义的前提下，重新安排语句的执行顺序。
- **指令并行重排**：现代处理器采用了指令级并行技术(Instruction-Level Parallelism，ILP)来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序

Java 源代码会经历 **编译器优化重排 —> 指令并行重排 —> 内存系统重排** 的过程，最终才变成操作系统可执行的指令序列

在多线程的情况下，指令重排序可能会导致一些问题

**编译器和处理器的指令重排序的处理方式不一样**。对于编译器，通过禁止特定类型的编译器重排序的方式来禁止重排序。对于处理器，通过插入内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）的方式来禁止特定类型的处理器重排序。指令并行重排和内存系统重排都属于是处理器级别的指令重排序

**JMM**

**需要JMM的原因**

- 对于一般的编程语言而言，其实是可以直接复用操作系统层面的内存模型，不过不同的操作系统其内存模型是不一样的，java语言是跨平台的，所以需要自己提供一套内存模型以屏蔽系统差异
- JMM 可以看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范

**JMM如何抽象线程和主内存之间的关系**

比如说**线程之间的共享变量**必须存储在**主内存中**

- **主内存**：**所有线程创建的实例对象都存放在主内存**中，不管该实例对象是成员变量，还是局部变量，类信息、常量、静态变量都是放在主内存中。为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。
- **本地内存**：**每个线程都有一个私有的本地内存**，**本地内存存储了该线程以读 / 写共享变量的副本**。每个线程只能操作自己本地内存中的变量，无法直接访问其他线程的本地内存。**如果线程间需要通信，必须通过主内存来进行**。本地内存是 JMM 抽象出来的一个概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。**每个线程都有自己的工作内存，它是主内存的私有拷贝。线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，然后再同步回主内存**。

主内存和本地内存相互交互通过以下8个同步操作进行

![image-20231228105308335](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231228105308335.png)

除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行

![image-20231228105404264](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231228105404264.png)

java内存区域和内存模型是两个概念

- JVM 内存区域和 Java 虚拟机的运行时区域相关，**定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例**
- Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的

**happens-before 原则是什么**

**Happens-Before规则**：这是JMM中最核心的部分，它为程序员提供了判断数据是否安全发布（Safe Publication）、线程间的操作是否可以无需同步等问题的指导。如果一个操作A happens-before操作B，那么操作A的结果对操作B是可见的

核心思想：

- 为了对编译器和处理器的约束尽可能少，**只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。**

- 对于**会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序**

![image-20231228110140300](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231228110140300.png)

具体规则：

- 如果**一个操作 happens-before 另一个操作**，那么**第一个操作的执行结果将对第二个操作可见**，并且**第一个操作的执行顺序排在第二个操作之前**。
- 两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。**如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序**。

**JMM常用规则**

1. **程序顺序规则**：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；
2. **解锁规则**：解锁 happens-before 于加锁；
3. **volatile 变量规则**：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。
4. **传递规则**：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；
5. **线程启动规则**：Thread 对象的 `start()`方法 happens-before 于此线程的每一个动作。

![image-20231228111043481](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231228111043481.png)

**并发编程三个重要特性**

- 原子性

  一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行，可以借助`synchronized`、各种 `Lock` 以及各种原子类实现原子性

- 可见性

  当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值，可以借助`synchronized`、`volatile` 以及各种 `Lock` 实现可见性

- 有序性

  由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序，`volatile` 关键字可以禁止指令进行重排序优化

##### Java 常见并发容器

- **`ConcurrentHashMap`** : 线程安全的 `HashMap`

  `HashMap` 不是线程安全的，所以就有了 `HashMap` 的线程安全版本—— `ConcurrentHashMap` 的诞生

- **`CopyOnWriteArrayList`** : 线程安全的 `List`，在读多写少的场合性能非常好，远远好于 `Vector`。

  以前想要并发的List就只有vector，但vector太旧了，已经被舍弃了并且对于增删改查等方法基本都加了 `synchronized`，所以性能十分低下，`CopyOnWriteArrayList` 中的**读取操作是完全无需加锁的。更加厉害的是，写入操作也不会阻塞读取操作，只有写写才会互斥**。这样一来，读操作的性能就可以大幅度提升

  当需要修改（ `add`，`set`、`remove` 等操作） `CopyOnWriteArrayList` 的内容时，**不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去**，这样就可以保证写操作不会影响读操作了

- **`ConcurrentLinkedQueue`** : 高效的并发队列，使用链表实现。可以看做一个线程安全的 `LinkedList`，这是一个非阻塞队列。

  Java 提供的线程安全的 `Queue` 可以分为**阻塞队列**和**非阻塞队列**，其中阻塞队列的典型例子是 `BlockingQueue`，非阻塞队列的典型例子是 `ConcurrentLinkedQueue`

  **阻塞队列可以通过加锁来实现，非阻塞队列可以通过 CAS 操作实现**

  对性能要求相对较高，同时对队列的读写存在多个线程同时进行的场景，即如果对队列加锁的成本较高则适合使用无锁的 `ConcurrentLinkedQueue` 来替代

- **`BlockingQueue`** : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。

  阻塞队列（`BlockingQueue`）被广泛使用在“生产者-消费者”问题中，其原因是 `BlockingQueue` 提供了可阻塞的插入和移除的方法。当队列容器**已满**，**生产者线程会被阻塞**，直到队列未满；当队列容器**为空**时，**消费者线程会被阻塞**，直至队列非空时为止

  `BlockingQueue` 是一个接口，下面主要介绍一下 3 个常见的 `BlockingQueue` 的实现类：`ArrayBlockingQueue`、`LinkedBlockingQueue`、`PriorityBlockingQueue` 

  - **ArrayBlockingQueue**

    `ArrayBlockingQueue` 是 `BlockingQueue` 接口的有界队列实现类，底层采用**数组**来实现

    一旦创建，**容量不能改变**。其**并发控制采用可重入锁 `ReentrantLock`** ，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞

    默认情况下不能保证线程访问队列的公平性

  - **LinkedBlockingQueue**

    `LinkedBlockingQueue` 底层基于**单向链表**实现的阻塞队列，**可以当做无界队列也可以当做有界队列来使用**

    为了防止 `LinkedBlockingQueue` 容量迅速增，损耗大量内存。通常在创建 `LinkedBlockingQueue` 对象时，会指定其大小，如果未指定，容量等于 `Integer.MAX_VALUE` 。

  - **PriorityBlockingQueue**

    支持优先级的无界阻塞队列，采用的是可重入锁 `ReentrantLock`，队列为无界队列，不可以插入 null 值，插入队列的对象必须是可比较大小的

- **`ConcurrentSkipListMap`** : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找

  跳表：跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找，但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。**而对于跳表，你只需要部分锁即可**。这样，**在高并发环境下，你就可以拥有更好的性能**。而就查询的性能而言，跳表的时间复杂度也是 **O(logn)** 所以在并发数据结构中，JDK 使用跳表来实现一个 Map。

  其本质就是维护多个链表

  ![image-20231228151913821](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231228151913821.png)

##### 原子类总结

###### **基本类型原子类**

- `AtomicInteger`：整型原子类
- `AtomicLong`：长整型原子类
- `AtomicBoolean`：布尔型原子类

```java
public final int get() //获取当前的值
public final int getAndSet(int newValue)//获取当前的值，并设置新的值
public final int getAndIncrement()//获取当前的值，并自增
public final int getAndDecrement() //获取当前的值，并自减
public final int getAndAdd(int delta) //获取当前的值，并加上预期的值
boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。

```

使用基本类型原子类的好处

- **多线程环境不使用原子类保证线程安全（基本数据类型）**

```java
class Test {
        private volatile int count = 0;
        //若要线程安全执行执行count++，需要加锁
        public synchronized void increment() {
                  count++;
        }

        public int getCount() {
                  return count;
        }
}

```

- **多线程环境使用原子类保证线程安全（基本数据类型）**

```java
class Test2 {
        private AtomicInteger count = new AtomicInteger();

        public void increment() {
                  count.incrementAndGet();
        }
      //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。
       public int getCount() {
                return count.get();
        }
}


```

`AtomicInteger` 类主要利用 **CAS (compare and swap) + volatile 和 native 方法来保证原子操作**，从而避免 synchronized 的高开销，执行效率大为提升。

###### **数组类型原子类**

- `AtomicIntegerArray`：整形数组原子类
- `AtomicLongArray`：长整形数组原子类
- `AtomicReferenceArray`：引用类型数组原子类

```java
public final int get(int i) //获取 index=i 位置元素的值
public final int getAndSet(int i, int newValue)//返回 index=i 位置的当前的值，并将其设置为新值：newValue
public final int getAndIncrement(int i)//获取 index=i 位置元素的值，并让该位置的元素自增
public final int getAndDecrement(int i) //获取 index=i 位置元素的值，并让该位置的元素自减
public final int getAndAdd(int i, int delta) //获取 index=i 位置元素的值，并加上预期的值
boolean compareAndSet(int i, int expect, int update) //如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）
public final void lazySet(int i, int newValue)//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。
```

使用事例：

```java
import java.util.concurrent.atomic.AtomicIntegerArray;

public class AtomicIntegerArrayTest {

    public static void main(String[] args) {
        int temvalue = 0;
        int[] nums = { 1, 2, 3, 4, 5, 6 };
        AtomicIntegerArray i = new AtomicIntegerArray(nums);
        for (int j = 0; j < nums.length; j++) {
            System.out.println(i.get(j));
        }
        temvalue = i.getAndSet(0, 2);
        System.out.println("temvalue:" + temvalue + ";  i:" + i);
        temvalue = i.getAndIncrement(0);
        System.out.println("temvalue:" + temvalue + ";  i:" + i);
        temvalue = i.getAndAdd(0, 5);
        System.out.println("temvalue:" + temvalue + ";  i:" + i);
    }

}
```

###### 引用类型原子类

基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类

- `AtomicReference`：引用类型原子类

- `AtomicStampedReference`：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

- `AtomicMarkableReference`：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来

**`AtomicReference` 类使用示例**

```java
import java.util.concurrent.atomic.AtomicReference;

public class AtomicReferenceTest {

    public static void main(String[] args) {
        AtomicReference < Person > ar = new AtomicReference < Person > ();
        Person person = new Person("SnailClimb", 22);
        ar.set(person);
        Person updatePerson = new Person("Daisy", 20);
        ar.compareAndSet(person, updatePerson);

        System.out.println(ar.get().getName());
        System.out.println(ar.get().getAge());
    }
}

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

}
```

###### 对象的属性修改类型原子类

如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类

- `AtomicIntegerFieldUpdater`:原子更新整形字段的更新器

- `AtomicLongFieldUpdater`：原子更新长整形字段的更新器

- `AtomicReferenceFieldUpdater`：原子更新引用类型里的字段的更新器

操作规则

1. 每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性
2. 更新的对象属性必须使用 public volatile 修饰符

样例：

```java
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

public class AtomicIntegerFieldUpdaterTest {
	public static void main(String[] args) {
		AtomicIntegerFieldUpdater<User> a = AtomicIntegerFieldUpdater.newUpdater(User.class, "age");

		User user = new User("Java", 22);
		System.out.println(a.getAndIncrement(user));// 22
		System.out.println(a.get(user));// 23
	}
}

class User {
	private String name;
	public volatile int age;

	public User(String name, int age) {
		super();
		this.name = name;
		this.age = age;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

}
```

##### 虚拟线程

虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，**虚拟线程的数量可以远大于操作系统线程的数量**

![image-20231228221250479](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231228221250479.png)

#### JVM



#### Spring

###### Spring,Spring MVC,Spring Boot 之间什么关系

Spring MVC 是 Spring 中的一个很重要的模块，主要**赋予 Spring 快速构建 MVC 架构的 Web 程序的能力**。

MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码

使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置，因此springboot由此诞生

######  Spring IoC

IoC是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。

**什么叫控制反转**

- **控制**：指的是对象创建（实例化、管理）的权力
- **反转**：控制权交给外部环境（Spring 框架、IoC 容器）

将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入，把应用从复杂的依赖关系中解放出来，解耦

在 Spring 中， **IoC 容器是 Spring 用来实现 IoC 的载体**， IoC 容器实际上就是个 **Map（key，value）**，Map 中存放的是各种对象

###### Spring Bean

Bean 代指的就是那些被 **IoC 容器所管理的对象**

告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类

```java
<!-- Constructor-arg with 'value' attribute -->
<bean id="..." class="...">
   <constructor-arg value="..."/>
</bean>

```

将一个类声明成Bean的注解有

- `@Component`：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。
- `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。
- `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- `@Controller` : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 `Service` 层返回数据给前端页面。

###### @Component 和 @Bean 的区别是什么

**`@Component` 注解作用于类，而`@Bean`注解作用于方法**。

`@Component`通常是通过**类路径扫描来自动侦测以及自动装配到 Spring 容器中**（我们可以使用 `@ComponentScan` 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。

`@Bean` 注解通常是我们在**标有该注解的方法中定义产生这个 bean**,`@Bean`告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。

`@Bean` 注解比 `@Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册 bean。

比如当我们引用第三方库中的类需要装配到 `Spring`容器时（但这个类不在你的控制之下，即你无法在它的类定义上添加`@Component`或其他类似的注解），则只能通过 `@Bean`来实现。

一般是首先创建一个配置类

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import com.thirdparty.ThirdPartyClass;  // 假设这是第三方库中的类

@Configuration
public class AppConfig {

    @Bean
    public ThirdPartyClass thirdPartyClass() {
        // 创建ThirdPartyClass的实例
        ThirdPartyClass thirdPartyClass = new ThirdPartyClass();
        // 配置实例（如果需要）
        // thirdPartyClass.setSomeProperty(value);
        return thirdPartyClass;
    }
}
```

在Spring应用程序的其他部分通过依赖注入使用这个bean

```java
import org.springframework.beans.factory.annotation.Autowired;
import com.thirdparty.ThirdPartyClass;

public class SomeService {
    private final ThirdPartyClass thirdPartyClass;

    @Autowired
    public SomeService(ThirdPartyClass thirdPartyClass) {
        this.thirdPartyClass = thirdPartyClass;
    }

    // 使用thirdPartyClass实例的方法...
}
```

**Spring 内置的 `@Autowired` 以及 JDK 内置的 `@Resource` 和 `@Inject` 都可以用于注入 Bean。**

###### @Autowired 和 @Resource 的区别是什么

`Autowired` 属于 Spring 内置的注解，默认的注入方式为**byType**（根据类型进行匹配），也就是说**会优先根据接口类型去匹配并注入 Bean**，这种方式存在的问题是如果一个接口存在多个实现类的话，这个时候就不知道注入哪个类了，就需要通过 `@Qualifier` 注解来显式指定名称而不是依赖变量的名称

```java
// 报错，byName 和 byType 都无法匹配到 bean
@Autowired
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Autowired
private SmsService smsServiceImpl1;
// 正确注入  SmsServiceImpl1 对象对应的 bean
// smsServiceImpl1 就是我们上面所说的名称
@Autowired
@Qualifier(value = "smsServiceImpl1")
private SmsService smsService;
```

@Resource属于 JDK 提供的注解，默认注入方式为 **byName**。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType

如果仅指定 `name` 属性则注入方式为`byName`，如果仅指定`type`属性则注入方式为`byType`，如果同时指定`name` 和`type`属性（不建议这么做）则注入方式为`byType`+`byName`

```java
// 报错，byName 和 byType 都无法匹配到 bean
@Resource
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Resource
private SmsService smsServiceImpl1;
// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）
@Resource(name = "smsServiceImpl1")
private SmsService smsService;
```

总结：

- `@Autowired` 是 Spring 提供的注解，`@Resource` 是 JDK 提供的注解。

- `Autowired` 默认的注入方式为`byType`（根据类型进行匹配），`@Resource`默认注入方式为 `byName`（根据名称进行匹配）。

- 当一个接口存在多个实现类的情况下，`@Autowired` 和`@Resource`都需要通过名称才能正确匹配到对应的 Bean。`Autowired` 可以通过 `@Qualifier` 注解来显式指定名称，`@Resource`可以通过 `name` 属性来显式指定名称。

- `@Autowired` 支持在构造函数、方法、字段和参数上使用。`@Resource` 主要用于字段和方法上的注入，不支持在构造函数或参数上使用

###### Bean 的作用域有哪些

- **singleton** : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。

- **prototype** : 每次获取都会创建一个新的 bean 实例。也就是说，连续 `getBean()` 两次，得到的是不同的 Bean 实例。

- **request** （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。

- **session** （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。

- **application/global-session** （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。

- **websocket** （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。

```java
@Bean
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Person personPrototype() {
    return new Person();
}
```

###### Bean 是线程安全的吗

Spring 框架中的 Bean 是否线程安全，取决于其**作用域和状态**

prototype 作用域下，**每次获取都会创建一个新的 bean 实例，不存在资源竞争问题**，所以不存在线程安全问题。

singleton 作用域下，**IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题**（取决于 Bean 是否有状态）。如果这个 bean 是**有状态**的话，那就存在**线程安全问题**（**有状态 Bean 是指包含可变的成员变量的对象**）

对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：

1. 在 Bean 中尽量避免定义可变的成员变量。
2. 在类中定义一个 `ThreadLocal` 成员变量，将需要的可变成员变量保存在 `ThreadLocal` 中（推荐的一种方式）

###### Bean 的生命周期

1. **实例化Bean**:
   - Spring容器首先找到配置文件中的Spring Bean定义。
   - 使用Java反射API创建Bean的实例。
2. **设置Bean属性**:
   - 如果Bean定义中有属性需要注入，则使用setter方法设置这些属性值。
3. **Aware接口方法调用**:
   - 如果Bean实现了`BeanNameAware`接口，Spring调用`setBeanName()`方法，传入Bean的名字。
   - 如果实现了`BeanClassLoaderAware`接口，调用`setBeanClassLoader()`方法，传入ClassLoader对象的实例。
   - 如果实现了`BeanFactoryAware`接口，调用`setBeanFactory()`方法，传入BeanFactory对象的实例。
   - 类似地，如果实现了其他`*.Aware`接口，Spring调用相应的方法。
4. **BeanPostProcessor的前置处理**:
   - 如果存在与Bean相关的`BeanPostProcessor`对象，执行`postProcessBeforeInitialization()`方法。
5. **初始化**:
   - 如果Bean实现了`InitializingBean`接口，执行`afterPropertiesSet()`方法。
   - 如果Bean的定义中包含`init-method`属性，执行指定的方法。
6. **BeanPostProcessor的后置处理**:
   - 执行`postProcessAfterInitialization()`方法。
7. **使用Bean**:
   - 此时，Bean已完全构建并准备好使用。
8. **销毁Bean**:
   - 当容器关闭时，如果Bean实现了`DisposableBean`接口，执行`destroy()`方法。
   - 如果Bean的定义中包含`destroy-method`属性，执行指定的方法。

![image-20231231112816881](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231231112816881.png)

###### Spring AoP

能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性

Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理

考虑以下两个类，一个实现了接口，另一个没有：

```java
public interface MyService {
    void performAction();
}

public class MyServiceImpl implements MyService {
    public void performAction() {
        System.out.println("Performing action in MyServiceImpl");
    }
}

public class MyComponent {
    public void performAction() {
        System.out.println("Performing action in MyComponent");
    }
}

```

在这个例子中，`MyServiceImpl`实现了`MyService`接口，而`MyComponent`没有实现任何接口。

当你使用Spring AOP来为这些类创建代理时，处理将如下：

- 对于`MyServiceImpl`（实现了接口的类），Spring将使用JDK动态代理。
- 对于`MyComponent`（没有实现接口的类），Spring将使用Cglib代理。

配置spring aop

```java
@Aspect
@Component
public class MyAspect {

    @Before("execution(* com.yourpackage..*.*(..))")
    public void beforeAdvice(JoinPoint joinPoint) {
        System.out.println("Before method: " + joinPoint.getSignature().getName());
    }
}
```

![image-20231231161216739](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231231161216739.png)

###### Spring AOP 和 AspectJ AOP 有什么区别

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation),如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多

###### AspectJ 定义的通知类型有哪些

- **Before**（前置通知）：目标对象的方法调用之前触发
- **After** （后置通知）：目标对象的方法调用之后触发
- **AfterReturning**（返回通知）：目标对象的方法调用完成，在返回结果值之后触发
- **AfterThrowing**（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。
- **Around** （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法

###### AspectJ 定义的通知类型有哪些

- **Before**（前置通知）：目标对象的方法调用之前触发
- **After** （后置通知）：目标对象的方法调用之后触发
- **AfterReturning**（返回通知）：目标对象的方法调用完成，在返回结果值之后触发
- **AfterThrowing**（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。
- **Around** （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法

###### 多个切面的执行顺序如何控制

- 通常使用`@Order` 注解直接定义切面顺序

  ```java
  // 值越小优先级越高
  @Order(3)
  @Component
  @Aspect
  public class LoggingAspect implements Ordered {
  
  ```

- **实现`Ordered` 接口重写 `getOrder` 方法**

  ```java
  @Component
  @Aspect
  public class LoggingAspect implements Ordered {
  
      // ....
  
      @Override
      public int getOrder() {
          // 返回值越小优先级越高
          return 1;
      }
  }
  ```

###### Spring MVC

MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码

MVC是一种设计模式，springMVC是一种MVC框架，帮助更简洁的开发，通常后端可以分为Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)

其核心组件有：

- **`DispatcherServlet`**：**核心的中央处理器**，负责接收请求、分发，并给予客户端响应。
- **`HandlerMapping`**：**处理器映射器**，根据 URL 去匹配查找能处理的 `Handler` ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
- **`HandlerAdapter`**：**处理器适配器**，根据 `HandlerMapping` 找到的 `Handler` ，适配执行对应的 `Handler`；
- **`Handler`**：**请求处理器**，处理实际请求的处理器。
- **`ViewResolver`**：**视图解析器**，根据 `Handler` 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 `DispatcherServlet` 响应客户端

![image-20231231164746243](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231231164746243.png)

**流程说明（重要）：**

1. 客户端（浏览器）发送请求， `DispatcherServlet`拦截请求。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping` 。`HandlerMapping` 根据 URL 去匹配查找能处理的 `Handler`（也就是我们平常说的 `Controller` 控制器） ，并会**将请求涉及到的拦截器和 `Handler` 一起封装**。
3. `DispatcherServlet` 调用 `HandlerAdapter`适配器执行 `Handler` 。
4. `Handler` 完成对用户请求的处理后，会返回一个 **`ModelAndView` 对象给`DispatcherServlet`**，`ModelAndView` 顾名思义，包含了数据模型以及相应的视图的信息。`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
5. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
6. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
7. 把 `View` 返回给请求者（浏览器）

###### 统一异常处理怎么做

使用注解的方式统一异常处理，具体会使用到 **`@ControllerAdvice` + `@ExceptionHandler`** 这两个注解 

```java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(BaseException.class)
    public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) {
      //......
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
      //......
    }
}
```

这种异常处理方式下，会给所有或者指定的 `Controller` 织入异常处理的逻辑（AOP），当 `Controller` 中的方法抛出异常的时候，由被`@ExceptionHandler` 注解修饰的方法进行处理。

`ExceptionHandlerMethodResolver` 中 `getMappedMethod` 方法决定了异常具体被哪个被 `@ExceptionHandler` 注解修饰的方法处理异常。

```java
@Nullable
	private Method getMappedMethod(Class<? extends Throwable> exceptionType) {
		List<Class<? extends Throwable>> matches = new ArrayList<>();
    //找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系
		for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {
			if (mappedException.isAssignableFrom(exceptionType)) {
				matches.add(mappedException);
			}
		}
    // 不为空说明有方法处理异常
		if (!matches.isEmpty()) {
      // 按照匹配程度从小到大排序
			matches.sort(new ExceptionDepthComparator(exceptionType));
      // 返回处理异常的方法
			return this.mappedMethods.get(matches.get(0));
		}
		else {
			return null;
		}
	}

```

######  Spring 事务

**Spring 管理事务的方式有几种**

- **编程式事务**：在代码中硬编码(不推荐使用) : 通过 `TransactionTemplate`或者 `TransactionManager` 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。
- **声明式事务**：在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）

###### Spring 事务中的隔离级别有哪几种

和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：`Isolation`

```java
public enum Isolation {

    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),

    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),

    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),

    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),

    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);

    private final int value;

    Isolation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }

}

```

- **`TransactionDefinition.ISOLATION_DEFAULT`** :使用后端数据库默认的隔离级别，MySQL 默认采用的 `REPEATABLE_READ` 隔离级别 Oracle 默认采用的 `READ_COMMITTED` 隔离级别.
- **`TransactionDefinition.ISOLATION_READ_UNCOMMITTED`** :最低的隔离级别，使用这个隔离级别很少，**因为它允许读取尚未提交的数据变更**，**可能会导致脏读、幻读或不可重复读**。脏读是指一个事务能读取另一个事务未提交的数据，这可能导致数据不一致
- **`TransactionDefinition.ISOLATION_READ_COMMITTED`** : **允许读取并发事务已经提交的数据**，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。不可重复读是指在同一事务中，两次读取同一数据行返回不同的数据值，这通常是由于其他事务在这两次读取之间修改了数据。
- **`TransactionDefinition.ISOLATION_REPEATABLE_READ`** : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**幻读是指当一个事务重新读取满足某个搜索条件的行时，会发现有其他事务插入或删除了额外的满足该条件的行。
- **`TransactionDefinition.ISOLATION_SERIALIZABLE`** : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

###### @Transactional(rollbackFor = Exception.class)注解

`Exception` 分为**运行时异常 `RuntimeException`** 和**非运行时异常**

当 `@Transactional` 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。

**在 `@Transactional` 注解中如果不配置`rollbackFor`属性,那么事务只会在遇到`RuntimeException`的时候才会回滚，加上 `rollbackFor=Exception.class`,可以让事务在遇到非运行时异常时也回滚。**

###### Spring Data JPA

JPA（Java Persistence API）是Java平台提供的一套规范，**用于对象关系映射**（ORM）。它定义了一种方式，使得Java开发者可以**将对象映射到关系数据库中的表，从而实现了Java对象与数据库表之间的映射**。JPA是Java EE和Jakarta EE平台的一部分，但也可以在Java SE环境中单独使用

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String name;
    private String email;
    // 省略构造函数、getter和setter方法
}
```

1. **实体映射**: JPA允许你通过使用注解（例如`@Entity`, `@Table`, `@Column`）或XML配置来定义Java类与数据库表之间的映射。
2. **EntityManager**: JPA中的`EntityManager`是一个用于管理实体（例如查询、插入、更新、删除）的API。它也处理事务管理和实体的持久化。
3. **JPQL（Java Persistence Query Language）**: 一种独立于数据库的查询语言，类似于SQL，但是操作的是对象而不是表。
4. **标准API**: JPA提供了一套标准的API，这意味着你可以在不同的JPA实现之间切换而不需要重写代码。常见的JPA实现包括Hibernate, EclipseLink和OpenJPA。
5. **缓存机制**: JPA支持一级缓存和二级缓存，以提高应用程序性能。
6. **自动化和简化数据库操作**: JPA通过ORM技术简化了数据库操作，开发者无需编写大量的JDBC代码和手动处理结果集。

**如何使用 JPA 在数据库中非持久化一个字段**

```java
@Entity(name="USER")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "ID")
    private Long id;

    @Column(name="USER_NAME")
    private String userName;

    @Column(name="PASSWORD")
    private String password;

    private String secrect;

}
```

如果我们想让`secrect` 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：

```java
static String transient1; // not persistent because of static
final String transient2 = "Satish"; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient
```

**JPA 的审计功能是做什么的**

审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@MappedSuperclass
@EntityListeners(value = AuditingEntityListener.class)
public abstract class AbstractAuditBase {

    @CreatedDate
    @Column(updatable = false)
    @JsonIgnore
    private Instant createdAt;

    @LastModifiedDate
    @JsonIgnore
    private Instant updatedAt;

    @CreatedBy
    @Column(updatable = false)
    @JsonIgnore
    private String createdBy;

    @LastModifiedBy
    @JsonIgnore
    private String updatedBy;
}
```

###### Spring Security

![image-20231231175428595](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231231175428595.png)

**hasRole和hasAuthority的区别**

1. **`hasRole`**:
   - 当你使用`hasRole('ROLE_XYZ')`时，Spring Security会在内部实际上检查`ROLE_XYZ`权限。换句话说，它会自动为你提供的角色添加`ROLE_`前缀。这意味着如果你的角色存储在不带`ROLE_`前缀的数据库中，`hasRole`会自动添加这个前缀来进行匹配。
   - 例如，如果你调用`hasRole('ADMIN')`，Spring Security会查找`ROLE_ADMIN`权限。
2. **`hasAuthority`**:
   - `hasAuthority`不会自动添加任何前缀，它会精确匹配你所指定的字符串。如果你的权限或角色名称以特定方式存储（比如没有`ROLE_`前缀），你应该使用`hasAuthority`。
   - 例如，`hasAuthority('ROLE_ADMIN')`和`hasAuthority('ADMIN')`会分别查找精确相同的字符串。

###### Spring&SpringBoot常用注解

**`@SpringBootApplication`**

可以把 `@SpringBootApplication`看作是 `@Configuration`、`@EnableAutoConfiguration`、`@ComponentScan` 注解的集合

- `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制
- `@ComponentScan`：扫描被`@Component` (`@Repository`,`@Service`,`@Controller`)注解的 bean，注解默认会扫描该类所在的包下所有的类。
- `@Configuration`：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类

**`@Autowired`**

自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中

```java
@Service
public class UserService {
  ......
}

@RestController
@RequestMapping("/users")
public class UserController {
   @Autowired
   private UserService userService;
   ......
}

```

 **`@Component`,`@Repository`,`@Service`, `@Controller`**

我们一般使用 `@Autowired` 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 `@Autowired` 注解自动装配的 bean 的类,可以采用以下注解实现：

- `@Component`：通用的注解，可标注任意类为 `Spring` 组件。如果一个 Bean 不知道属于哪个层，可以使用`@Component` 注解标注。
- `@Repository` : 对应持久层即 Dao 层，主要用于数据库相关操作。
- `@Service` : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- `@Controller` : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。

**`@RestController`**

`@RestController`注解是`@Controller`和`@ResponseBody`的合集,表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器

单独使用 `@Controller` 不加 `@ResponseBody`的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。`@Controller` +`@ResponseBody` 返回 JSON 或 XML 形式数据

**`@Scope`**

```java
@Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}
```

- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
- prototype : 每次请求都会创建一个新的 bean 实例。
- request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。
- session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。

**`@Configuration`**

一般用来声明配置类，可以使用 `@Component`注解替代，不过使用`@Configuration`注解声明配置类更加语义化

```java
@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}
```

前后端传值

**`@PathVariable` 和 `@RequestParam`**

`@PathVariable`用于获取路径参数，`@RequestParam`用于获取查询参数

**`@RequestBody`**

用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且**Content-Type 为 application/json** 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用`HttpMessageConverter`或者自定义的`HttpMessageConverter`将请求的 body 中的 json 字符串转换为 java 对象。

**读取配置信息**

一般**将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。**

使用注解进行读取

- `@Value`

使用 `@Value("${property}")` 读取比较简单的配置信息

- `@ConfigurationProperties`

通过`@ConfigurationProperties`读取配置信息并与 bean 绑定

```java
@Component
@ConfigurationProperties(prefix = "library")
class LibraryProperties {
    @NotEmpty
    private String location;
    private List<Book> books;

    @Setter
    @Getter
    @ToString
    static class Book {
        String name;
        String description;
    }
  省略getter/setter
  ......
}

```

接着就可以像使用普通的 Spring bean 一样，将其注入到类中使用

**参数校验**

**即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据**

**JSR(Java Specification Requests）** 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了

校验的时候我们实际用的是 **Hibernate Validator** 框架，SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖

**所有的注解，推荐使用 JSR 注解，即`javax.validation.constraints`，而不是`org.hibernate.validator.constraints`**

**一些常用的字段验证的注解**

![image-20231231214252086](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231231214252086.png)

**验证请求体**

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Person {

    @NotNull(message = "classId 不能为空")
    private String classId;

    @Size(max = 33)
    @NotNull(message = "name 不能为空")
    private String name;

    @Pattern(regexp = "((^Man$|^Woman$|^UGM$))", message = "sex 值不在可选范围")
    @NotNull(message = "sex 不能为空")
    private String sex;

    @Email(message = "email 格式不正确")
    @NotNull(message = "email 不能为空")
    private String email;

}
```

**验证请求参数**

```java
@RestController
@RequestMapping("/api")
@Validated
public class PersonController {

    @GetMapping("/person/{id}")
    public ResponseEntity<Integer> getPersonByID(@Valid @PathVariable("id") @Max(value = 5,message = "超过 id 的范围了") Integer id) {
        return ResponseEntity.ok().body(id);
    }
}
```

**全局处理 Controller 层异常**

1. `@ControllerAdvice` :注解定义全局异常处理类
2. `@ExceptionHandler` :注解声明异常处理方法

```java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    /**
     * 请求参数异常处理
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) {
       ......
    }
}
```

**json 数据处理**

- 过滤 json 数据

  **`@JsonIgnoreProperties` 作用在类上用于过滤掉特定字段不返回或者不解析**

  ```java
  //生成json时将userRoles属性过滤
  @JsonIgnoreProperties({"userRoles"})
  public class User {
  
      private String userName;
      private String fullName;
      private String password;
      private List<UserRole> userRoles = new ArrayList<>();
  }
  
  ```

  **`@JsonIgnore`一般用于类的属性上，作用和上面的`@JsonIgnoreProperties` 一样**

  ```java
  public class User {
  
      private String userName;
      private String fullName;
      private String password;
     //生成json时将userRoles属性过滤
      @JsonIgnore
      private List<UserRole> userRoles = new ArrayList<>();
  }
  
  ```

- 格式化 json 数据

  `@JsonFormat`一般用来格式化 json 数据

  ```java
  @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone="GMT")
  private Date date;
  
  ```

#### JVM

##### 运行时数据区域

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域



##### HotSpot虚拟机对象探秘



