---
layout: post
title: "面经"
subtitle: "面经"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
  - java
---

### 面经

[参考](https://javaguide.cn/java/basis/java-basic-questions-01.html#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)

#### java基础面试题总结

###### Java SE vs Java EE

Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序

###### JVM vs JDK vs JRE

JVM是java运行字节码的虚拟机，有针对不同系统的的实现，程序编译成字节码，通过JVM，就可以在不同系统上运行，得到相同的结果

JDK是java开发者工具，提供给开发者使用，能够创建和编译java程序，其包含了JRE，并且包含编译器等

JRE是java运行环境，包含了Java程序运行时候的环境，和必须的库

如果需要进行 Java 编程工作，比如编写和编译 Java 程序、使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 JSP 转换为 Java Servlet、使用反射等，也需要 JDK 来编译和运行 Java 代码

![image-20231215195252063](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231215195252063.png)

###### 字节码

在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。

由于**字节码并不针对一种特定的机器**，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行

从字节码到机器码这一段，JVM会加载字节码文件，然后通过解释器逐行解释执行，这种方式比较慢，所以后面引入JIT，会在第一次编译之后，将字节码对应的机器码保存起来，供下次使用，所以速度更快  对热点代码进行保存

![image-20231216154345640](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231216154345640.png)

高级编程语言按照程序的执行方式分为两种：

- 编译型：通过编译器将代码一次性翻译成可被该平台执行的机器码，执行速度比较快，开发效率比较低
- 解释型：通过解释器将代码一句一句的将代码解释（interpret）为机器代码后再执行。开发效率比较快，执行速度比较慢

Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

###### AOT

这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译，AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。

但AOT也存在一些缺点，所以只能说 AOT 更适合当下的**云原生场景**，对微服务架构的支持也比较友好，OT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。然而，很多框架和库（如 Spring、CGLIB）都用到了这些特性。如果只使用 AOT 编译，那就没办法使用这些框架和库了

###### Java与c++区别

Java 不提供指针来直接访问内存，程序内存更加安全

Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。

Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。

C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

###### 标识符和关键字

标识符是程序、类、变量、方法等的名字，关键字是Java 语言已经赋予了其特殊的含义，只能用于特定的地方。**关键字是被赋予特殊含义的标识**符，所有的关键字都是小写的，在 IDE 中会以特殊颜色显示

⚠️ 注意：虽然 `true`, `false`, 和 `null` 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。

###### 移位运算符

`<<` :左移运算符，向左移若干位，高位丢弃，低位补零。`x << 1`,相当于 x 乘以 2(不溢出的情况下)。

`>>` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> 1`,相当于 x 除以 2。

`>>>` :无符号右移，忽略符号位，空位都以 0 补齐。

由于 `double`，`float` 在二进制中的表现比较特殊，因此不能来进行移位操作。

移位操作符实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作。

当 **int 类型左移/右移位数大于等于 32 位操作**时，会**先求余（%）后再进行左移/右移操作**。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。

###### 基本数据类型

![image-20231216165137530](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231216165137530.png)

Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析

这八个基本类型都有自己的**包装类**，比如说int的包装类是Integer

下面是包装类和基本类型的区别

- **包装类型可用于泛型**，而基本类型不可以
- 相比于包装类型（对象类型）， **基本数据类型占用的空间往往非常小**
- **基本数据类型的局部变量**存放在Java 虚拟机栈中的**局部变量表**中，**成员变量**被存放在 Java 虚拟机的**堆**中，**包装类型**属于对象类型，我们知道几乎所有对象实例都存在于**堆**中。
- 对于**基本数据类型**来说，**`==`** 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型**包装类对象**之间值的比较，全部使用 **`equals()`** 方法

###### 包装类型的缓存机制

Java 基本数据类型的包装类型的大部分都用到了**缓存机制**来提升性能

**Byte，Short，Integer，Long** 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，**`Character`** 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 True or False

缓存机制代表了在这个范围内，定义相同的值，两个值的内存地址是一样的，**Float和Double没有实现缓存机制**

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);// 输出 false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);// 输出 false
```

###### 自动装箱和拆箱

- **装箱**：将**基本类型**用它们对应的**引用类型**包装起来；
- **拆箱**：将**包装类型**转换为**基本数据类型**；

```java
Integer i = 10;  //装箱
int n = i;   //拆箱
```

**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作**

###### 解决浮点数运算精度丢失的问题

`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。

```java
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("0.9");
BigDecimal c = new BigDecimal("0.8");

BigDecimal x = a.subtract(b);
BigDecimal y = b.subtract(c);

System.out.println(x); /* 0.1 */
System.out.println(y); /* 0.1 */
System.out.println(Objects.equals(x, y)); /* true */
```

在使用`BigDecimal`的时候

![image-20231219183416527](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219183416527.png)

对于`BigDecimal`方法有自己的数据操作的方法

```java
BigDecimal a = new BigDecimal("1.0");
BigDecimal b = new BigDecimal("0.9");
System.out.println(a.add(b));// 1.9
System.out.println(a.subtract(b));// 0.1
System.out.println(a.multiply(b));// 0.90
System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常
System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11

```

![image-20231219184907404](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219184907404.png)

工具类

```java
import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * 简化BigDecimal计算的小工具类
 */
public class BigDecimalUtil {

    /**
     * 默认除法运算精度
     */
    private static final int DEF_DIV_SCALE = 10;

    private BigDecimalUtil() {
    }

    /**
     * 提供精确的加法运算。
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static double add(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.add(b2).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double subtract(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.subtract(b2).doubleValue();
    }

    /**
     * 提供精确的乘法运算。
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double multiply(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.multiply(b2).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入。
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2) {
        return divide(v1, v2, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入。
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double divide(double v1, double v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.divide(b2, scale, RoundingMode.HALF_EVEN).doubleValue();
    }

    /**
     * 提供精确的小数位四舍五入处理。
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b = BigDecimal.valueOf(v);
        BigDecimal one = new BigDecimal("1");
        return b.divide(one, scale, RoundingMode.HALF_UP).doubleValue();
    }

    /**
     * 提供精确的类型转换(Float)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static float convertToFloat(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.floatValue();
    }

    /**
     * 提供精确的类型转换(Int)不进行四舍五入
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static int convertsToInt(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.intValue();
    }

    /**
     * 提供精确的类型转换(Long)
     *
     * @param v 需要被转换的数字
     * @return 返回转换结果
     */
    public static long convertsToLong(double v) {
        BigDecimal b = new BigDecimal(v);
        return b.longValue();
    }

    /**
     * 返回两个数中大的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中大的一个值
     */
    public static double returnMax(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.max(b2).doubleValue();
    }

    /**
     * 返回两个数中小的一个值
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 返回两个数中小的一个值
     */
    public static double returnMin(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.min(b2).doubleValue();
    }

    /**
     * 精确对比两个数字
     *
     * @param v1 需要被对比的第一个数
     * @param v2 需要被对比的第二个数
     * @return 如果两个数一样则返回0，如果第一个数比第二个数大则返回1，反之返回-1
     */
    public static int compareTo(double v1, double v2) {
        BigDecimal b1 = BigDecimal.valueOf(v1);
        BigDecimal b2 = BigDecimal.valueOf(v2);
        return b1.compareTo(b2);
    }

}

```

###### 成员变量和局部变量

- **成员变量可以被 `public`,`private`,`static` 等修饰符所修饰**，而**局部变量不能**被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰
- 从变量在内存中的存储方式来看，如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而**对象存在于堆内存，局部变量则存在于栈内存。**
- 从变量在内存中的生存时间上看，**成员变量**是对象的一部分，它**随着对象的创建而存在**，而**局部变量**随着**方法的调用而自动生成**，随着方法的调用结束而消亡
- **成员变量如果没有被赋初始值**，则会自动以类型的**默认值**而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值

###### 静态变量

被 `static` 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量

###### 静态方法为什么不能调用非静态成员

- 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问
- 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

**静态方法和实例方法的不同**

- 在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 
- 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制

###### 重载和重写

**重载**是同一个方法，拥有**相同的方法名，但输入数据不同**，这样**编译器**必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。

```java
StringBuilder sb = new StringBuilder();
StringBuilder sb2 = new StringBuilder("HelloWorld");
```

**重写**是**子类继承自父类的相同方法**，**输入数据一样**，但要做出有别于父类的响应时，你就要覆盖父类方法,重写发生在运行期，是**子类对父类的允许访问的方法的实现过程**进行重新编写

1. 方法名、参数列表必须相同，**子类方法返回值类型应比父类方法返回值类型更小或相等**，抛出的**异常范围小于等于父类**，**访问修饰符范围大于等于父类**。
2. 如果父类方法访问修饰符为 **`private/final/static`** 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被**再次声明**。
3. **构造方法无法被重写**

![image-20231217120803615](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231217120803615.png)

⭐️ 如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

**遇到方法重载会优先匹配固定参数的方法，因为固定参数的方法匹配度更高**

###### 面向对象的三大特征

**封装**

一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

**继承**

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类

关于继承有几个点需要注意的

- 子类不能直接访问父类的私有方法和私有变量。私有方法和变量只在定义它们的类内部可见，这是封装的一个重要方面，不过可以通过共有方法或者protect方法进行访问
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展
- 子类可以用自己的方式实现父类的方法

**多态**

对象可以采用多种形态。在 Java 中，多态主要通过继承（inheritance）和接口（interfaces）以及方法的重写（overriding）和重载（overloading）来实现。多态使得我们可以用统一的方式处理不同类型的对象

**实现方法**

- 方法重写：子类重写父类的方法。当子类对象调用这个方法时，执行的是子类中重写的版本
- 方法重载：同一个类中多个同名方法，但它们的参数列表不同
- 向上转型：子类对象可以被当作父类对象使用。例如，如果有一个父类 `Animal` 和一个子类 `Dog`，那么 `Dog` 对象也可以被当作 `Animal` 对象使用。这使得你可以用 `Animal` 类型的变量来引用一个 `Dog` 对象
- 一个类实现一个接口，它需要提供接口中所有方法的具体实现。一个接口引用可以指向任何实现了该接口的类的对象

```java
// 父类
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

// 子类
class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

// 主程序
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // 创建 Animal 对象
        Animal myDog = new Dog();        // 创建 Dog 对象，但将其视为 Animal

        myAnimal.sound();  // 输出: Animal makes a sound
        myDog.sound();     // 输出: Dog barks，尽管 myDog 被声明为 Animal 类型
    }
}
```

###### 接口和抽象类

共同点：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法

区别：

- 接口里只有抽象方法，抽象类可以有非抽象方法
- 一个类只能继承一个类，但是可以实现多个接口
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值

###### 深拷贝和浅拷贝

- 浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。

- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

![image-20231218161815217](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218161815217.png)

```java
String a = new String("ab"); // a 为一个引用
String b = new String("ab"); // b为另一个引用,对象的内容一样
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true
```

###### hashCode

`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置

如果两个对象的**`hashCode` 值相等**，那这两个**对象不一定相等**（哈希碰撞）。

如果两个对象的**`hashCode` 值相等并且`equals()`方法也返回 `true`**，我们才认为这两个对象相等。

如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等

###### **String、StringBuffer、StringBuilder 的区别**

**可变性**

`String` 是不可变的

`StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 `final` 和 `private` 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法

**线程安全性**

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。

`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。

`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

`String` 类型进行改变的时候，都会生成一个新的 `String` 对象

`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。

相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险

**总结**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

###### String类型的不可变性

`String` 类中使用 `final` 关键字修饰字符数组来保存字符串，但这不是其不可变的原因，因为对于final来说，被 `final` 关键字**修饰的类不能被继承**，修饰的**方法**不能被**重写**，修饰的**变量**是**基本数据类型**则值**不能改变**，修饰的变量是**引用类型**则**不能再指向其他对象**

不可变的原因：

1. 保存字符串的数组被 `final` 修饰且为**私有**的，并且`String` 类没**有提供/暴露修改这个字符串的方法**。
2. `String` 类被 `final` 修饰导致其**不能被继承**，进而**避免了子类破坏 `String` 不可变**。

###### 字符串拼接用“+” 还是 StringBuilder

字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 

即先创建StringBuilder对象，然后用append进行拼接，然后toString转回String对象

这种方式会创建多个StringBuilder对象，空间上产生了浪费

如果直接使用 `StringBuilder` 对象进行字符串拼接的话，就不会存在这个问题了。

```java
String[] arr = {"he", "llo", "world"};
StringBuilder s = new StringBuilder();
for (String value : arr) {
    s.append(value);
}
System.out.println(s);

```

**`String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址**

###### String s1 = new String("abc")

上面这句话会创建1-2个对象，依据常量池中是否含有该字符串常量来判断

- 如果常量池含有该字符串常量

  则会创建一个对象，即new的时候会创建一个对象

- 如果常量池不含有该字符串常量

  会创建两个对象，new的时候会创建一个对象，然后会创建一个字符串对象abc，进行赋值

###### intern 方法的作用

`String.intern()` 是一个 native（本地）方法，其作用是**将指定的字符串对象的引用保存在字符串常量池中**，可以简单分为两种情况：

- 如果字符串常量池中**保存了对应的字符串对象的引用**，就**直接返回该引用**。
- 如果字符串常量池中**没有保存了对应的字符串对象的引用**，那就在**常量池中创建一个指向该字符串对象的引用**并返回。

```java
// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = "Java";
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String("Java");
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true
```

![image-20231218184007388](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218184007388.png)

###### 异常处理

![image-20231218184213110](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231218184213110.png)

###### 受检测异常和非受检测异常

**Checked Exception** 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 `catch`或者`throws` 关键字处理的话，就没办法通过编译

**Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译

除了`RuntimeException`及其子类以外，**其他的`Exception`类及其子类都属于受检查异常** 。常见的受检查异常有：IO 相关的异常、`ClassNotFoundException`、`SQLException`...。

###### Throwable类常用方法

- `String getMessage()`: 返回异常发生时的简要描述
- `String toString()`: 返回异常发生时的详细信息
- `String getLocalizedMessage()`: 返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同
- `void printStackTrace()`: 在控制台上打印 `Throwable` 对象封装的异常信息

###### try-catch-finally

try作用是捕获异常，catch是处理异常，finally是最后都是进入finally

**当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行**。

因此**注意：不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值

并且finally中的代码也不是一定会执行，就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。或者程序所在的线程死亡，关闭 CPU。

###### try-with-resources

面对必须要关闭的资源，我们总是应该优先使用 `try-with-resources` 而不是`try-finally`。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。`try-with-resources`语句让我们更容易编写必须要关闭的资源的代码，若采用`try-finally`则几乎做不到这点。

```java
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("test.txt")));
     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
    int b;
    while ((b = bin.read()) != -1) {
        bout.write(b);
    }
}
catch (IOException e) {
    e.printStackTrace();
}
```

###### 泛型

允许在类、接口和方法中使用类型参数。它提供了编译时类型安全检查的优点，这意味着您可以在编译时捕获到不正确的类型使用，而不是在运行时。泛型的引入减少了对强制类型转换的需求，并提供了更加抽象和通用的编程方式。

泛型一般使用有三种方式

- 泛型类

  ```java
  //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
  //在实例化泛型类时，必须指定T的具体类型
  public class Generic<T>{
  
      private T key;
  
      public Generic(T key) {
          this.key = key;
      }
  
      public T getKey(){
          return key;
      }
  }
  ```

- 泛型接口

  ```java
  public interface Generator<T> {
      public T method();
  }
  
  ```

- 泛型方法

  ```java
     public static < E > void printArray( E[] inputArray )
     {
           for ( E element : inputArray ){
              System.out.printf( "%s ", element );
           }
           System.out.println();
      }
  ```

###### 反射

在运行时分析类以及执行类中方法的能力，通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性

其主要使用步骤：

1. **在运行时获取类的信息**： 反射可以用来在运行时获取类的信息，比如类的名称、方法、字段和注解等。这对于理解未知代码或动态生成代码非常有用。
2. **动态创建对象和调用方法**： 使用反射可以动态地创建对象和调用方法，即使在编译时这些类或方法是未知的。
3. **修改字段值**： 即使字段被声明为私有，反射也能够修改它们的值。

```java
public class ReflectionExample {
    private int number;
    private String name;

    public ReflectionExample(int number, String name) {
        this.number = number;
        this.name = name;
    }

    public void printInfo() {
        System.out.println("Number: " + number + ", Name: " + name);
    }

    public static void main(String[] args) throws Exception {
        // 使用反射创建对象
        Class<?> clazz = ReflectionExample.class;
        Constructor<?> constructor = clazz.getConstructor(int.class, String.class);
        Object instance = constructor.newInstance(10, "Test");

        // 调用方法
        Method method = clazz.getMethod("printInfo");
        method.invoke(instance);

        // 访问字段
        Field field = clazz.getDeclaredField("name");
        field.setAccessible(true); // 对于私有字段需要这样做
        field.set(instance, "New Name");
        method.invoke(instance);
    }
}

```

缺点：

- 反射操作通常比直接的 Java 代码执行要慢，因为涉及到动态类型检查和方法调用。
- 反射破坏了封装，可能会导致意外的副作用，尤其是在访问私有字段和方法时。
- 在受限的环境（如 Applet 或服务器应用程序）中，安全策略可能会限制反射的使用。

为什么你使用 Spring 的时候 ，一个`@Component`注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 `@Value`注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？

这些都是因为你可以**基于反射分析类**，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。

**获取class对象的四种方式**

![image-20231219171551905](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219171551905.png)

###### 代理模式

**使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能**

**代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作**

代理模式有**静态代理和动态代理**两种实现方式

**静态代理**

**静态代理中，我们对目标对象的每个方法的增强都是手动完成的（\*后面会具体演示代码\*），非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改\*）且麻烦(\*需要对每个目标类都单独写一个代理类）**

**静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。**

静态代理的步骤：

1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

**动态代理**

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类

使用步骤：

1. 定义一个接口，声明需要代理的方法。
2. 创建一个实现了 `InvocationHandler` 接口的类，并定义在方法调用时想要执行的逻辑。
3. 使用 `Proxy.newProxyInstance` 方法创建代理对象，这个方法需要三个参数：类加载器、一组接口以及 `InvocationHandler` 实例。



###### 注解的分析方式

- **编译期直接扫描**：编译器在**编译 Java 代码的时候扫描对应的注解并处理**，比如某个方法使用`@Override` 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
- **运行期通过反射处理**：像框架中自带的注解(比如 Spring 框架的 `@Value`、`@Component`)都是通过**反射**来进行处理的。

###### SPI

![image-20231219154053778](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219154053778.png)

API是接口提供方提供方法实现，用户就可以直接调用接口进行使用

SPI是由**接口调用方确定接口规则**，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。

SPI机制能够大大地提高接口设计的灵活性，但也有一些缺点

- 需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。
- 当多个 `ServiceLoader` 同时 `load` 时，会有并发问题。

###### 序列化和反序列化

- **序列化**：将**数据结构或对象转换成二进制字节流的过程**
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

序列化的都是对象（Object）也就是实例化后的类(Class)

**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**

序列化协议在osi七层协议中是表示层，在tcp/ip四层协议中就是应用层

![image-20231219155537932](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219155537932.png)

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

关于 `transient` 还有几点注意：

- `transient` **只能修饰变量，不能修饰类和方法**。
- `transient` 修饰的变量，在**反序列化后变量值将会被置成类型的默认值**。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

[JDK自带的也有序列化方式](https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/)，但一般不使用，其原因是：

- **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
- **性能差**：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
- **存在安全问题**：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。

###### I/O

Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。

- `InputStream`/`Reader`: 所有的输入流的基类，**前者是字节输入流，后者是字符输入流**。
- `OutputStream`/`Writer`: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

![](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219163727170.png)

###### 语法糖

为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读，例如for-each

不过，**JVM 其实并不能识别语法糖**，Java 语法糖要想被正确执行，**需要先通过编译器进行解糖，也就是在程序编译阶段将其转换成 JVM 认识的基本语法**。这也侧面说明，Java 中真正支持语法糖的是 Java 编译器而不是 JVM

###### 参数传递

在java中引用传递，传递的是引用类型的地址

```java
public class Person {
    private String name;
   // 省略构造函数、Getter&Setter方法
}

public static void main(String[] args) {
    Person xiaoZhang = new Person("小张");
    Person xiaoLi = new Person("小李");
    swap(xiaoZhang, xiaoLi);
    System.out.println("xiaoZhang:" + xiaoZhang.getName());
    System.out.println("xiaoLi:" + xiaoLi.getName());
}

public static void swap(Person person1, Person person2) {
    Person temp = person1;
    person1 = person2;
    person2 = temp;
    System.out.println("person1:" + person1.getName());
    System.out.println("person2:" + person2.getName());
}


输出：
  person1:小李
  person2:小张
  xiaoZhang:小张
  xiaoLi:小李

```

像上面这种情况，记住传递的是地址，所以swap中进行交换，只是把这些对象指向的地址换了，在原方法中这些对象的地址是没变的

###### Unsafe

主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等

#### 集合面试题

![image-20231219204406441](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219204406441.png)

##### List

###### ArrayList和Array**的区别**

`ArrayList` 内部基于动态数组实现，比 `Array`（静态数组） 使用起来更加灵活：

- `ArrayList`会根据实际存储的元素动态地扩容或缩容，而 `Array` 被创建之后就不能改变它的长度了。
- `ArrayList` 允许你使用泛型来确保类型安全，`Array` 则不可以。
- `ArrayList` 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。`Array` 可以直接存储基本类型数据，也可以存储对象。
- `ArrayList` 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 `add()`、`remove()`等。`Array` 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。

`ArrayList`创建时不需要指定大小，而`Array`创建时必须指定大小。

![image-20231219224346858](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231219224346858.png)

###### ArrayList插入和删除元素时间复杂度

对于插入：

- 头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。
- 尾部插入：当 `ArrayList` 的容量**未达到极限**时，往列表末尾插入元素的**时间复杂度是 O(1)**，因为它只需要在数组末尾添加一个元素即可；当**容量已达到极限并且需要扩容时**，则**需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中**，然后再执行 O(1) 的操作添加元素。
- 指定位置插入：**需要将目标位置之后的所有元素都向后移动一个位置**，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。

对于删除：

- 头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。
- 尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。
- 指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。

###### LinkedList 插入和删除元素

头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。

尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。

指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)

###### ArrayList 与 LinkedList 区别

- **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是不保证线程安全；
- **底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）
- **插入和删除是否受元素位置的影响：**
  - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
  - `LinkedList` 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()`、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`,`remove(int index)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。
- **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 **`ArrayList`（实现了 `RandomAccess` 接口） 支持**。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。
- **内存空间占用：** **`ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）**

##### Set

###### Comparable 和 Comparator 的区别

`Comparable` 接口和 `Comparator` 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：

- `Comparable` 接口实际上是出自`java.lang`包 它有一个 `compareTo(Object obj)`方法用来排序
- `Comparator`接口实际上是出自 `java.util` 包它有一个`compare(Object obj1, Object obj2)`方法用来排序

###### 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同

底层实现不同

- `HashSet`、`LinkedHashSet` 和 `TreeSet` 都是 `Set` 接口的实现类，都能保证元素唯一，并且都不是线程安全的。
- `HashSet`、`LinkedHashSet` 和 `TreeSet` 的主要区别在于底层数据结构不同。`HashSet` 的底层数据结构是哈希表（基于 `HashMap` 实现）。`LinkedHashSet` 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。`TreeSet` 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。
- 底层数据结构不同又导致这三者的应用场景不同。`HashSet` 用于不需要保证元素插入和取出顺序的场景，`LinkedHashSet` 用于保证元素的插入和取出顺序满足 FIFO 的场景，`TreeSet` 用于支持对元素自定义排序规则的场景。

##### Queue

###### Queue 与 Deque 的区别

**![](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221155138555-20231221160730944-20231221160751391.png)**

###### ArrayDeque 与 LinkedList 的区别

- `ArrayDeque` 是基于可变长的数组和双指针来实现，而 `LinkedList` 则通过链表来实现。
- `ArrayDeque` 不支持存储 `NULL` 数据，但 `LinkedList` 支持。
- `ArrayDeque` 是在 JDK1.6 才被引入的，而`LinkedList` 早在 JDK1.2 时就已经存在。
- `ArrayDeque` 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 `LinkedList` 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。

从性能的角度上，选用 `ArrayDeque` 来实现队列要比 `LinkedList` 更好

###### PriorityQueue

其与 `Queue` 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。

- `PriorityQueue` 利用了**二叉堆的数据结构**来实现的，底层使用可变长的数组来存储数据

- `PriorityQueue` 通过**堆元素的上浮和下沉**，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。

- `PriorityQueue` 是**非线程安全**的，且不支持存储 `NULL` 和 `non-comparable` 的对象。

- `PriorityQueue` 默认是**小顶堆**，但可以接收一个 `Comparator` 作为构造参数，从而来自定义元素优先级的先后。

###### BlockingQueue

`BlockingQueue` （阻塞队列）是一个接口，继承自 `Queue`。`BlockingQueue`阻塞的原因是**其支持当队列没有元素时一直阻塞，直到有元素**；还支持如果**队列已满**，一直**等到队列可以放入新元素时再放入**。

BlockingQueue接口有很多实现类，包括ArrayBlockingQueue、LinkedBlockingQueue等

###### ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别

- 底层实现：`ArrayBlockingQueue` 基于数组实现，而 `LinkedBlockingQueue` 基于链表实现。
- 是否有界：`ArrayBlockingQueue` 是有界队列，必须在创建时指定容量大小。`LinkedBlockingQueue` 创建时可以不指定容量大小，默认是`Integer.MAX_VALUE`，也就是无界的。但也可以指定队列大小，从而成为有界的。
- 锁是否分离： `ArrayBlockingQueue`中的锁是没有分离的，即生产和消费用的是同一个锁；`LinkedBlockingQueue`中的锁是分离的，即生产用的是`putLock`，消费是`takeLock`，这样可以防止生产者和消费者线程之间的锁争夺。
- 内存占用：`ArrayBlockingQueue` 需要提前分配数组内存，而 `LinkedBlockingQueue` 则是动态分配链表节点内存。这意味着，`ArrayBlockingQueue` 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而`LinkedBlockingQueue` 则是根据元素的增加而逐渐占用内存空间。

##### Map

###### HashMap 和 Hashtable 的区别

- **线程是否安全：** `HashMap` 是**非线程安全的**，`Hashtable` 是线程安全的,因为 `Hashtable` 内部的方法基本都经过`synchronized` 修饰。（如果你要保证**线程安全的话就使用 `ConcurrentHashMap`** 吧！）；

- **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它；

- **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。

- **初始容量大小和每次扩充容量大小的不同：** ① **创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍**。② 创建时如果给定了容量初始值，那么 `Hashtable` 会直接使用你给定的大小，而 **`HashMap` 会将其扩充为 2 的幂次方大小**（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小

  **原因是：**希望哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的，用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ `(n - 1) & hash`”

- **底层数据结构：** JDK1.8 以后的 **`HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树**（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。`Hashtable` 没有这样的机制。

hashmap设置初始容量时的源码，这段代码通过位运算确定最接近并大于等于给定容量 `cap` 的 2 的幂的值

```java
/**
     * Returns a power of two size for the given target capacity.
     */
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

###### HashMap 和 HashSet 区别

`HashSet` 底层就是基于 `HashMap` 实现的。（`HashSet` 的源码非常非常少，因为除了 `clone()`、`writeObject()`、`readObject()`是 `HashSet` 自己不得不实现之外，其他方法都是直接调用 `HashMap` 中的方法

![image-20231221174219484](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221174219484.png)

######  HashMap 和 TreeMap 区别

`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口，因此**多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力**

###### HashSet 如何检查重复

当你把对象加入`HashSet`时，`HashSet` 会先计算对象的`hashcode`值来判断对象加入的位置，同时也会与其他加入的对象的 `hashcode` 值作比较，如果没有相符的 `hashcode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashcode` 值的对象，这时会调用`equals()`方法来检查 `hashcode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让加入操作成功

###### HashMap 的底层实现

JDK1.8 之前 `HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 `hashcode` 经过**扰动函数**处理过后得到 **hash 值**，然后通过 `(n - 1) & hash` （取余）判断当前元素**存放的位置**（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 **hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突**。

**扰动函数**指的就是 HashMap 的 `hash` 方法。使用 `hash` 方法也就是扰动函数是为了防止一些实现比较差的 `hashCode()` 方法 换句话说**使用扰动函数之后可以减少碰撞**。

![image-20231221210113846](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231221210113846.png)

JDK1.8 之后在解决哈希冲突时有了较大的变化，当**链表长度大于阈值**（默认为 8）（将链表转换成红黑树**前**会判断，**如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树**）时，将**链表转化为红黑树**，以减少搜索时间

红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。

###### HashMap 多线程操作导致死循环问题

JDK1.7 及之前版本的 `HashMap` 在多线程环境下扩容操作可能存在死循环问题，其原因是当一个桶位中有**多个元素需要进行扩容**时，**多个线程同时对链表进行操作**，**头插法**可能会导致链表中的节点**指向错误的位置**，从而形成一个**环形链表**，进而使得查询元素的操作陷入死循环无法结束。

![image-20231222100747245](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222100747245.png)

JDK1.8 版本的 HashMap 采用了**尾插法**而不是头插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，**保持了节点原来的相对顺序**，避免了链表中的环形结构。但是还是不建议在多线程下使用 `HashMap`，因为多线程下使用 `HashMap` 还是会存在数据覆盖的问题。并发环境下，推荐使用 **`ConcurrentHashMap`** 。

###### HashMap 为什么线程不安全

**JDK1.7 及之前版本**，在多线程环境下，`HashMap` 扩容时会造成**死循环和数据丢失**的问题。

数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。

**JDK 1.8 后**，在 `HashMap` 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有**数据覆盖**的风险

发生数据丢失的情况：

1. 两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。
2. 不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。
3. 随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了

###### HashMap 常见的遍历方式

1. 使用 `entrySet()` 遍历

   ```java
   Map<String, Integer> map = new HashMap<>();
   // ...添加元素到map中
   for (Map.Entry<String, Integer> entry : map.entrySet()) {
       System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
   }
   ```

2. 使用 `keySet()` 遍历

   ```java
   for (String key : map.keySet()) {
       System.out.println("Key = " + key + ", Value = " + map.get(key));
   }
   ```

3. 使用 `values()` 遍历

   ```java
   for (Integer value : map.values()) {
       System.out.println("Value = " + value);
   }
   ```

4. 使用 Java 8 的 `forEach`

   ```java
   map.forEach((key, value) -> System.out.println("Key = " + key + ", Value = " + value));
   ```

5. 使用迭代器

   ```java
   Iterator<Map.Entry<String, Integer>> iterator = map.entrySet().iterator();
   while (iterator.hasNext()) {
       Map.Entry<String, Integer> entry = iterator.next();
       System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
   }
   ```

###### ConcurrentHashMap 和 Hashtable 的区别

- 底层数据结构

  ConcurrentHashMap：在JDK1.7之前**分段的数组+链表** ，在JDK1.8后**数组+链表/红黑二叉树**

  HashTable：在JDK1.7之前**数组+链表**，

- **实现线程安全的方式**

  ConcurrentMap：

  **JDK1.7之前**，对整个桶数组进行了**分割分段(`Segment`，分段锁)**，即 **Segment 数组 + HashEntry 数组 + 链表**，每一把锁只**锁容器其中一部分数据**，**多线程访问容器里不同数据段的数据**，就**不会存在锁竞争**，提高并发访问率。 

  ![image-20231222105333437](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222105333437.png)

  **JDK1.8之后** ，**已经摒弃了 `Segment` 的概念**，而是直接用 **`Node` 数组+链表+红黑树的数据结构**来实现，**并发控制使用 `synchronized` 和 CAS 来操作**。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

  Hashtable：

  使用 `synchronized` 来保证线程安全，效率非常低下

###### ConcurrentHashMap 线程安全的具体实现方式/底层具体实现

**JDK1.8 之前**

首先将数据分为一段一段（这个“段”就是 `Segment`）的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，参照上图

**`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成**

一个 `ConcurrentHashMap` 里包含一个 `Segment` 数组，`Segment` 的个数一旦**初始化就不能改变**。 **`Segment` 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写**

每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。也就是说，对同一 `Segment` 的并发写入会被阻塞，不同 `Segment` 的写入是可以并发执行的

**JDK1.8 之后**

`ConcurrentHashMap` **取消了 `Segment` 分段锁**，采用 **`Node + CAS + synchronized`** 来保证并发安全。数据结构跟 `HashMap` 1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将**链表（寻址时间复杂度为 O(N)）转换为红黑树**（寻址时间复杂度为 O(log(N))）。

Java 8 中，**锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点**，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升

######  ConcurrentHashMap 为什么 key 和 value 不能为 null

key 和 value 不能为 null 主要是为了避免二义性。null 是一个特殊的值，**表示没有对象或没有引用**。**如果你用 null 作为键，那么你就无法区分这个键是否存在于 `ConcurrentHashMap` 中，还是根本没有这个键**。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 `ConcurrentHashMap` 中的，还是因为找不到对应的键而返回的。

但**HashMap**可以存储，可以通过**containsKey来查找**，而ConcurrentHashMap，存在一个线程操作该 `ConcurrentHashMap` 时，**其他的线程将该 `ConcurrentHashMap` 修改的情况**，所以**无法通过 `containsKey(key)`** 来判断否存在这个键值对，也就没办法解决二义性问题了

**线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）**

###### ConcurrentHashMap 能保证复合操作的原子性吗

**复合操作**是指由多个基本操作(如`put`、`get`、`remove`、`containsKey`等)组成的操作，例如先判断某个键是否存在`containsKey(key)`，然后根据结果进行插入或更新`put(key, value)`。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期

`ConcurrentHashMap` 提供了一些**原子性的复合操作**，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。**这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中**

![image-20231222113526863](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231222113526863.png)

##### 集合操作的注意事项

###### 集合判空

**判断所有集合内部的元素是否为空，使用 `isEmpty()` 方法，而不是 `size()==0` 的方式**

这是因为 `isEmpty()` 方法的可读性更好，并且时间复杂度为 O(1)，而ConcurrentLinkedQueue`、`ConcurrentHashMap的size( )的时间复杂度就不是O(1)

###### 集合转 Map

**在使用 `java.util.stream.Collectors` 类的 `toMap()` 方法转为 `Map` 集合时，一定要注意当 value 为 null 时会抛 NPE 异常**

```java
class Person {
    private String name;
    private String phoneNumber;
     // getters and setters
}

List<Person> bookList = new ArrayList<>();
bookList.add(new Person("jack","18163138123"));
bookList.add(new Person("martin",null));
// 空指针异常
bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));

```

因为toMap方法会调用`Map` 接口的 `merge()` 方法，`merge()` 方法会先调用 `Objects.requireNonNull()` 方法判断 value 是否为空。

###### 集合遍历

**不要在 foreach 循环里进行元素的 `remove/add` 操作。remove 元素请使用 `Iterator` 方式，如果并发操作，需要对 `Iterator` 对象加锁**

这是因为使用 `foreach` 循环（或 Java 中的增强型 for 循环）遍历集合时，底层用的是**集合的迭代器**实现，而**集合迭代器在遍历过程中要求集合结构保持不变**，所以会抛出`ConcurrentModificationException` 异常

而使用可以使用**迭代器（`Iterator`）的 `remove` 方法**。这种方式允许你在遍历时修改集合，而不会抛出 `ConcurrentModificationException`。

```java
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String element = iterator.next();
    if (someCondition(element)) {
        iterator.remove(); // 安全移除元素
    }
}
```

并且如果在**多线程环境中**，**多个线程同时遍历和修改同一个集合**，即使是使用迭代器的 `remove` 方法，也可能会遇到**并发问题**

所以在并发操作时，需要对**迭代器或集合对象加锁**，以保证在**一个线程遍历和修改集合时，其他线程不能进行修改**。这可以通过同步代码块或使用并发集合来实现，可以使用 `synchronized` 关键字来实现加锁

###### 集合去重

**可以利用 `Set` 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 `List` 的 `contains()` 进行遍历去重或者判断包含操作**

下面是Set和List去重的代码

```java
// Set 去重代码示例
public static <T> Set<T> removeDuplicateBySet(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new HashSet<>();
    }
    return new HashSet<>(data);
}

// List 去重代码示例
public static <T> List<T> removeDuplicateByList(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new ArrayList<>();

    }
    List<T> result = new ArrayList<>(data.size());
    for (T current : data) {
        if (!result.contains(current)) {
            result.add(current);
        }
    }
    return result;
}

```

两者的区别在于**`HashSet` 的 `contains()` 方法底部依赖的 `HashMap` 的 `containsKey()` 方法，时间复杂度接近于 O（1）**，而**`ArrayList` 的 `contains()` 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)**

###### 集合转数组

**使用集合转数组的方法，必须使用集合的 `toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。**

例如下面代码，传入new String[0]表示类型

下面的Arrays.asList方法，对list进行反转，同样的s数组也会反转

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};
List<String> list = Arrays.asList(s);
Collections.reverse(list);
//没有指定类型的话会报错
s=list.toArray(new String[0]);

```

最后一行虽然传入了一个长度为 0 的数组，但 Java 会根据列表的大小创建一个新的、合适大小的数组。

###### 数组转集合

使用工具类 `Arrays.asList()` 把数组转换成集合时，**不能使用其修改集合相关的方法**， 它的 `add/remove/clear` 方法会抛出 `UnsupportedOperationException` 异常

这里使用asList将数组转化为集合，只是传入了一个元素，list里面只有一个元素

```java
int[] myArray = {1, 2, 3};
List myList = Arrays.asList(myArray);
System.out.println(myList.size());//1
System.out.println(myList.get(0));//数组地址值
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
int[] array = (int[]) myList.get(0);
System.out.println(array[0]);//1
```

同时，使用集合的方法也会报错

```java
List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
```

所以要将数组转化为ArrayList可以用以下方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"))
```

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());

```

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```

##### 集合源码分析

###### ArrayList源码分析

数组队列，相当于动态数组，其容量能**动态增长**

在**添加大量元素**前，应用程序可以使用**`ensureCapacity`操作**来**增加 `ArrayList` 实例的容量**

```java

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{

  }

```

从这个继承关系可以看出

- `List` : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。
- `RandomAccess` ：这是一个标志接口，表明实现这个接口的 `List` 集合是支持 **快速随机访问** 的。在 `ArrayList` 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。
- `Cloneable` ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。
- `Serializable` : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。

**ArrayList和vector的区别在于：**

- ArrayList是List的主要实现类，vector是以前的实现类
- ArrayList线程不安全，vector线程安全

**ArrayList扩容机制**

1. **初始容量**： 当创建 `ArrayList` 时，你可以指定一个初始容量。如果没有指定，`ArrayList` 将使用默认容量大小（在 Java 8 中，默认为 10）。
2. **添加元素**： 当向 `ArrayList` 添加元素且内部数组无法容纳更多元素时，`ArrayList` 需要扩容。
3. **新容量计算**： 新容量的计算公式取决于 `ArrayList` 的版本。在大多数实现中，新容量是旧容量的 1.5 倍。例如，如果当前容量为 10，扩容后将变为 15。这个增长率是一个折中的选择，旨在平衡内存使用和性能。
4. **创建新数组并复制元素**： `ArrayList` 会创建一个新的、更大的数组。然后，它将旧数组中的所有元素复制到新数组中。
5. **废弃旧数组**： 一旦旧数组中的元素被复制到新数组中，旧数组就会被废弃，以便垃圾收集器回收。

###### LinkedList源码分析



