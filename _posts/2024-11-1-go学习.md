---
layout: post
title: "go学习"
subtitle: "go学习"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
- go

---

#### 基础语法

**变量**

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    var a = "initial"

    var b, c int = 1, 2

    var d = true

    var e float64

    f := float32(e)

    g := a + "foo"
    fmt.Println(a, b, c, d, e, f) // initial 1 2 true 0 0
    fmt.Println(g)                // initialfoo

    const s string = "constant"
    const h = 500000000
    const i = 3e20 / h
    fmt.Println(s, h, i, math.Sin(h), math.Sin(i))
}
```

**if else**

```go
package main

import "fmt"

func main() {
    if 7%2 == 0 {
        fmt.Println("7 is even")
    } else {
        fmt.Println("7 is odd")
    }

    if 8%4 == 0 {
        fmt.Println("8 is divisible by 4")
    }

    if num := 9; num < 0 {
        fmt.Println(num, "is negative")
    } else if num < 10 {
        fmt.Println(num, "has 1 digit")
    } else {
        fmt.Println(num, "has multiple digits")
    }
}
```

**循环**

go中没有while、do-while循环，只有for循环

```go
package main

import "fmt"

func main() {
    i := 1
  //死循环
    for {
        fmt.Println("loop")
        break
    }
//这里面三段任何一段都可以省略
    for j := 7; j < 9; j++ {
        fmt.Println(j)
    }

    for n := 0; n < 5; n++ {
        if n%2 == 0 {
            continue
        }
        fmt.Println(n)
    }

    for i <= 3 {
        fmt.Println(i)
        i = i + 1
    }
}
```

**switch**

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    a := 2
  //go中不需要break，可以用任何类型
    switch a {
    case 1:
        fmt.Println("one")
    case 2:
        fmt.Println("two")
    case 3:
        fmt.Println("three")
    case 4, 5:
        fmt.Println("four or five")
    default:
        fmt.Println("other")
    }

    t := time.Now()
  //甚至不需要变量
    switch {
    case t.Hour() < 12:
        fmt.Println("It's before noon")
    default:
        fmt.Println("It's after noon")
    }
}
```

**数组**

```go
package main

import "fmt"

func main() {
    var a [5]int
    a[4] = 100
    fmt.Println(a[4], len(a))

    b := [5]int{1, 2, 3, 4, 5}
  //也可以不设置大小值
  //b := []int{1, 2, 3, 4, 5}
    fmt.Println(b)

    var twoD [2][3]int
    for i := 0; i < 2; i++ {
        for j := 0; j < 3; j++ {
            twoD[i][j] = i + j
        }
    }
    fmt.Println("2d: ", twoD)
}
```

**切片**

```go
package main

import "fmt"

func main() {
    s := make([]string, 3)
    s[0] = "a"
    s[1] = "b"
    s[2] = "c"
    fmt.Println("get:", s[2])    // c
    fmt.Println("len:", len(s))   // 3

    s = append(s, "d")
    s = append(s, "e", "f")
    fmt.Println(s)                // [a b c d e f]

    c := make([]string, len(s))
    copy(c, s)
    fmt.Println(c)                // [a b c d e f]

    fmt.Println(s[2:5])           // [c d e]
    fmt.Println(s[:5])            // [a b c d e]
    fmt.Println(s[2:])            // [c d e f]

    good := []string{"g", "o", "o", "d"}
    fmt.Println(good)             // [g o o d]
}
```

**map**

```go
package main

import "fmt"

func main() {
    m := make(map[string]int)
    m["one"] = 1
    m["two"] = 2
    fmt.Println(m)                // map[one:1 two:2]
    fmt.Println(len(m))           // 2
    fmt.Println(m["one"])         // 1
    fmt.Println(m["unknow"])      // 0

    r, ok := m["unknow"]
    fmt.Println(r, ok)            // 0 false

    delete(m, "one")

    m2 := map[string]int{"one": 1, "two": 2}
    var m3 = map[string]int{"one": 1, "two": 2}
    fmt.Println(m2, m3)
}
```

**range**

用于快速，简洁遍历数组

```go
package main

import "fmt"

func main() {
    nums := []int{2, 3, 4}
    sum := 0
    for i, num := range nums {
        sum += num
        if num == 2 {
            fmt.Println("index:", i, "num:", num) // index: 0 num: 2
        }
    }
    fmt.Println(sum) // 9

    m := map[string]string{"a": "A", "b": "B"}
    for k, v := range m {
        fmt.Println(k, v) // b B; a A
    } 
    for k := range m {
        fmt.Println("key", k) // key a; key b
    }
}
```

**函数**

```go
package main

import "fmt"

func add(a int, b int) int {
    return a + b
}

func add2(a, b int) int {
    return a + b
}

func exists(m map[string]string, k string) (v string, ok bool) {
    v, ok = m[k]
    return v, ok
}

func main() {
    res := add(1, 2)
    fmt.Println(res) // 3

    v, ok := exists(map[string]string{"a": "A"}, "a")
    fmt.Println(v, ok) // A true
}
```

**指针**

```go
package main

import "fmt"

func add2(n int) {
    n += 2
}

func add2ptr(n *int) {
    *n += 2
}

func main() {
    n := 5
    add2(n)
    fmt.Println(n) // 5
    add2ptr(&n)
    fmt.Println(n) // 7
}
```

**结构体**

```go
package main

import "fmt"

type user struct {
    name     string
    password string
}

func main() {
  //结构体的几种声明变量的方式
    a := user{name: "wang", password: "1024"}
    b := user{"wang", "1024"}
    c := user{name: "wang"}
    c.password = "1024"
    var d user
    d.name = "wang"
    d.password = "1024"

    fmt.Println(a, b, c, d) // {wang 1024} {wang 1024} {wang 1024} {wang 1024}
    fmt.Println(checkPassword(a, "haha"))   // false
    fmt.Println(checkPassword2(&a, "haha")) // false
}
//结构体传递可以有指针和非指针两种方式
//这和java不一样，java这种传的都是引用，但go这里如果不传指针形式的话，是不会改变原始值的
func checkPassword(u user, password string) bool {
    return u.password == password
}

func checkPassword2(u *user, password string) bool {
    return u.password == password
}
```

**结构体方法**

在函数名前面的 (u user) 或 (u *user) 称为**接收者**。接收者指定了这个方法属于哪个类型（例如 user 结构体），因此该方法成为了这个类型的**方法**。

类似于java的类成员函数

```go
package main

import "fmt"

type user struct {
    name     string
    password string
}
//适合用于不改变结构体内容的场景，如只读操作
func (u user) checkPassword(password string) bool {
    return u.password == password
}
//适合用于需要修改结构体内容的场景，如更新密码
func (u *user) resetPassword(password string) {
    u.password = password
}

func main() {
    a := user{name: "wang", password: "1024"}
    a.resetPassword("2048")
    fmt.Println(a.checkPassword("2048")) // true
}
```

**错误处理**

```go
package main

import (
    "errors"
    "fmt"
)

type user struct {
    name     string
    password string
}

func findUser(users []user, name string) (v *user, err error) {
    for _, u := range users {
        if u.name == name {
            return &u, nil
        }
    }
    return nil, errors.New("not found")
}

func main() {
  //定义函数返回值有err
    u, err := findUser([]user{{"wang", "1024"}}, "wang")
  //所以首先判断err
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(u.name) // wang

    if u, err := findUser([]user{{"wang", "1024"}}, "li"); err != nil {
        fmt.Println(err) // not found
        return
    } else {
        fmt.Println(u.name)
    }
}
```

**字符串**

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    a := "hello"
    fmt.Println(strings.Contains(a, "ll"))          // true
    fmt.Println(strings.Count(a, "l"))              // 2
    fmt.Println(strings.HasPrefix(a, "he"))         // true
    fmt.Println(strings.HasSuffix(a, "llo"))        // true
    fmt.Println(strings.Index(a, "ll"))             // 2
    fmt.Println(strings.Join([]string{"he", "llo"}, "-")) // he-llo
    fmt.Println(strings.Repeat(a, 2))               // hellohello
    fmt.Println(strings.Replace(a, "e", "E", -1))   // hEllo
    fmt.Println(strings.Split("a-b-c", "-"))        // [a b c]
    fmt.Println(strings.ToLower(a))                 // hello
    fmt.Println(strings.ToUpper(a))                 // HELLO
    fmt.Println(len(a))                             // 5

    b := "你好"
    fmt.Println(len(b))                             // 6
}
```

**字符串格式化**

```go
package main

import "fmt"

type point struct {
    x, y int
}

func main() {
    s := "hello"
    n := 123
    p := point{1, 2}
    fmt.Println(s, n)             // hello 123
    fmt.Println(p)                // {1 2}
//有各种占位符，用%v可以代替各种类型的符
    fmt.Printf("s=%v\n", s)       // s=hello
    fmt.Printf("n=%v\n", n)       // n=123
    fmt.Printf("p=%v\n", p)       // p={1 2}
    fmt.Printf("p=%+v\n", p)      // p={x:1 y:2}
    fmt.Printf("p=%#v\n", p)      // p=main.point{x:1, y:2}

    f := 3.141592653
    fmt.Println(f)                // 3.141592653
    fmt.Printf("%.2f\n", f)       // 3.14
}
```

**JSON处理**

结构体中每个字段首字母要大写，就可以用json.Marshal进行序列化

```go
package main

import (
    "encoding/json"
    "fmt"
)

type userInfo struct {
    Name  string
    Age   int      `json:"age"`
    Hobby []string
}

func main() {
    a := userInfo{Name: "wang", Age: 18, Hobby: []string{"Golang", "TypeScript"}}
  //将结构体进行序列化
    buf, err := json.Marshal(a)
    if err != nil {
        panic(err)
    }
    fmt.Println(buf)              // [123 34 97 103 ...]
    fmt.Println(string(buf))       // {"Name":"wang","age":18,"Hobby":["Golang","TypeScript"]}

    buf, err = json.MarshalIndent(a, "", "\t")
    if err != nil {
        panic(err)
    }
    fmt.Println(string(buf))       // 格式化后的 JSON 输出

    var b userInfo
  //buff反序列化到b中
    err = json.Unmarshal(buf, &b)
    if err != nil {
        panic(err)
    }
    fmt.Printf("%#v\n", b)         // main.userInfo{Name:"wang", Age:18, Hobby:[]string{"Golang", "TypeScript"}}
}
```

**时间处理**

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    now := time.Now()
    fmt.Println(now) // 当前时间，示例：2022-03-27 18:04:59.433297 +0800 CST m=+0.000087933

    t := time.Date(2022, 3, 27, 1, 25, 36, 0, time.UTC)
    t2 := time.Date(2022, 3, 27, 2, 30, 36, 0, time.UTC)
    fmt.Println(t) // 2022-03-27 01:25:36 +0000 UTC

    fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) // 输出各时间字段，例如：2022 March 27 1 25
    fmt.Println(t.Format("2006-01-02 15:04:05")) // 格式化时间输出：2022-03-27 01:25:36
	//得到时间段
    diff := t2.Sub(t)
    fmt.Println(diff) // 时间差，示例：1h5m0s
    fmt.Println(diff.Minutes(), diff.Seconds()) // 时间差的分钟数和秒数，例如：65 3900

    t3, err := time.Parse("2006-01-02 15:04:05", "2022-03-27 01:25:36")
    if err != nil {
        panic(err)
    }
    fmt.Println(t3 == t) // true，判断解析的时间是否等于原始时间
	//获取时间戳
    fmt.Println(now.Unix()) // 输出当前时间的 Unix 时间戳，例如：1648378800
}
```

**字符串数字间转化**

```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
  
  //strconv.ParseFloat：将字符串解析为浮点数。参数 64 表示转换为 float64 类型
    f, _ := strconv.ParseFloat("1.234", 64)
    fmt.Println(f)               // 1.234
  
	//strconv.ParseInt：将字符串解析为指定进制的整数。参数 10 表示十进制，0 表示自动识别进制（如 "0x" 前缀会识别为十六进制）。参数 64 指定目标类型为 int64
    n, _ := strconv.ParseInt("111", 10, 64)
    fmt.Println(n)               // 111

    n, _ = strconv.ParseInt("0x1000", 0, 64)
    fmt.Println(n)               // 4096

  //专门用于将十进制字符串转换为整数，返回 int 类型
    n2, _ := strconv.Atoi("123")
    fmt.Println(n2)              // 123
  //解析失败
    n2, err := strconv.Atoi("AAA")
    fmt.Println(n2, err)         // 0 strconv.Atoi: parsing "AAA": invalid syntax
}
```

**进程信息**

```go
package main

import (
    "fmt"
    "os"
    "os/exec"
)

func main() {
    // go run example/20-env/main.go a b c d
  	//os.Args是切片，所以可以用args := os.Args[1:]获取输入参数
    fmt.Println(os.Args)           // 输出程序参数，例如：[path/to/exe a b c d]

    fmt.Println(os.Getenv("PATH")) // 获取环境变量 PATH，例如：/usr/local/go/bin...
    fmt.Println(os.Setenv("AA", "BB")) // 设置环境变量 AA=BB

    buf, err := exec.Command("grep", "127.0.0.1", "/etc/hosts").CombinedOutput()
    if err != nil {
        panic(err)
    }
    fmt.Println(string(buf))       // 输出 grep 结果，例如：127.0.0.1 localhost
}
```

#### go实战案例

##### 猜谜游戏

```go
package main

import(
	"fmt"
	"math/rand"
	"bufio"
	"strings"
	"os"
	"strconv"
)

func main(){
	maxNum:=100
	secretNum:=rand.Intn(maxNum)
	fmt.Println("input your guess")
	reader:=bufio.NewReader(os.Stdin)
	for{
		input,err:=reader.ReadString('\n')
		if err != nil{
			fmt.Println("An error occured while inputing",err)
			continue
		}
		input=strings.TrimSuffix(input,"\n")
		guess,err:=strconv.Atoi(input)
		if err!=nil{
			fmt.Println("Invalid input")
			continue
		}
		fmt.Println("your guess is",guess)
		if guess > secretNum{
			fmt.Println("bigger")
		}else if guess<secretNum{
			fmt.Println("smaller")
		}else{
			fmt.Println("bingo")
			break
		}
	}
}
```

##### **命令行词典**

```go
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
)

func main() {
	client := &http.Client{}
  //创建一个包含 JSON 格式数据的 io.Reader 类型的数据流，用于 HTTP 请求的请求体中
	var data = strings.NewReader(`{"trans_type":"en2zh","source":"good"}`)
  //创建请求
	req, err := http.NewRequest("POST", "https://api.interpreter.caiyunapp.com/v1/dict", data)
	if err != nil {
		log.Fatal(err)
	}
  //设置请求头
	req.Header.Set("Connection", "keep-alive")
	req.Header.Set("DNT", "1")
	req.Header.Set("sec-ch-ua-mobile", "?0")
	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36")
	req.Header.Set("app-name", "xy")
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	req.Header.Set("Accept", "application/json, text/plain, */*")
	req.Header.Set("device-id", "")
	req.Header.Set("os-type", "web")
	req.Header.Set("X-Authorization", "token:qgemv4jiy38j4gv6uvhj")
	req.Header.Set("Referer", "https://fanyi.caiyunapp.com/")
	req.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
	req.Header.Set("Cookie", "_ym_uid=1645984782032859353; _ym_d=1645984782")
	//发送请求
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
  //避免资源泄漏，手动关闭流
	defer resp.Body.Close()
  //读取响应
	bodyText, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s\n", bodyText)
}
```

但上面的是固定参数，所以这里可以设计一个结构体，将参数传入结构体中，然后调用json.Marshal进行序列化

```go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
)

type DictRequest struct {
	TransType string `json:"trans_type"`
	Source    string `json:"source"`
	UserID    string `json:"user_id"`
}

func main() {
	client := &http.Client{}

	request := DictRequest{TransType: "en2zh", Source: "good"}
	buf, err := json.Marshal(request)
	if err != nil {
		log.Fatal(err)
	}
	
	var data = bytes.NewReader(buf)
	req, err := http.NewRequest("POST", "https://api.interpreter.caiyunapp.com/v1/dict", data)
	if err != nil {
		log.Fatal(err)
	}

	req.Header.Set("Connection", "keep-alive")
	req.Header.Set("DNT", "1")
	req.Header.Set("sec-ch-ua-mobile", "?0")
	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36")
	req.Header.Set("app-name", "xy")
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	req.Header.Set("Accept", "application/json, text/plain, */*")
	req.Header.Set("device-id", "")
	req.Header.Set("os-type", "web")
	req.Header.Set("X-Authorization", "token:qgemv4jiy38j4gv6uvhj")
	req.Header.Set("Referer", "https://fanyi.caiyunapp.com/")
	req.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
	req.Header.Set("Cookie", "_ym_uid=1645984782032859353; _ym_d=1645984782")

	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	bodyText, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%s\n", bodyText)
}
```

接着设置响应体，进行解析，总代码如下

```go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"strings"
)

type DictRequest struct {
	TransType string `json:"trans_type"`
	Source    string `json:"source"`
	UserID    string `json:"user_id"`
}

type DictResponse struct {
    Rc   int    `json:"rc"`
    Wiki struct {
        KnownInLanguages int `json:"known_in_languages"`
        Description      struct {
            Source string      `json:"source"`
            Target interface{} `json:"target"`
        } `json:"description"`
        ID    string `json:"id"`
        Item  struct {
            Source string `json:"source"`
            Target string `json:"target"`
        } `json:"item"`
        ImageURL  string `json:"image_url"`
        IsSubject string `json:"is_subject"`
        Sitelink  string `json:"sitelink"`
    } `json:"wiki"`
    Dictionary struct {
        Prons struct {
            EnUs string `json:"en-us"`
            En   string `json:"en"`
        } `json:"prons"`
        Explanations []string    `json:"explanations"`
        Synonym      []string    `json:"synonym"`
        Antonym      []string    `json:"antonym"`
        WqxExample   []string    `json:"wqx_example"`
        Entry        string      `json:"entry"`
        Type         string      `json:"type"`
        Related      interface{} `json:"related"`
        Source       string      `json:"source"`
    } `json:"dictionary"`
}

func query(word string) {
	client := &http.Client{}
	//设置结构体，便于序列化
	request := DictRequest{TransType: "en2zh", Source: word}
	//序列化
	buf, err := json.Marshal(request)
	if err != nil {
		log.Fatal(err)
	}
	//将buf包装为io.Reader 类型的数据流对象 data，可以让数据被逐字节地读取，适合用作 HTTP 请求体
	var data = bytes.NewReader(buf)
	//创建了一个新的 HTTP 请求对象 req，请求方法为 POST
	req, err := http.NewRequest("POST", "https://api.interpreter.caiyunapp.com/v1/dict", data)
	if err != nil {
		log.Fatal(err)
	}
	//设置请求头
	req.Header.Set("Connection", "keep-alive")
	req.Header.Set("DNT", "1")
	req.Header.Set("sec-ch-ua-mobile", "?0")
	req.Header.Set("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36")
	req.Header.Set("app-name", "xy")
	req.Header.Set("Content-Type", "application/json;charset=UTF-8")
	req.Header.Set("Accept", "application/json, text/plain, */*")
	req.Header.Set("device-id", "")
	req.Header.Set("os-type", "web")
	req.Header.Set("X-Authorization", "token:qgemv4jiy38j4gv6uvhj")
	req.Header.Set("Referer", "https://fanyi.caiyunapp.com/")
	req.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
	req.Header.Set("Cookie", "_ym_uid=1645984782032859353; _ym_d=1645984782")
	//进行网络请求
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	//读取响应
	bodyText, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatal(err)
	}

	if resp.StatusCode != 200 {
		log.Fatal("bad StatusCode:", resp.StatusCode, "body", string(bodyText))
	}
	//定义响应体
	var dictResponse DictResponse
	//反序列化
	err = json.Unmarshal(bodyText, &dictResponse)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(word, "UK:", dictResponse.Dictionary.Prons.En, "US:", dictResponse.Dictionary.Prons.EnUs)
	for _, item := range dictResponse.Dictionary.Explanations {
		fmt.Println(item)
	}
}

func main(){
	if(len(os.Args)!=2){
		fmt.Println("error")
		os.Exit(1)
	}
	word:=query(os.Args[1])
	fmt.Println(word)
}
```

**Socks5代理服务器**

作用是在防火墙中开一个端口，便于通过这个端口去访问资源

![image-20241105093720656](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20241105093720656.png)

TCP echo server

实现监听，读取信息，打印信息

```go
package main

import (
    "bufio"
    "log"
    "net"
)

func main() {
  //监听端口
    server, err := net.Listen("tcp", "127.0.0.1:1080")
    if err != nil {
        panic(err)
    }
//在死循环里面用server接受请求
    for {
        client, err := server.Accept()
        if err != nil {
            log.Printf("Accept failed %v", err)
            continue
        }
      //启用的gorutinue
        go process(client)
    }
}
//处理连接
func process(conn net.Conn) {
  //关掉连接，连接的生命周期就是函数的声明周期
    defer conn.Close()
    reader := bufio.NewReader(conn)
    for {
        b, err := reader.ReadByte()
        if err != nil {
            break
        }
        _, err = conn.Write([]byte{b})
        if err != nil {
            break
        }
    }
}
```

实现auth函数，修改源代码

```go
package main

import (
    "bufio"
    "log"
    "net"
)

func main() {
  //监听端口
    server, err := net.Listen("tcp", "127.0.0.1:1080")
    if err != nil {
        panic(err)
    }
//在死循环里面用server接受请求
    for {
        client, err := server.Accept()
        if err != nil {
            log.Printf("Accept failed %v", err)
            continue
        }
      //启用的gorutinue
        go process(client)
    }
}
// process 函数
func process(conn net.Conn) {
  //使用 defer conn.Close() 确保函数退出时自动关闭客户端连接。
    defer conn.Close()
  //使用 bufio.NewReader 包装客户端连接，方便后续逐字节读取数据
    reader := bufio.NewReader(conn)
  //调用 auth 函数进行认证
    err := auth(reader, conn)
    if err != nil {
        log.Printf("client %v auth failed: %v", conn.RemoteAddr(), err)
        return
    }
  //授权后，进行连接
    err = connect(reader, conn)
    if err != nil {
        log.Printf("client %v auth failed: %v", conn.RemoteAddr(), err)
        return
    }
}

// connect 函数
func connect(reader *bufio.Reader, conn net.Conn) (err error) {
    // VER | CMD | RSV | ATYP | DST.ADDR | DST.PORT
  //之前使用newByte进行读，这里可以先创建一个长度为4的缓冲区
    buf := make([]byte, 4)
  //接着使用io.ReadFull来填充满
    _, err = io.ReadFull(reader, buf)
    if err != nil {
        return fmt.Errorf("read header failed: %w", err)
    }
	//接下来就验证每个type的正确性
    ver, cmd, atyp := buf[0], buf[1], buf[3]
  //检查 ver 是否为 socks5Ver（即 0x05）
    if ver != socks5Ver {
        return fmt.Errorf("not supported ver: %v", ver)
    }
  //检查cmd 是否为 cmdBind（即 0x01）
    if cmd != cmdBind {
        return fmt.Errorf("not supported cmd: %v", ver)
    }

    var addr string
  //使用 switch 语句根据 atyp 的值（地址类型）来选择不同的地址解析方式
    switch atyp {
        case atypIPv4:
            buf = make([]byte, 4)
            err = io.ReadFull(reader, buf)
            if err != nil {
                return fmt.Errorf("read atyp failed: %w", err)
            }
            addr = fmt.Sprintf("%d.%d.%d.%d", buf[0], buf[1], buf[2], buf[3])
        case atypHOST:
     //当 atyp 等于 atypHOST（即 0x03）时，首先读取一个字节 hostSize，表示主机名的长度
            hostSize, err := reader.ReadByte()
            if err != nil {
                return fmt.Errorf("read hostSize failed: %w", err)
            }
     //创建一个长度为 hostSize 的字节数组 host，然后从 reader 中读取指定长度的主机名
            host := make([]byte, hostSize)
            _, err = io.ReadFull(reader, host)
            if err != nil {
                return fmt.Errorf("read host failed: %w", err)
            }
      //将读取到的字节数组转换为字符串形式，存储在 addr 中
            addr = string(host)
        case atypIPv6:
            return errors.New("IPv6: no supported yet")
        default:
            return errors.New("invalid atyp")
    }
	//创建一个长度为 2 的字节数组 buf 用于读取端口号
    buf = make([]byte, 2)
    _, err = io.ReadFull(reader, buf)
    if err != nil {
        return fmt.Errorf("read port failed: %w", err)
    }
  //使用 binary.BigEndian.Uint16(buf) 将 2 字节数据转换为无符号的 16 位整数（即端口号），并存储在 port 中
    port := binary.BigEndian.Uint16(buf)
  	//使用 net.Dial("tcp", fmt.Sprintf("%v:%v", addr, port)) 建立一个 TCP 连接
    dest, err := net.Dial("tcp", fmt.Sprintf("%v:%v", addr, port))
    if err != nil {
        return fmt.Errorf("dial dst failed: %w", err)
    }
    defer dest.Close()
    log.Println("dial", addr, port)

    // 响应 VER | REP | RSV | ATYP | BND.ADDR | BND.PORT
  //向客户端发送一个成功响应，表示代理服务器接受了客户端的请求
    _, err = conn.Write([]byte{0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00})
    if err != nil {
        return fmt.Errorf("write failed: %w", err)
    }
    return nil
}

// auth 函数实现了 SOCKS5 的认证流程，主要负责协议版本的校验和认证方法的选择
func auth(reader *bufio.Reader, conn net.Conn) (err error) {
    // VER | NMETHODS | METHODS
  	//从客户端读取第一个字节（ver），表示 SOCKS 协议的版本号
    ver, err := reader.ReadByte()
    if err != nil {
        return fmt.Errorf("read ver failed: %w", err)
    }
    if ver != socks5Ver {
        return fmt.Errorf("not supported ver: %v", ver)
    }
  	//从客户端读取一个字节，表示客户端支持的认证方法数量
    methodSize, err := reader.ReadByte()
    if err != nil {
        return fmt.Errorf("read methodSize failed: %w", err)
    }
  	//根据 methodSize 的大小，创建一个字节数组 method，用于存储客户端支持的认证方法
  	//创建io的缓冲区
    method := make([]byte, methodSize)
  	//ReadFull来填充满，指定数量的字节（即 methodSize 个字节）到 method 数组中
    _, err = io.ReadFull(reader, method)
    if err != nil {
        return fmt.Errorf("read method failed: %w", err)
    }
    log.Println("ver", ver, "method", method)

    // 返回 VER | METHOD
  	//服务器在认证阶段完成后，向客户端发送一个响应，表示协议版本和认证状态
    _, err = conn.Write([]byte{socks5Ver, 0x00})
    if err != nil {
        return fmt.Errorf("write failed: %w", err)
    }
  //接下来就可以浏览器服务器间进行双向数据转化
  //正常如果就创建两个go线程进行数据交换，主线程就会直接到最后一行导致函数结束，所以这里需要用到context，主线程会停止在Done那里，直到等到context执行完成，即某一方完成或发生错误时，将会调用 cancel()，解除阻塞，主 goroutine 继续执行，进而退出当前函数。
  ctx, cancel := context.WithCancel(context.Background())
  defer cancel()
  go func() {
      _, _ = io.Copy(dest, reader)
      cancel()
  }()
  go func() {
      _, _ = io.Copy(conn, dest)
      cancel()
  }()
  <-ctx.Done()
    return nil
}
```

