---
layout: post
title: "go学习"
subtitle: "go学习"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
- go

---

#### 基础语法

**变量**

```go
package main

import (
    "fmt"
    "math"
)

func main() {
    var a = "initial"

    var b, c int = 1, 2

    var d = true

    var e float64

    f := float32(e)

    g := a + "foo"
    fmt.Println(a, b, c, d, e, f) // initial 1 2 true 0 0
    fmt.Println(g)                // initialfoo

    const s string = "constant"
    const h = 500000000
    const i = 3e20 / h
    fmt.Println(s, h, i, math.Sin(h), math.Sin(i))
}
```

**if else**

```go
package main

import "fmt"

func main() {
    if 7%2 == 0 {
        fmt.Println("7 is even")
    } else {
        fmt.Println("7 is odd")
    }

    if 8%4 == 0 {
        fmt.Println("8 is divisible by 4")
    }

    if num := 9; num < 0 {
        fmt.Println(num, "is negative")
    } else if num < 10 {
        fmt.Println(num, "has 1 digit")
    } else {
        fmt.Println(num, "has multiple digits")
    }
}
```

**循环**

go中没有while、do-while循环，只有for循环

```go
package main

import "fmt"

func main() {
    i := 1
  //死循环
    for {
        fmt.Println("loop")
        break
    }
//这里面三段任何一段都可以省略
    for j := 7; j < 9; j++ {
        fmt.Println(j)
    }

    for n := 0; n < 5; n++ {
        if n%2 == 0 {
            continue
        }
        fmt.Println(n)
    }

    for i <= 3 {
        fmt.Println(i)
        i = i + 1
    }
}
```

**switch**

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    a := 2
  //go中不需要break，可以用任何类型
    switch a {
    case 1:
        fmt.Println("one")
    case 2:
        fmt.Println("two")
    case 3:
        fmt.Println("three")
    case 4, 5:
        fmt.Println("four or five")
    default:
        fmt.Println("other")
    }

    t := time.Now()
  //甚至不需要变量
    switch {
    case t.Hour() < 12:
        fmt.Println("It's before noon")
    default:
        fmt.Println("It's after noon")
    }
}
```

**数组**

```go
package main

import "fmt"

func main() {
    var a [5]int
    a[4] = 100
    fmt.Println(a[4], len(a))

    b := [5]int{1, 2, 3, 4, 5}
  //也可以不设置大小值
  //b := []int{1, 2, 3, 4, 5}
    fmt.Println(b)

    var twoD [2][3]int
    for i := 0; i < 2; i++ {
        for j := 0; j < 3; j++ {
            twoD[i][j] = i + j
        }
    }
    fmt.Println("2d: ", twoD)
}
```

**切片**

```go
package main

import "fmt"

func main() {
    s := make([]string, 3)
    s[0] = "a"
    s[1] = "b"
    s[2] = "c"
    fmt.Println("get:", s[2])    // c
    fmt.Println("len:", len(s))   // 3

    s = append(s, "d")
    s = append(s, "e", "f")
    fmt.Println(s)                // [a b c d e f]

    c := make([]string, len(s))
    copy(c, s)
    fmt.Println(c)                // [a b c d e f]

    fmt.Println(s[2:5])           // [c d e]
    fmt.Println(s[:5])            // [a b c d e]
    fmt.Println(s[2:])            // [c d e f]

    good := []string{"g", "o", "o", "d"}
    fmt.Println(good)             // [g o o d]
}
```

**map**

```go
package main

import "fmt"

func main() {
    m := make(map[string]int)
    m["one"] = 1
    m["two"] = 2
    fmt.Println(m)                // map[one:1 two:2]
    fmt.Println(len(m))           // 2
    fmt.Println(m["one"])         // 1
    fmt.Println(m["unknow"])      // 0

    r, ok := m["unknow"]
    fmt.Println(r, ok)            // 0 false

    delete(m, "one")

    m2 := map[string]int{"one": 1, "two": 2}
    var m3 = map[string]int{"one": 1, "two": 2}
    fmt.Println(m2, m3)
}
```

**range**

用于快速，简洁遍历数组

```go
package main

import "fmt"

func main() {
    nums := []int{2, 3, 4}
    sum := 0
    for i, num := range nums {
        sum += num
        if num == 2 {
            fmt.Println("index:", i, "num:", num) // index: 0 num: 2
        }
    }
    fmt.Println(sum) // 9

    m := map[string]string{"a": "A", "b": "B"}
    for k, v := range m {
        fmt.Println(k, v) // b B; a A
    } 
    for k := range m {
        fmt.Println("key", k) // key a; key b
    }
}
```

**函数**

```go
package main

import "fmt"

func add(a int, b int) int {
    return a + b
}

func add2(a, b int) int {
    return a + b
}

func exists(m map[string]string, k string) (v string, ok bool) {
    v, ok = m[k]
    return v, ok
}

func main() {
    res := add(1, 2)
    fmt.Println(res) // 3

    v, ok := exists(map[string]string{"a": "A"}, "a")
    fmt.Println(v, ok) // A true
}
```

**指针**

```go
package main

import "fmt"

func add2(n int) {
    n += 2
}

func add2ptr(n *int) {
    *n += 2
}

func main() {
    n := 5
    add2(n)
    fmt.Println(n) // 5
    add2ptr(&n)
    fmt.Println(n) // 7
}
```

**结构体**

```go
package main

import "fmt"

type user struct {
    name     string
    password string
}

func main() {
  //结构体的几种声明变量的方式
    a := user{name: "wang", password: "1024"}
    b := user{"wang", "1024"}
    c := user{name: "wang"}
    c.password = "1024"
    var d user
    d.name = "wang"
    d.password = "1024"

    fmt.Println(a, b, c, d) // {wang 1024} {wang 1024} {wang 1024} {wang 1024}
    fmt.Println(checkPassword(a, "haha"))   // false
    fmt.Println(checkPassword2(&a, "haha")) // false
}
//结构体传递可以有指针和非指针两种方式
//这和java不一样，java这种传的都是引用，但go这里如果不传指针形式的话，是不会改变原始值的
func checkPassword(u user, password string) bool {
    return u.password == password
}

func checkPassword2(u *user, password string) bool {
    return u.password == password
}
```

**结构体方法**

在函数名前面的 (u user) 或 (u *user) 称为**接收者**。接收者指定了这个方法属于哪个类型（例如 user 结构体），因此该方法成为了这个类型的**方法**。

类似于java的类成员函数

```go
package main

import "fmt"

type user struct {
    name     string
    password string
}
//适合用于不改变结构体内容的场景，如只读操作
func (u user) checkPassword(password string) bool {
    return u.password == password
}
//适合用于需要修改结构体内容的场景，如更新密码
func (u *user) resetPassword(password string) {
    u.password = password
}

func main() {
    a := user{name: "wang", password: "1024"}
    a.resetPassword("2048")
    fmt.Println(a.checkPassword("2048")) // true
}
```

**错误处理**

```go
package main

import (
    "errors"
    "fmt"
)

type user struct {
    name     string
    password string
}

func findUser(users []user, name string) (v *user, err error) {
    for _, u := range users {
        if u.name == name {
            return &u, nil
        }
    }
    return nil, errors.New("not found")
}

func main() {
  //定义函数返回值有err
    u, err := findUser([]user{{"wang", "1024"}}, "wang")
  //所以首先判断err
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(u.name) // wang

    if u, err := findUser([]user{{"wang", "1024"}}, "li"); err != nil {
        fmt.Println(err) // not found
        return
    } else {
        fmt.Println(u.name)
    }
}
```

**字符串**

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    a := "hello"
    fmt.Println(strings.Contains(a, "ll"))          // true
    fmt.Println(strings.Count(a, "l"))              // 2
    fmt.Println(strings.HasPrefix(a, "he"))         // true
    fmt.Println(strings.HasSuffix(a, "llo"))        // true
    fmt.Println(strings.Index(a, "ll"))             // 2
    fmt.Println(strings.Join([]string{"he", "llo"}, "-")) // he-llo
    fmt.Println(strings.Repeat(a, 2))               // hellohello
    fmt.Println(strings.Replace(a, "e", "E", -1))   // hEllo
    fmt.Println(strings.Split("a-b-c", "-"))        // [a b c]
    fmt.Println(strings.ToLower(a))                 // hello
    fmt.Println(strings.ToUpper(a))                 // HELLO
    fmt.Println(len(a))                             // 5

    b := "你好"
    fmt.Println(len(b))                             // 6
}
```

**字符串格式化**

```go
package main

import "fmt"

type point struct {
    x, y int
}

func main() {
    s := "hello"
    n := 123
    p := point{1, 2}
    fmt.Println(s, n)             // hello 123
    fmt.Println(p)                // {1 2}
//有各种占位符，用%v可以代替各种类型的符
    fmt.Printf("s=%v\n", s)       // s=hello
    fmt.Printf("n=%v\n", n)       // n=123
    fmt.Printf("p=%v\n", p)       // p={1 2}
    fmt.Printf("p=%+v\n", p)      // p={x:1 y:2}
    fmt.Printf("p=%#v\n", p)      // p=main.point{x:1, y:2}

    f := 3.141592653
    fmt.Println(f)                // 3.141592653
    fmt.Printf("%.2f\n", f)       // 3.14
}
```

**JSON处理**

结构体中每个字段首字母要大写，就可以用json.Marshal进行序列化

```go
package main

import (
    "encoding/json"
    "fmt"
)

type userInfo struct {
    Name  string
    Age   int      `json:"age"`
    Hobby []string
}

func main() {
    a := userInfo{Name: "wang", Age: 18, Hobby: []string{"Golang", "TypeScript"}}
  //将结构体进行序列化
    buf, err := json.Marshal(a)
    if err != nil {
        panic(err)
    }
    fmt.Println(buf)              // [123 34 97 103 ...]
    fmt.Println(string(buf))       // {"Name":"wang","age":18,"Hobby":["Golang","TypeScript"]}

    buf, err = json.MarshalIndent(a, "", "\t")
    if err != nil {
        panic(err)
    }
    fmt.Println(string(buf))       // 格式化后的 JSON 输出

    var b userInfo
  //buff反序列化到b中
    err = json.Unmarshal(buf, &b)
    if err != nil {
        panic(err)
    }
    fmt.Printf("%#v\n", b)         // main.userInfo{Name:"wang", Age:18, Hobby:[]string{"Golang", "TypeScript"}}
}
```

**时间处理**

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    now := time.Now()
    fmt.Println(now) // 当前时间，示例：2022-03-27 18:04:59.433297 +0800 CST m=+0.000087933

    t := time.Date(2022, 3, 27, 1, 25, 36, 0, time.UTC)
    t2 := time.Date(2022, 3, 27, 2, 30, 36, 0, time.UTC)
    fmt.Println(t) // 2022-03-27 01:25:36 +0000 UTC

    fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) // 输出各时间字段，例如：2022 March 27 1 25
    fmt.Println(t.Format("2006-01-02 15:04:05")) // 格式化时间输出：2022-03-27 01:25:36
	//得到时间段
    diff := t2.Sub(t)
    fmt.Println(diff) // 时间差，示例：1h5m0s
    fmt.Println(diff.Minutes(), diff.Seconds()) // 时间差的分钟数和秒数，例如：65 3900

    t3, err := time.Parse("2006-01-02 15:04:05", "2022-03-27 01:25:36")
    if err != nil {
        panic(err)
    }
    fmt.Println(t3 == t) // true，判断解析的时间是否等于原始时间
	//获取时间戳
    fmt.Println(now.Unix()) // 输出当前时间的 Unix 时间戳，例如：1648378800
}
```

**字符串数字间转化**

```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
  
  //strconv.ParseFloat：将字符串解析为浮点数。参数 64 表示转换为 float64 类型
    f, _ := strconv.ParseFloat("1.234", 64)
    fmt.Println(f)               // 1.234
  
	//strconv.ParseInt：将字符串解析为指定进制的整数。参数 10 表示十进制，0 表示自动识别进制（如 "0x" 前缀会识别为十六进制）。参数 64 指定目标类型为 int64
    n, _ := strconv.ParseInt("111", 10, 64)
    fmt.Println(n)               // 111

    n, _ = strconv.ParseInt("0x1000", 0, 64)
    fmt.Println(n)               // 4096

  //专门用于将十进制字符串转换为整数，返回 int 类型
    n2, _ := strconv.Atoi("123")
    fmt.Println(n2)              // 123
  //解析失败
    n2, err := strconv.Atoi("AAA")
    fmt.Println(n2, err)         // 0 strconv.Atoi: parsing "AAA": invalid syntax
}
```

**进程信息**

```go
package main

import (
    "fmt"
    "os"
    "os/exec"
)

func main() {
    // go run example/20-env/main.go a b c d
  	//os.Args是切片，所以可以用args := os.Args[1:]获取输入参数
    fmt.Println(os.Args)           // 输出程序参数，例如：[path/to/exe a b c d]

    fmt.Println(os.Getenv("PATH")) // 获取环境变量 PATH，例如：/usr/local/go/bin...
    fmt.Println(os.Setenv("AA", "BB")) // 设置环境变量 AA=BB

    buf, err := exec.Command("grep", "127.0.0.1", "/etc/hosts").CombinedOutput()
    if err != nil {
        panic(err)
    }
    fmt.Println(string(buf))       // 输出 grep 结果，例如：127.0.0.1 localhost
}
```

#### go实战案例

##### 猜谜游戏

```go
package main

import(
	"fmt"
	"math/rand"
	"bufio"
	"strings"
	"os"
	"strconv"
)

func main(){
	maxNum:=100
	secretNum:=rand.Intn(maxNum)
	fmt.Println("input your guess")
	reader:=bufio.NewReader(os.Stdin)
	for{
		input,err:=reader.ReadString('\n')
		if err != nil{
			fmt.Println("An error occured while inputing",err)
			continue
		}
		input=strings.TrimSuffix(input,"\n")
		guess,err:=strconv.Atoi(input)
		if err!=nil{
			fmt.Println("Invalid input")
			continue
		}
		fmt.Println("your guess is",guess)
		if guess > secretNum{
			fmt.Println("bigger")
		}else if guess<secretNum{
			fmt.Println("smaller")
		}else{
			fmt.Println("bingo")
			break
		}
	}
}
```

