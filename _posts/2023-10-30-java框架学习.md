---
layout: post
title: "java框架学习"
subtitle: "java框架学习"
author: "DYC"
header-img: "img/post-bg-linux.jpg"
header-mask: 0.3
catalog: true
tags:
  - java


---

java框架学习

#### 前端学习

##### html

特点

![image-20231029213833047](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029213833047.png)

事例

![image-20231029214246223](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029214246223.png)

##### css

![image-20231029214528728](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029214528728.png)

三种引入方式

![image-20231029215028461](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029215028461.png)

css选择器

![image-20231029215638716](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029215638716.png)

##### javascript

![image-20231029230249022](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029230249022.png)

**基础语法**

![image-20231029230540840](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029230540840.png)

输出语句的三种方式

![image-20231029231200485](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029231200485.png)

**变量**

![image-20231029231613012](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029231613012.png)

1.可以重复定义；2.作用域是全局

![image-20231029232333606](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029232333606.png)

**变量的数据类型**

![image-20231029232603556](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029232603556.png)

![image-20231029233107247](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029233107247.png)

**函数**

![image-20231029233354707](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231029233354707.png)

**数组对象**

![image-20231030205842535](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030205842535.png)

![image-20231030205939477](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030205939477.png)

**String对象**

![image-20231030211549773](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030211549773.png)

**Json对象**

现在常用于数据载体，在网络进行数据传递

![image-20231030212700085](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030212700085.png)

![image-20231030213030529](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030213030529.png)

**Bom对象**

![image-20231030213227148](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030213227148.png)

window对象

![image-20231030213252392](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030213252392.png)

![image-20231030214523689](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030214523689.png)

**DOM**

将标记语言各个组成部分封装成对应对象

![image-20231030221054554](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030221054554.png)

基本上包括两个操作

- 通过上面的元素对象方法获取到标签对应的元素对象
- 查询各个对象的方法，完成对应的修改状态的操作

**事件监听**

![image-20231030221609566](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030221609566.png)

事件绑定

![image-20231030221644658](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030221644658.png)

![image-20231030221852193](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030221852193.png)

##### Vue

![image-20230414105417711](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20230414105417711.png)

![image-20231030224506500](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030224506500.png)

![image-20231030224710399](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030224710399.png)

![image-20231030225420114](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030225420114.png)

**v-if是没有满足条件，则浏览器不会进行渲染，而v-show当没有满足条件时，浏览器会渲染，但是会隐藏该元素，不进行显示**

![image-20231030225504237](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030225504237.png)

![image-20231030225944488](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030225944488.png)

**生命周期**

在对应的生命周期，就会自动调用该生命周期里面的方法

![image-20231030230425051](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030230425051.png)

##### Ajax

在服务器端和前端进行数据交互，并且是异步的方式，可以只更新部分页面

![image-20231030230827743](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030230827743.png)

同步的话当进行服务器端的数据请求的时候，必须要等到服务器响应返回之后才能进行其他操作，比如点击超链接，在进入新网址的过程就是同步的操作

![image-20231030231429298](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030231429298.png)

**原生Ajax**

![image-20231030231616541](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030231616541.png)

但原生的Ajax操作比较繁琐，所以现在用的比较多的是它的升级版，比如**axios**

##### Axios

![image-20231030231914185](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030231914185.png)

![image-20231030232103434](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030232103434.png)

简化上面的操作

![image-20231030232640405](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030232640405.png)

##### 前后端分离开发

一个功能叫做一个接口，通过接口文档来规范前后端开发的要求

![image-20231030233752094](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030233752094.png)

![image-20231030233902397](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231030233902397.png)

**接口文档管理平台**比如

**YAPI**

##### 前端工程化

**环境准备**

**脚手架 vue-cli**

![image-20231101091650781](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101091650781.png)

![image-20231101092000994](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101092000994.png)

对于第二种方法 图形化界面

![image-20231101092054132](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101092054132.png)

![image-20231101092112289](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101092112289.png)

![image-20231101092127838](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101092127838.png)

![image-20231101092150597](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101092150597.png)

**vue项目结构**

![image-20231101092511646](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101092511646.png)

vue项目的**默认首页**

![image-20231101093133272](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101093133272.png)

vue项目中每个**vue文件的结构**如下

![image-20231101093352774](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101093352774.png)

**前端组件**

使用elementUI的步骤

![image-20231101094828412](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101094828412.png)

这个引入ElementUI组件库是在main.js中引入

然后编写好vue文件之后在app.vue中进入引入，就可以显示

![image-20231101100423059](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101100423059.png)

案例：根据页面完成员工管理页面开发，通过Axios完成数据的异步加载

![image-20231101102215834](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101102215834.png)

对于第一步第二步都可以在elementUI里面直接找到 进行复制添加

对于第三步，首先进行安装引入

![image-20231101103444424](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101103444424.png)

**Vue路由**

![image-20231101104309540](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101104309540.png)

首先配置路由信息

![image-20231101104615730](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101104615730.png)

然后在对应菜单位置加入router-link

![image-20231101104819535](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101104819535.png)

接着在APP.vue中加入router-view 进行显示

最后要设置一个根路径 对其进行重定向

![image-20231101105114651](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101105114651.png)

**vue项目打包部署**

**打包**

![image-20231101105227633](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101105227633.png)

**部署**

![image-20231101105329592](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101105329592.png)

##### Maven

![image-20231101110449433](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101110449433.png)

![image-20231101110611255](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231101110611255.png)

![image-20231102220342127](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102220342127.png)

**Maven安装**

![image-20231102221333394](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102221333394.png)

**在idea中进行maven的配置**

![image-20231102222022571](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102222022571.png)

![image-20231102222051760](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102222051760.png)

![image-20231102222118373](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102222118373.png)

![](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102224236270.png)

**创建maven项目**

![image-20231102224532619](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102224532619.png)

**Maven中依赖具有传递性**

**Maven依赖也可以设置有效范围**

![image-20231102235544863](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231102235544863.png)

**生命周期**

![image-20231104143912004](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104143912004.png)

#### Web

**创建SpringBoot项目**

![image-20231104145306237](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104145306237.png)

定义一个请求处理类

让这个类成为请求处理类，主要是因为下面两个注解，@RestController和@RequestMapping

```java
@RestController
public class hellocontroller {

    @RequestMapping(value = "/hello",method = RequestMethod.GET)
    public String hello(String name){
        return "hello "+name;
    }
}
```

##### **http协议**

![image-20231104150931388](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104150931388.png)

**http请求数据格式**

![image-20231104151528511](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104151528511.png)

**http响应数据格式**

![image-20231104152123146](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104152123146.png)

对于响应行、响应头各个参数的意义

![image-20231104152210071](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104152210071.png)

遇到报错的时候，可以在开发者工具看看状态码来定位错误的位置

**http协议的解析**

serverSocket可以协议解析

服务器端对于http协议的解析很复杂，需要考虑各种情况，但因为http格式的固定的，所以有很多已经封装好的http解析程序，包括tomcat，jetty等

[http与https的区别](https://blog.csdn.net/yzhcjl_/article/details/131488393?spm=1001.2014.3001.5502)

**Tomcat**

Tomcat是一款流行的开源Web服务器和Servlet容器，它提供了Java Servlet和JavaServer Pages（JSP）运行环境。

Tomcat允许开发人员编写Java Web应用程序并将其部署到服务器上，以便客户端可以访问这些Web应用程序。

![image-20231104154223242](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104154223242.png)

springBoot内嵌了tomcat，所以不需要再下载安装tomcat，直接使用springboot即可

##### **前后端请求**

springboot底层有一个DispatcherSerlet，可以和tomcat对接，tomcat从浏览器获取的http信息之后会被DispatcherSerlet封装城HttpServletRequest对象，然后发送给对应的controller类，同理响应也是通过它

![image-20231104161651546](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104161651546.png)

**请求过程中的常见参数及封装**

对于简单的参数，服务器端获取可以通过**HttpServletRequest对象**来获取，然后使用该参数

![image-20231104162750895](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104162750895.png)

这种方式比较繁琐，并且需要手动的进行类型转化，所以一般不用，springboot给了一种更简单的方式，直接定义变量

![image-20231104163152413](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104163152413.png)

**请求名可以和参数名**不一致，使用注解**@RequestParam**完成映射

![image-20231104165733616](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104165733616.png)

该注解有**required属性**，可以设置false，表示该参数可以选择传递也可以不传

**对于pojo类型的参数**

如果参数太多，可以考虑将这些参数封装到实体类当中，即**pojo对象**，然后进行传递，比如：

```java
@PostMapping("/user")
public String save(user user){
    int i=usermapper.insert(user);
    if(i>0){
        return "success";
    }else {
        return "fail";
    }
}
```

**对于数组类型的参数**

比如前端遇到一个多选项，这个时候就可以使用数组的方式进行数据的传递

![image-20231104170946666](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104170946666.png)

也可以使用集合的方式，不过默认是数组，所以需要**@RequestParam**进行绑定

```java
@RequestMapping ("/listParam")
public String listParam(@RequestParam List<String> hobby) {
    System.out.printIn(hobby) ;
    return "OK";
}
```

**对于日期类型的参数**

![image-20231104171636082](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104171636082.png)

**对于json类型的参数**

json格式的参数只能使用post方式进行请求，在postman中Body请求体中设置参数，选择raw，json格式，然后输入json中各个参数的值

![image-20231104172350057](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104172350057.png)

需要使用到注解**`@RequestBody`** ，它是 Spring 框架中的一个注解，它用于将 HTTP 请求的内容体（body）部分绑定到方法的参数上，将json格式的数据封装到pojo对象上

**对于路径类型的参数**

![image-20231104173037289](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104173037289.png)

##### **前后端响应**

后端数据进行响应的时候，其实依赖于一个注解@ResponseBody，该注解的作用是将方法返回值直接响应，如果返回对象是实体或者集合，就自动转化为json格式进行响应

![image-20231104183925487](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104183925487.png)

一般直接用@RestController=@Controller+@ResponseBody

为了方便管理，一般都使用统一的响应结果类，包含响应码，返回数据等

![image-20231104184455856](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104184455856.png)

案例

![image-20231104185032826](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104185032826.png)

编写其中的Controller类

![](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104185834372-20231104190029464.png)

##### **分层解耦**

如果加载数据，处理处理，响应都写在一个方法里，复用性维护性差，所以考虑分层

**分层**

**三层架构**

**mapper层进行数据访问，service层进行逻辑处理，controller层进行接受请求，数据响应**

对于mapper层这种，可能存在获取数据的方式有多种，所以对于每一种数据单独创建一个interface接口，然后再创建对应的impl实现类进行实现

![image-20231104191709842](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104191709842.png)

**解耦**

上面的写法耦合度很高，比如说上面的service层修改了类名，或者要换一个实现类，就还要改controller层里的代码，这样代码维护困难

解耦的操作是**定义一个容器**，比如**将创建好的service对象存放在容器里**，**controller层通过容器来调用该对象**，进行对应的操作

对于这个容器怎样存储对象，和怎么从容器中提取对象来进行操作，spring提供了相应的操作，**控制反转和依赖注入**

![image-20231104192711653](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104192711653.png)

在springboot中这两个操作都可以通过注解完成

**控制反转**：通过**@Component**注解，将对应实现类交与IOC容器进行管理

**依赖注入**：通过**@Autowired**注解，将容器里的对象注入运行

![image-20231104193217079](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104193217079.png)

所以对于service层和mapper层定义接口也是有必要的，修改的是实现类，通过依赖注入，直接调用接口的名

当要切换实现类时，直接删除对应的component注解，从容器中剔除即可

**IOC详解**

对不同的层使用不同的component注解，方便管理，对于不属于这三层的一些工具类可以使用component注解进行ioc管理

![image-20231104193821743](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104193821743.png)

对于spring怎么去找这些component注解，spring提供了一个叫@ComponentScan的注解，该注解可以去扫描一些包的位置，去找到这些bean对象

Springboot底层中默认还有该注解，扫描的是当前包及其子包，如果在其他位置时，就需要在项目入口文件中添加@ComponentScan这个注解，将所有的bean对象的位置包含进去

![image-20231104194857192](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104194857192.png)

**DI详解**

如果存在同一个类型的多个bean对象，就会出错，不知道该自动注入哪一个bean，但可以通过下面注解进行解决

![image-20231104195644094](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104195644094.png)

![image-20231104195710738](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231104195710738.png)

#### MySQL

##### 语法

![image-20231105121430687](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105121430687.png)

**DDL**

![image-20231105121956359](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105121956359.png)

![image-20231105124158145](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105124158145.png)

创建表时要注意数据类型，字段一共有三种数据类型

![image-20231105124614061](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105124614061.png)

![image-20231105131334930](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105131334930.png)

![image-20231105131348257](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105131348257.png)

**修改表操作**

![image-20231105153815812](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105153815812.png)

**DML**

![image-20231105153912238](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105153912238.png)

**DQL**

![image-20231105154709431](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105154709431.png)

**分组查询**

![image-20231105163342849](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105163342849-20231105163544803.png)

![image-20231105163428115](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105163428115.png)

**分页查询**

![image-20231105163955758](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105163955758.png)

##### **多表设计**

**一对多的表结构**

![image-20231105195221088](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105195221088.png)

当多表之间存在联系的时候，如果删除一个表的字段，就要考虑对另一个表的相应数据进行修改，这个时候就可以使用**外键**进行关联

![image-20231105200003049](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105200003049.png)

上述外键属于物理外键，存在下面的缺点

- 影响增删改查效率
- 仅适用于单一的数据库，不适用于分布式，集群的场景
- 容易引发死锁等

**一对一的表结构**

![image-20231105200718218](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105200718218.png)

**多对多的表结构**

对于多对多的结构，不能直接使用外键，因为外键是两张表一对一或者一对多的关系，所以对于多对多的结构，可以添加一个中间表，成为两个一对多

![image-20231105201211044](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105201211044.png)

创建表的步骤

1. 了解需求，分析各个模块涉及到的表结构，及表之间的关系

   ![image-20231105203917389](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105203917389.png)

2. 根据要求，分析具体的字段及约束

   ![image-20231105204013556](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105204013556.png)

##### **多表查询**

当直接select * from table1,table2的时候，查询的数据的数量是num(table1)*num(table2)，是两个表进行笛卡尔积的数量，所以真正需要的数据需要where条件，从这笛卡尔积之后的数据中进行筛选，拿到真实的数据

多表查询分为两种，一种是连接查询，一种是子查询

![image-20231105211544260](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105211544260.png)

**内连接查询**

![image-20231105211649242](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105211649242.png)

**外连接查询**

都是从笛卡尔积中进行查找，只是有对应的偏重

左外连接就表示完全包含左表的数据，对应右表的字段要是没有就null，右外连接对应

![image-20231105212102464](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105212102464.png)

**子查询**

![image-20231105225523159](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105225523159.png)

行子查询

![image-20231105232312484](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105232312484.png)

表子查询

![image-20231105232904904](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105232904904.png)

##### **事务**

将多个步骤进行绑定，要成功全部成功，要失败都失败

![image-20231105235154318](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105235154318.png)

事例：

![image-20231105235250858](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105235250858.png)

事务的四大特性

![image-20231105235430093](https://cdn.jsdelivr.net/gh/ddyycc123/imageloader@main/image-20231105235430093.png)
